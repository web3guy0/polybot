================================================================================
                POLYBOT v5.0 - FULL SOURCE CODE ARCHIVE
                Date: 2026-01-18 08:28:32
================================================================================

FILES INCLUDED:
  1. .env
  2. go.mod
  3. cmd/polybot/main.go
  4. internal/config/config.go
  5. internal/arbitrage/engine.go
  6. internal/arbitrage/sniper_strategy.go
  7. internal/arbitrage/whale_strategy.go
  8. internal/arbitrage/scalper.go
  9. internal/arbitrage/clob.go
  10. internal/arbitrage/odds.go
  11. internal/polymarket/window_scanner.go
  12. internal/polymarket/client.go
  13. internal/binance/client.go
  14. internal/database/database.go
  15. internal/bot/telegram.go


================================================================================
FILE: .env
================================================================================
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                    POLYBOT v5.0 - PROFESSIONAL TRADING BOT
#                    Multi-Asset Crypto Prediction Arbitrage
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# SECTION 1: CORE SETTINGS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

DRY_RUN=false
DEBUG=false
TRADING_ASSETS=BTC,ETH,SOL
BANKROLL=4.30

# üêã USE WHALE STRATEGY (set to true to enable whale, disables scalper)
USE_WHALE=true

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# SECTION 2: CREDENTIALS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

TELEGRAM_BOT_TOKEN=8441833779:AAES52VHxeoTsObzFwAPW0iXYtLcktuZchI
TELEGRAM_CHAT_ID=1674347811

CLOB_API_KEY=39480489-6ed5-38b9-0b86-77a0b5c9433d
CLOB_API_SECRET=6p1moua3K5GTKCxcyF6JQLW2JsZx1TlvTYBtoIWQAjM=
CLOB_PASSPHRASE=d2ed22d427248025510f1bc8ed5a58eab0d4c7ebb1b40b84948bc678f3641481

WALLET_PRIVATE_KEY=0x23ac87abc5367acb6625b284aae1a993137830b1816fa82796f79b9f46b834a5
SIGNER_ADDRESS=0xA4C80739928f00d990E46290D132A2dEBC7a3839
FUNDER_ADDRESS=0xB89D418C1f99B746C3BA86406b6595F9f66eBa2f
SIGNATURE_TYPE=1

DATABASE_URL=postgresql://neondb_owner:npg_Ca76zLJiekGd@ep-falling-morning-a1e70wgm-pooler.ap-southeast-1.aws.neon.tech/neondb?sslmode=require

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                           STRATEGY 1: SCALPER
#                     Quick flips on extreme price odds
#                        Best for: Small bankroll ($5)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

SCALPER_POSITION_SIZE=0.50
SCALPER_ENTRY_THRESHOLD=0.15

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                           STRATEGY 2: SWING
#                     Mean reversion on market dips
#                      Best for: Medium bankroll ($20+)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

SWING_MAX_POSITION_USD=2.00
SWING_MAX_POSITIONS=3
SWING_MIN_DROP_PCT=0.12
SWING_COOLDOWN_SEC=30

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                        STRATEGY 3: SNIPER v2.0 ‚≠ê‚≠ê
#                       ULTRA-SAFE Last-Second Sniping
#                  Based on analysis of 153 trades & $160 loss data
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# üî¨ DATA-DRIVEN IMPROVEMENTS:
#    ‚Ä¢ Old: 85-91¬¢ entries, 50¬¢ SL ‚Üí 52% WR but -$55 P&L (losses too big)
#    ‚Ä¢ New: 93-97¬¢ entries, 88¬¢ SL ‚Üí Need 55% WR (tight risk/reward)
#
# üí° KEY INSIGHT: 9 catastrophic 90¬¢‚Üí0¬¢ losses cost -$43.40
#    Solution: Enter LATER (when outcome more certain) + TIGHTER stop loss
#
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Position Size (smaller = less risk per trade)
SNIPER_POSITION_SIZE=2.00

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TIME WINDOW - ULTRA LATE ENTRIES ONLY
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# At 3 min: 52% confidence (coin flip - BAD)
# At 1 min: 70% confidence (okay)
# At 30 sec: 85%+ confidence (GOOD - direction usually locked)
# 
# üéØ TRADE ONLY in last 30-60 seconds when outcome is nearly certain
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SNIPER_MIN_TIME_MIN=0.25
SNIPER_MAX_TIME_MIN=1.0

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ENTRY ODDS - ONLY BUY NEAR-CERTAIN WINNERS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 
# OLD LOGIC (FAILED):
#   Entry at 85-91¬¢ = market says "85-91% chance"
#   But actually ~52% win rate ‚Üí MARKET IS SMARTER THAN BOT
#
# NEW LOGIC:
#   Entry at 93-97¬¢ = market says "93-97% chance"
#   In last 30 sec with 0.1%+ price move = ~80% actual win rate
#   
# MATH:
#   Win: 95¬¢ ‚Üí $1.00 = +5¬¢ profit
#   Loss: 95¬¢ ‚Üí 88¬¢ SL = -7¬¢ loss
#   Breakeven: 58% win rate (80% actual = profitable!)
#
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SNIPER_MIN_ODDS=0.93
SNIPER_MAX_ODDS=0.97
SNIPER_TARGET=0.99
SNIPER_STOP_LOSS=0.88
SNIPER_HOLD_TO_RESOLUTION=true

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PRICE MOVEMENT THRESHOLDS - STRONGER CONFIRMATION REQUIRED
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 
# Old: 0.05% BTC, 0.05% ETH, 0.10% SOL ‚Üí Too weak, caught reversals
# New: 0.10% minimum across all ‚Üí Only trade CLEAR winners
#
# In 15min window, 0.10% move = strong directional signal
# Combined with 93¬¢+ odds + last 60sec = high confidence entry
#
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SNIPER_BTC_MIN_PRICE_MOVE=0.10
SNIPER_ETH_MIN_PRICE_MOVE=0.10
SNIPER_SOL_MIN_PRICE_MOVE=0.15

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                        üêã STRATEGY 4: WHALE ‚≠ê‚≠ê NEW!
#                  ML-Trained Contrarian Dip Buying
#           Trained on 150,411 trades from top whale wallets
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# KEY INSIGHT: Whales buy when odds CRASH, not when high!
#   - Your old strategy: Buy at 83¬¢ (momentum)
#   - Whale strategy: Buy at 35¬¢ (contrarian)
#
# R:R COMPARISON:
#   Old:   Entry 83¬¢, Risk 33¬¢, Reward 17¬¢, R:R 1:0.52, Breakeven 66%
#   Whale: Entry 35¬¢, Risk 35¬¢, Reward 65¬¢, R:R 1:1.86, Breakeven 35%
#
# STRATEGY: Buy crashed odds (15-55¬¢), hold to resolution, NO stop loss
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WHALE_ENABLED=true
WHALE_POSITION_SIZE_PCT=0.15
WHALE_MIN_ODDS=0.15
WHALE_MAX_ODDS=0.45
WHALE_MIN_TIME_MIN=2.0
WHALE_MAX_TIME_MIN=14.0

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# PER-ASSET OPTIMAL ENTRY (ML-derived from 150k whale trades)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# BTC: Optimal 35¬¢ ‚Üí R:R 1:1.86, Breakeven WR 35%
# ETH: Optimal 40¬¢ ‚Üí R:R 1:1.50, Breakeven WR 40%
# SOL: Optimal 45¬¢ ‚Üí R:R 1:1.22, Breakeven WR 45%
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
WHALE_BTC_OPTIMAL_ENTRY=0.35
WHALE_ETH_OPTIMAL_ENTRY=0.40
WHALE_SOL_OPTIMAL_ENTRY=0.45

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# üéØ WHALE EXIT STRATEGY (PROFIT TAKING)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Take Profit: Exit when price rises +X% from entry
# Stop Loss: Exit when price drops -X% from entry
# Trailing Stop: Exit when price drops X% from HIGH WATER MARK
# Time Exit: Exit X minutes before window resolution (to lock in gains)
# Hold To Resolution: If true, ignore all exits and hold to binary outcome
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
WHALE_TAKE_PROFIT_PCT=0.25
WHALE_STOP_LOSS_PCT=0.40
WHALE_TRAILING_STOP_PCT=0.15
WHALE_TIME_EXIT_MIN=0.5
WHALE_HOLD_TO_RESOLUTION=false

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                        ADVANCED: LATENCY ARBITRAGE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

ARB_ENABLED=false
ARB_MIN_PRICE_MOVE=0.001
ARB_MIN_ODDS=0.25
ARB_MAX_ODDS=0.65
ARB_POSITION_SIZE=1
ARB_EXIT_ODDS=0.75
ARB_STOP_LOSS=0.20
ARB_MAX_DAILY_TRADES=200
ARB_MAX_TRADES_PER_WINDOW=3
ARB_COOLDOWN_SECONDS=10

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#                             API ENDPOINTS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

POLYMARKET_API_URL=https://gamma-api.polymarket.com
POLYMARKET_CLOB_URL=https://clob.polymarket.com


================================================================================
FILE: go.mod
================================================================================
module github.com/web3guy0/polybot

go 1.24.0

require (
	github.com/ethereum/go-ethereum v1.16.7
	github.com/go-telegram-bot-api/telegram-bot-api/v5 v5.5.1
	github.com/gorilla/websocket v1.5.1
	github.com/joho/godotenv v1.5.1
	github.com/rs/zerolog v1.31.0
	github.com/shopspring/decimal v1.3.1
	gorm.io/driver/postgres v1.6.0
	gorm.io/driver/sqlite v1.5.4
	gorm.io/gorm v1.25.10
)

require (
	github.com/ProjectZKM/Ziren/crates/go-runtime/zkvm_runtime v0.0.0-20251001021608-1fe7b43fc4d6 // indirect
	github.com/bits-and-blooms/bitset v1.20.0 // indirect
	github.com/consensys/gnark-crypto v0.18.0 // indirect
	github.com/crate-crypto/go-eth-kzg v1.4.0 // indirect
	github.com/crate-crypto/go-ipa v0.0.0-20240724233137-53bbb0ceb27a // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.0.1 // indirect
	github.com/ethereum/c-kzg-4844/v2 v2.1.5 // indirect
	github.com/ethereum/go-verkle v0.2.2 // indirect
	github.com/fatih/color v1.18.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/holiman/uint256 v1.3.2 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.6.0 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-sqlite3 v1.14.17 // indirect
	github.com/rodaine/table v1.3.0 // indirect
	github.com/supranational/blst v0.3.16-0.20250831170142-f48500c1fdbe // indirect
	golang.org/x/crypto v0.36.0 // indirect
	golang.org/x/net v0.38.0 // indirect
	golang.org/x/sync v0.12.0 // indirect
	golang.org/x/sys v0.40.0 // indirect
	golang.org/x/term v0.39.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)


================================================================================
FILE: cmd/polybot/main.go
================================================================================
// Polybot - Latency Arbitrage Trading Bot for Polymarket
//
// This bot exploits the information lag between Binance BTC price movements
// and Polymarket odds updates on Bitcoin Up/Down prediction windows.
//
// Strategy:
// 1. Track BTC price at window start from Binance WebSocket
// 2. Detect significant price moves (>0.2%)
// 3. Check if Polymarket odds are stale (still ~50/50)
// 4. Buy the winning side at discounted odds
// 5. Collect $1 on resolution
//
// Reference: @PurpleThunderBicycleMountain - $330k profit in 1 month
package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/joho/godotenv"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"

	"github.com/web3guy0/polybot/internal/arbitrage"
	"github.com/web3guy0/polybot/internal/binance"
	"github.com/web3guy0/polybot/internal/bot"
	"github.com/web3guy0/polybot/internal/chainlink"
	"github.com/web3guy0/polybot/internal/cmc"
	"github.com/web3guy0/polybot/internal/config"
	"github.com/web3guy0/polybot/internal/dashboard"
	"github.com/web3guy0/polybot/internal/database"
	"github.com/web3guy0/polybot/internal/polymarket"
)

const version = "5.0.0" // Mean Reversion Swing Trading

func main() {
	// Load environment FIRST (before checking any env vars)
	_ = godotenv.Load() // Ignore error - may use env vars directly
	
	// Check for dashboard mode FIRST (before setting up zerolog)
	useDashboard := false
	useSwing := false      // Mean reversion swing trading
	useSniper := false     // Last minute sniper strategy
	useWhale := os.Getenv("USE_WHALE") == "true" || os.Getenv("USE_WHALE") == "1"  // üêã Whale strategy (ML-trained contrarian)
	for _, arg := range os.Args[1:] {
		if arg == "--dashboard" || arg == "-d" || arg == "--responsive" || arg == "-r" {
			useDashboard = true
		}
		if arg == "--swing" || arg == "-s" {
			useSwing = true
		}
		if arg == "--sniper" || arg == "--snipe" {
			useSniper = true
		}
		if arg == "--whale" || arg == "-w" {
			useWhale = true
		}
	}

	// Create dashboard
	var dash *dashboard.ResponsiveDash
	
	if useDashboard {
		strategyName := "SCALPER"
		if useSwing {
			strategyName = "SWING"
		}
		if useSniper {
			strategyName = "SNIPER"
		}
		if useWhale {
			strategyName = "üêã WHALE"
		}
		dash = dashboard.NewResponsiveDash(strategyName)
	}

	// Setup logging - route to dashboard if enabled
	if dash != nil {
		// Silent mode - logs go to dashboard
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
		log.Logger = log.Output(dash.Writer())
	} else {
		// Normal console logging
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	}

	// Check for analysis mode
	if len(os.Args) > 1 && os.Args[1] == "--analyze" {
		arbitrage.PrintProbabilityAnalysis()
		
		// Run Monte Carlo for all conditions
		conditions := arbitrage.MarketConditions{
			Profile:          arbitrage.MediumVolProfile,
			AvgSpread:        0.02,
			OrderBookDepth:   1000,
			CompetitorBots:   5,
			LatencyAdvantage: 50,
		}
		arbitrage.MonteCarloSimulation(conditions, 10000)
		return
	}

	// .env already loaded at start of main()
	
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to load configuration")
	}

	if cfg.Debug {
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	}

	// Multi-asset support: BTC, ETH, SOL
	// Can be configured via TRADING_ASSETS="BTC,ETH,SOL" or defaults to BTC only
	assets := cfg.TradingAssets
	if len(assets) == 0 {
		// Fallback to single asset config
		asset := cfg.TradingAsset
		if asset == "" {
			asset = "BTC"
		}
		assets = []string{asset}
	}

	log.Info().
		Str("version", version).
		Str("mode", "latency_arbitrage").
		Strs("assets", assets).
		Bool("dry_run", cfg.DryRun).
		Msg("‚ö° Polybot Multi-Asset Arbitrage starting...")

	// Create context for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Initialize database for trade logging
	db, dbErr := database.New(cfg.DatabasePath)
	if dbErr != nil {
		log.Warn().Err(dbErr).Msg("Database initialization failed (continuing without)")
	} else {
		log.Info().Msg("üìä Database connected for trade logging")
	}

	// ====== CORE COMPONENTS ======

	// 1. Binance client - real-time BTC price feed (still needed as fallback)
	binanceClient := binance.NewClient()
	if err := binanceClient.Start(); err != nil {
		log.Fatal().Err(err).Msg("Failed to start Binance client")
	}
	log.Info().Msg("üìà Binance WebSocket connected")

	// 1b. Multi-asset Binance client - BTC, ETH, SOL real-time prices
	binanceMulti := binance.NewMultiClient(assets...)
	if err := binanceMulti.Start(); err != nil {
		log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to start multi-asset Binance")
	}

	// 2. Chainlink client - BTC/USD price feed on Polygon (what Polymarket uses for resolution)
	chainlinkClient := chainlink.NewClient()
	if err := chainlinkClient.Start(); err != nil {
		log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to start Chainlink client - using CMC/Binance only")
	} else {
		log.Info().Msg("‚õìÔ∏è Chainlink price feed connected (Polygon)")
	}

	// 2b. Multi-asset Chainlink client - BTC, ETH, SOL price feeds for Price to Beat
	multiChainlink := chainlink.NewMultiClient(assets...)
	if err := multiChainlink.Start(); err != nil {
		log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to start multi-asset Chainlink - using CMC only for ETH/SOL")
	}

	// 3. CMC client - fast price updates for ALL assets (BTC, ETH, SOL)
	cmcClient := cmc.NewClient(assets...)
	cmcClient.Start()
	log.Info().Strs("assets", assets).Msg("üìä CMC price feed started (1s updates)")

	// 3b. Polymarket WebSocket client - real-time odds updates
	wsClient := polymarket.NewWSClient()
	if err := wsClient.Connect(); err != nil {
		log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to connect Polymarket WebSocket - using HTTP polling")
		wsClient = nil
	}

	// 4. CLOB client - for trading and account data (shared across all engines)
	var clobClient *arbitrage.CLOBClient
	if cfg.WalletPrivateKey != "" || (cfg.CLOBApiKey != "" && cfg.CLOBApiSecret != "") {
		clobClient, err = arbitrage.NewCLOBClient(
			cfg.CLOBApiKey,
			cfg.CLOBApiSecret,
			cfg.CLOBPassphrase,
			cfg.WalletPrivateKey,
			cfg.SignerAddress,
			cfg.FunderAddress,
			cfg.SignatureType,
		)
		if err != nil {
			log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to initialize CLOB client - trading disabled")
		} else {
			log.Info().Msg("üí≥ CLOB client initialized")
		}
	} else {
		log.Warn().Msg("‚ö†Ô∏è No credentials - add CLOB_API_KEY/SECRET to .env for trading")
	}

	// 5. Create window scanners and arbitrage engines for EACH asset
	windowScanners := make([]*polymarket.WindowScanner, 0, len(assets))
	arbEngines := make([]*arbitrage.Engine, 0, len(assets))
	
	for _, asset := range assets {
		// Window scanner for this asset
		scanner := polymarket.NewWindowScanner(cfg.PolymarketAPIURL, asset)
		// Connect WebSocket for REAL-TIME odds (ms latency!)
		if wsClient != nil {
			scanner.SetWSClient(wsClient)
		}
		scanner.Start()
		windowScanners = append(windowScanners, scanner)
		log.Info().Str("asset", asset).Msg("üîç Window scanner started")
		
		// Arbitrage engine for this asset
		engine := arbitrage.NewEngine(cfg, binanceClient, chainlinkClient, cmcClient, scanner)
		engine.SetAsset(asset) // Tell engine which asset it's tracking
		
		// Wire up database for storing window prices
		if db != nil {
			engine.SetDatabase(db)
		}
		
		// Wire up multi-asset Chainlink for Price to Beat
		if multiChainlink != nil {
			engine.SetMultiChainlink(multiChainlink)
		}
		
		// Wire up multi-asset Binance for all assets
		if binanceMulti != nil {
			engine.SetBinanceMulti(binanceMulti)
		}
		
		// Wire up WebSocket for real-time odds
		if wsClient != nil {
			engine.SetWSClient(wsClient)
		}
		
		if clobClient != nil {
			engine.SetCLOBClient(clobClient)
		}
		engine.Start()
		arbEngines = append(arbEngines, engine)
		log.Info().Str("asset", asset).Msg("‚ö° Arbitrage engine started")
	}

	// ====== SWING STRATEGY (Mean Reversion) ======
	// Buy the dip (12¬¢+ drop), sell the bounce (+6¬¢ profit)
	// Trades volatility, not window resolution
	var swingStrategies []*arbitrage.SwingStrategy
	if useSwing {
		swingStrategies = make([]*arbitrage.SwingStrategy, 0, len(assets))
		for i, asset := range assets {
			swing := arbitrage.NewSwingStrategy(
				windowScanners[i],
				clobClient,
				db,
			)
			swing.SetEngine(arbEngines[i]) // For live price data
			swing.SetNotifier(nil) // Will set after telegram init
			if dash != nil {
				swing.SetDashboard(dash)
			}
			swing.Start()
			swingStrategies = append(swingStrategies, swing)
			log.Info().Str("asset", asset).Msg("üé¢ Swing strategy started (mean reversion)")
		}
	}

	// ====== SCALPER STRATEGY ======
	// Buy extreme mispricings (<20¬¢) and sell when they bounce to 33¬¢+
	// CRITICAL: Uses engine's price-to-beat data to avoid late entries!
	var scalperStrategies []*arbitrage.ScalperStrategy
	if !useSwing && !useSniper && !useWhale {
		scalperStrategies = make([]*arbitrage.ScalperStrategy, 0, len(assets))
		for i, asset := range assets {
			scalper := arbitrage.NewScalperStrategy(
				windowScanners[i], 
				clobClient, 
				cfg.DryRun,
				cfg.ScalperPositionSize,    // Position size from config
			)
			// Link scalper to engine for price-to-beat data
			scalper.SetEngine(arbEngines[i])
			// Connect to database for trade logging
			if db != nil {
				scalper.SetDatabase(db)
			}
			scalper.Start()
			scalperStrategies = append(scalperStrategies, scalper)
			log.Info().Str("asset", asset).Bool("paper", cfg.DryRun).Msg("üéØ Scalper strategy started")
		}
	}
	
	// ====== SNIPER STRATEGY ======
	// Last-minute high-confidence trades: buy at 85-92¬¢ in final 2-3 mins
	// Target: 95¬¢ (5-10¬¢ profit) | Stop: 75¬¢ (tight risk control)
	var sniperStrategies []*arbitrage.SniperStrategy
	if useSniper {
		sniperStrategies = make([]*arbitrage.SniperStrategy, 0, len(assets))
		for i, asset := range assets {
			sniper := arbitrage.NewSniperStrategy(
				windowScanners[i],
				clobClient,
				cfg.SniperPositionSizePct,
			)
			// Apply config from .env
			sniper.SetConfig(
				cfg.SniperMinTimeMin,
				cfg.SniperMaxTimeMin,
				cfg.SniperMinPriceMove,
				cfg.SniperMinOdds,
				cfg.SniperMaxOdds,
				cfg.SniperTarget,
				cfg.SniperStopLoss,
				cfg.SniperHoldToResolution,
			)
			// Apply per-asset price move thresholds (CRITICAL - based on volatility)
			sniper.SetPerAssetPriceMove(
				cfg.SniperBTCMinPriceMove,
				cfg.SniperETHMinPriceMove,
				cfg.SniperSOLMinPriceMove,
			)
			// Link sniper to engine for price data
			sniper.SetEngine(arbEngines[i])
			// Connect to database for trade logging
			if db != nil {
				sniper.SetDatabase(db)
			}
			sniper.Start()
			sniperStrategies = append(sniperStrategies, sniper)
			log.Info().Str("asset", asset).Bool("paper", cfg.DryRun).Msg("üéØ Sniper strategy started")
		}
	}
	
	// ====== üêã WHALE STRATEGY (ML-Trained Contrarian) ======
	// Buy CRASHED odds (15-55¬¢) when others panic sell
	// Buy low, sell high - take profit on momentum
	// Trained on 150,411 whale trades - exploits odds mispricing
	var whaleStrategies []*arbitrage.WhaleStrategy
	var printedWhaleInfo bool // Only print banner once
	if useWhale {
		whaleStrategies = make([]*arbitrage.WhaleStrategy, 0, len(assets))
		for i, asset := range assets {
			whale := arbitrage.NewWhaleStrategy(
				windowScanners[i],
				clobClient,
				db,
				cfg.DryRun,   // Paper trading mode
				cfg.Bankroll, // Bankroll for position sizing
			)
			// Configure from .env
			whaleConfig := arbitrage.WhaleConfig{
				MinOddsEntry:           cfg.WhaleMinOdds,
				MaxOddsEntry:           cfg.WhaleMaxOdds,
				OptimalEntry:           cfg.WhaleBTCOptimalEntry, // Default, will be per-asset
				MinTimeRemainingMin:    cfg.WhaleMinTimeMin,
				MaxTimeRemainingMin:    cfg.WhaleMaxTimeMin,
				// üéØ EXIT CONDITIONS (PROFIT TAKING)
				TakeProfitPct:          cfg.WhaleTakeProfitPct,
				StopLossPct:            cfg.WhaleStopLossPct,
				TrailingStopPct:        cfg.WhaleTrailingStopPct,
				TimeExitMinutes:        cfg.WhaleTimeExitMin,
				MinProfitToExit:        decimal.NewFromFloat(0.02), // Min 2¬¢ profit
				HoldToResolution:       cfg.WhaleHoldToResolution,
				PositionSizePct:        cfg.WhalePositionSizePct,
				MaxConcurrentPositions: 2,
				MaxTradesPerWindow:     1,
				AssetMinEntry: map[string]decimal.Decimal{
					"BTC": cfg.WhaleMinOdds,
					"ETH": cfg.WhaleMinOdds.Add(decimal.NewFromFloat(0.05)),
					"SOL": cfg.WhaleMinOdds.Add(decimal.NewFromFloat(0.10)),
				},
				AssetMaxEntry: map[string]decimal.Decimal{
					"BTC": cfg.WhaleMaxOdds,
					"ETH": cfg.WhaleMaxOdds.Add(decimal.NewFromFloat(0.05)),
					"SOL": cfg.WhaleMaxOdds.Add(decimal.NewFromFloat(0.10)),
				},
				AssetOptimalEntry: map[string]decimal.Decimal{
					"BTC": cfg.WhaleBTCOptimalEntry,
					"ETH": cfg.WhaleETHOptimalEntry,
					"SOL": cfg.WhaleSOLOptimalEntry,
				},
			}
			whale.SetConfig(whaleConfig)
			if !printedWhaleInfo {
				whale.PrintStrategyInfo()
				printedWhaleInfo = true
			}
			whale.Start()
			whaleStrategies = append(whaleStrategies, whale)
			log.Info().Str("asset", asset).Bool("paper", cfg.DryRun).Msg("üêã Whale strategy started (contrarian dip buying)")
		}
	}
	
	// Subscribe to WebSocket markets for all active windows
	if wsClient != nil {
		go func() {
			// Wait for initial window scan
			time.Sleep(3 * time.Second)
			for _, scanner := range windowScanners {
				for _, w := range scanner.GetActiveWindows() {
					if w.ConditionID != "" && w.YesTokenID != "" {
						wsClient.Subscribe(w.ConditionID, w.YesTokenID, w.NoTokenID)
					}
				}
			}
		}()
	}

	// ====== TELEGRAM BOT ======
	telegramBot, err := bot.New(cfg)
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to initialize Telegram bot")
	}
	
	// Register engines and strategies for each asset
	// Also connect telegram as notifier for trade alerts
	for i, asset := range assets {
		telegramBot.AddEngine(asset, arbEngines[i])
		
		if useSwing && i < len(swingStrategies) {
			// Using swing strategy
			swingStrategies[i].SetNotifier(telegramBot)
			if dash != nil {
				swingStrategies[i].SetDashboard(dash)
			}
		} else if useSniper && i < len(sniperStrategies) {
			// Using sniper strategy
			sniperStrategies[i].SetNotifier(telegramBot)
			if dash != nil {
				sniperStrategies[i].SetDashboard(dash)
			}
		} else if useWhale && i < len(whaleStrategies) {
			// Using whale strategy (no SetNotifier yet, just log)
			log.Info().Str("asset", asset).Msg("üêã Whale strategy monitoring started")
		} else if !useSwing && !useSniper && !useWhale && i < len(scalperStrategies) {
			// Using scalper strategy (default)
			telegramBot.AddScalper(asset, scalperStrategies[i])
			scalperStrategies[i].SetNotifier(telegramBot)
			if dash != nil {
				scalperStrategies[i].SetDashboard(dash)
			}
		}
	}

	go telegramBot.Start()
	
	// Start dashboard if enabled
	if dash != nil {
		dash.Start()
	}

	// ====== STARTUP COMPLETE ======
	log.Info().Msg("‚úÖ All systems online")
	log.Info().Msg("")
	if useSwing {
		log.Info().Msg("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
		log.Info().Msg("‚ïë   üé¢ MEAN REVERSION SWING TRADING üé¢      ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  Strategy: Buy dips, sell bounces        ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msgf("‚ïë  Assets: %-32s ‚ïë", formatAssets(assets))
		log.Info().Msg("‚ïë  ‚Üí Track odds history (30s lookback)     ‚ïë")
		log.Info().Msg("‚ïë  ‚Üí Buy when odds drop 12¬¢+ quickly       ‚ïë")
		log.Info().Msg("‚ïë  ‚Üí Sell on 50% retracement bounce        ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  üìà Entry: 8¬¢-65¬¢ range only            ‚ïë")
		log.Info().Msg("‚ïë  üéØ Exit: Bounce target / Stop loss      ‚ïë")
		log.Info().Msg("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
	} else if useSniper {
		log.Info().Msg("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
		log.Info().Msg("‚ïë   üéØ LAST MINUTE SNIPER STRATEGY üéØ       ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  Strategy: High-confidence final trades  ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msgf("‚ïë  Assets: %-32s ‚ïë", formatAssets(assets))
		log.Info().Msg("‚ïë  ‚Üí Wait for last 1-3 minutes             ‚ïë")
		log.Info().Msg("‚ïë  ‚Üí Buy at 85-92¬¢ if price moved 0.2%+   ‚ïë")
		log.Info().Msg("‚ïë  ‚Üí Target 95¬¢ / Stop 75¬¢                ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  üî´ Quick scalps on near-certain bets   ‚ïë")
		log.Info().Msg("‚ïë  ‚ö° 5-10¬¢ profit, tight risk control     ‚ïë")
		log.Info().Msg("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
	} else if useWhale {
		log.Info().Msg("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
		log.Info().Msg("‚ïë   üêã WHALE STRATEGY - BUY LOW SELL HIGH  ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  Entry: Crash + Momentum UP required     ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msgf("‚ïë  Assets: %-32s ‚ïë", formatAssets(assets))
		log.Info().Msg("‚ïë  ‚Üí Buy CRASHED odds (15-55¬¢)            ‚ïë")
		log.Info().Msgf("‚ïë  ‚Üí Take Profit: +%d%%                     ‚ïë", int(cfg.WhaleTakeProfitPct.Mul(decimal.NewFromInt(100)).IntPart()))
		log.Info().Msgf("‚ïë  ‚Üí Stop Loss: -%d%%                       ‚ïë", int(cfg.WhaleStopLossPct.Mul(decimal.NewFromInt(100)).IntPart()))
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  üìà R:R 1:1.86 @ 35¬¢ entry              ‚ïë")
		log.Info().Msg("‚ïë  üé≤ Breakeven: 35% WR (actual ~50%)      ‚ïë")
		log.Info().Msg("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
	} else {
		log.Info().Msg("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
		log.Info().Msg("‚ïë   MULTI-ASSET LATENCY ARBITRAGE ACTIVE   ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  Strategy: Exploit price‚Üíodds lag        ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msgf("‚ïë  Assets: %-32s ‚ïë", formatAssets(assets))
		log.Info().Msg("‚ïë  ‚Üí Watch for price moves on CMC          ‚ïë")
		log.Info().Msg("‚ïë  ‚Üí Buy stale Polymarket odds             ‚ïë")
		log.Info().Msg("‚ïë  ‚Üí Exit at 75¬¢ OR hold to resolution     ‚ïë")
		log.Info().Msg("‚ïë                                          ‚ïë")
		log.Info().Msg("‚ïë  üöÄ Dynamic Sizing: 1x/2x/3x by move     ‚ïë")
		log.Info().Msg("‚ïë  üéØ Scalper: Buy cheap, sell on bounce   ‚ïë")
		log.Info().Msg("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
	}
	log.Info().Msg("")
	log.Info().Msg("üí° Use /help for commands")

	// Wait for shutdown signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	select {
	case <-quit:
		log.Info().Msg("üõë Received shutdown signal")
	case <-ctx.Done():
		log.Info().Msg("üõë Context cancelled")
	}

	// Graceful shutdown
	log.Info().Msg("Shutting down...")

	// Stop dashboard first
	if dash != nil {
		dash.Stop()
	}
	
	telegramBot.Stop()
	for _, engine := range arbEngines {
		engine.Stop()
	}
	for _, scalper := range scalperStrategies {
		scalper.Stop()
	}
	for _, scanner := range windowScanners {
		scanner.Stop()
	}
	cmcClient.Stop()
	chainlinkClient.Stop()
	binanceClient.Stop()

	log.Info().Msg("üëã Goodbye!")
}

// formatAssets formats asset list for display
func formatAssets(assets []string) string {
	if len(assets) == 1 {
		return assets[0]
	}
	result := ""
	for i, a := range assets {
		if i > 0 {
			result += ", "
		}
		result += a
	}
	return result
}


================================================================================
FILE: internal/config/config.go
================================================================================
package config

import (
"fmt"
"os"
"strconv"
"strings"
"time"

"github.com/shopspring/decimal"
)

// Config holds all configuration for the bot
type Config struct {
// Telegram
TelegramToken  string
TelegramChatID int64

// Trading Asset(s)
TradingAsset  string   // Single asset (backward compatible)
TradingAssets []string // Multi-asset: BTC, ETH, SOL

// Mode
DryRun bool
Debug  bool

// Polymarket API
PolymarketAPIURL  string
PolymarketCLOBURL string

// CLOB Credentials
CLOBApiKey     string
CLOBApiSecret  string
CLOBPassphrase string

// Wallet
WalletPrivateKey string
WalletAddress    string
SignerAddress    string // Address that signed/derived the API credentials
FunderAddress    string // Address that holds funds (may differ from signing key)
SignatureType    int    // 0=EOA, 1=Magic/Email, 2=Proxy

	// Arbitrage Settings
	ArbEnabled           bool
	ArbMinPriceMove      decimal.Decimal // e.g., 0.002 = 0.2%
	ArbMinOddsForEntry   decimal.Decimal // e.g., 0.35 = 35 cents (min entry)
	ArbMaxOddsForEntry   decimal.Decimal // e.g., 0.65 = 65 cents (max entry)
	ArbMinEdge           decimal.Decimal // e.g., 0.10 = 10%
	ArbPositionSize      decimal.Decimal // USD per trade
	ArbMaxDailyTrades    int
	ArbMaxTradesPerWindow int            // Max trades per 15-min window
	ArbCooldownSeconds   int

	// Scalper Strategy Settings
	ScalperPositionSize  decimal.Decimal // USD per scalp trade
	ScalperEntryThreshold decimal.Decimal // Enter when odds drop to this (e.g., 0.15)

	// Swing Strategy Settings
	SwingMaxPositionUSD decimal.Decimal // Max USD per swing trade
	SwingMaxPositions   int             // Max concurrent swing positions
	SwingMinDropPct     decimal.Decimal // Min drop % to trigger entry (e.g., 0.12 = 12¬¢)
	SwingCooldownSec    int             // Cooldown between trades

	// Sniper Strategy Settings (Last Minute)
	SniperPositionSizePct decimal.Decimal // % of balance per trade (e.g., 0.10 = 10%)
	SniperMinTimeMin      float64         // Min time remaining (minutes)
	SniperMaxTimeMin      float64         // Max time remaining (minutes)
	SniperMinPriceMove    decimal.Decimal // Min price move to confirm direction
	SniperMinOdds         decimal.Decimal // Min odds to buy (e.g., 0.79)
	SniperMaxOdds         decimal.Decimal // Max odds to buy (e.g., 0.90)
	
	// Per-Asset Price Movement (CRITICAL - varies by volatility)
	// BTC = 0.02% (stable, small moves are significant)
	// ETH = 0.04% (medium volatility)
	// SOL = 0.08% (volatile, needs bigger move to confirm)
	SniperBTCMinPriceMove decimal.Decimal
	SniperETHMinPriceMove decimal.Decimal
	SniperSOLMinPriceMove decimal.Decimal
	SniperTarget          decimal.Decimal // Quick flip target (e.g., 0.95)
	SniperStopLoss        decimal.Decimal // Stop loss (e.g., 0.75)
	SniperHoldToResolution bool           // Hold to resolution instead of quick flip (default: false)

	// üêã WHALE STRATEGY (ML-trained contrarian dip buying)
	// Trained on 150,411 trades from top whale wallets
	WhaleEnabled          bool            // Enable whale strategy
	WhalePositionSizePct  decimal.Decimal // % of balance per trade (e.g., 0.15 = 15%)
	WhaleMinOdds          decimal.Decimal // Min odds to buy (e.g., 0.15 = 15¬¢)
	WhaleMaxOdds          decimal.Decimal // Max odds to buy (e.g., 0.55 = 55¬¢)
	WhaleMinTimeMin       float64         // Min time remaining (minutes)
	WhaleMaxTimeMin       float64         // Max time remaining (minutes)
	// Per-asset optimal entry (ML-derived)
	WhaleBTCOptimalEntry  decimal.Decimal // 35¬¢ - R:R 1:1.86
	WhaleETHOptimalEntry  decimal.Decimal // 40¬¢ - R:R 1:1.50
	WhaleSOLOptimalEntry  decimal.Decimal // 45¬¢ - R:R 1:1.22
	// üéØ Whale Exit Strategy (PROFIT TAKING)
	WhaleTakeProfitPct    decimal.Decimal // Take profit at +X% (e.g., 0.20 = +20%)
	WhaleStopLossPct      decimal.Decimal // Stop loss at -X% (e.g., 0.30 = -30%)
	WhaleTrailingStopPct  decimal.Decimal // Trailing stop from high (e.g., 0.15 = 15%)
	WhaleTimeExitMin      float64         // Exit X minutes before resolution
	WhaleHoldToResolution bool            // If true, ignore TP/SL

	// Triple Exit Strategy
	ArbExitOddsThreshold decimal.Decimal // e.g., 0.75 = exit at 75¬¢ for quick flip
	ArbHoldThreshold     decimal.Decimal // e.g., 0.005 = 0.5% BTC move confirms direction
	ArbStopLossPct       decimal.Decimal // e.g., 0.20 = 20% stop-loss
	Bankroll     decimal.Decimal

// Database
DatabasePath string
}

// Load loads configuration from environment variables
func Load() (*Config, error) {
cfg := &Config{
// Telegram
TelegramToken: os.Getenv("TELEGRAM_BOT_TOKEN"),

// Trading
TradingAsset:  getEnv("TRADING_ASSET", "BTC"),
TradingAssets: getEnvStringSlice("TRADING_ASSETS", []string{}), // e.g., "BTC,ETH,SOL"
DryRun:        getEnvBool("DRY_RUN", true),
Debug:         getEnvBool("DEBUG", false),

// Polymarket API
PolymarketAPIURL:  getEnv("POLYMARKET_API_URL", "https://gamma-api.polymarket.com"),
PolymarketCLOBURL: getEnv("POLYMARKET_CLOB_URL", "https://clob.polymarket.com"),

// CLOB Credentials
CLOBApiKey:     os.Getenv("CLOB_API_KEY"),
CLOBApiSecret:  os.Getenv("CLOB_API_SECRET"),
CLOBPassphrase: os.Getenv("CLOB_PASSPHRASE"),

// Wallet
WalletPrivateKey: os.Getenv("WALLET_PRIVATE_KEY"),
WalletAddress:    os.Getenv("WALLET_ADDRESS"),
SignerAddress:    os.Getenv("SIGNER_ADDRESS"),
FunderAddress:    os.Getenv("FUNDER_ADDRESS"),
SignatureType:    getEnvInt("SIGNATURE_TYPE", 0),

		// Arbitrage Settings
		ArbEnabled:           getEnvBool("ARB_ENABLED", true),
		ArbMinPriceMove:      getEnvDecimal("ARB_MIN_PRICE_MOVE", decimal.NewFromFloat(0.002)),
		ArbMinOddsForEntry:   getEnvDecimal("ARB_MIN_ODDS", decimal.NewFromFloat(0.35)),   // Min 35¬¢
		ArbMaxOddsForEntry:   getEnvDecimal("ARB_MAX_ODDS", decimal.NewFromFloat(0.65)),   // Max 65¬¢
		ArbMinEdge:           getEnvDecimal("ARB_MIN_EDGE", decimal.NewFromFloat(0.10)),
		ArbPositionSize:      getEnvDecimal("ARB_POSITION_SIZE", decimal.NewFromFloat(1)),
		ArbMaxDailyTrades:    getEnvInt("ARB_MAX_DAILY_TRADES", 200),
		ArbMaxTradesPerWindow: getEnvInt("ARB_MAX_TRADES_PER_WINDOW", 3),  // Max 3 trades per 15-min window
		ArbCooldownSeconds:   getEnvInt("ARB_COOLDOWN_SECONDS", 10),

		// Scalper Strategy
		ScalperPositionSize:   getEnvDecimal("SCALPER_POSITION_SIZE", decimal.NewFromFloat(0.50)),   // Default $0.50
		ScalperEntryThreshold: getEnvDecimal("SCALPER_ENTRY_THRESHOLD", decimal.NewFromFloat(0.15)), // 15¬¢ max

		// Swing Strategy
		SwingMaxPositionUSD: getEnvDecimal("SWING_MAX_POSITION_USD", decimal.NewFromFloat(2.0)),
		SwingMaxPositions:   getEnvInt("SWING_MAX_POSITIONS", 3),
		SwingMinDropPct:     getEnvDecimal("SWING_MIN_DROP_PCT", decimal.NewFromFloat(0.12)),
		SwingCooldownSec:    getEnvInt("SWING_COOLDOWN_SEC", 30),

		// Sniper Strategy (Last Minute) - NEW OPTIMIZED DEFAULTS
		SniperPositionSizePct: getEnvDecimal("SNIPER_POSITION_SIZE_PCT", decimal.NewFromFloat(0.10)), // 10% of balance
		SniperMinTimeMin:      getEnvFloat("SNIPER_MIN_TIME_MIN", 1.0),
		SniperMaxTimeMin:      getEnvFloat("SNIPER_MAX_TIME_MIN", 3.0),
		SniperMinPriceMove:    getEnvDecimal("SNIPER_MIN_PRICE_MOVE", decimal.NewFromFloat(0.002)),
		SniperMinOdds:         getEnvDecimal("SNIPER_MIN_ODDS", decimal.NewFromFloat(0.79)),  // Entry at 79¬¢+
		SniperMaxOdds:         getEnvDecimal("SNIPER_MAX_ODDS", decimal.NewFromFloat(0.90)),  // Entry up to 90¬¢
		SniperTarget:          getEnvDecimal("SNIPER_TARGET", decimal.NewFromFloat(0.99)),   // Exit at 99¬¢ (near resolution)
		SniperStopLoss:        getEnvDecimal("SNIPER_STOP_LOSS", decimal.NewFromFloat(0.50)), // SL at 50¬¢ (wide, let it breathe)
		SniperHoldToResolution: getEnvBool("SNIPER_HOLD_TO_RESOLUTION", false), // Default: quick flip at 99¬¢
		
		// Per-Asset Price Movement (CRITICAL - based on volatility)
		// BTC = low volatility, small moves are significant
		// ETH = medium volatility, needs moderate confirmation
		// SOL = high volatility, needs bigger move to filter noise
		SniperBTCMinPriceMove: getEnvDecimal("SNIPER_BTC_MIN_PRICE_MOVE", decimal.NewFromFloat(0.02)), // 0.02%
		SniperETHMinPriceMove: getEnvDecimal("SNIPER_ETH_MIN_PRICE_MOVE", decimal.NewFromFloat(0.04)), // 0.04%
		SniperSOLMinPriceMove: getEnvDecimal("SNIPER_SOL_MIN_PRICE_MOVE", decimal.NewFromFloat(0.08)), // 0.08%

		// üêã WHALE STRATEGY (ML-trained contrarian dip buying)
		// Trained on 150,411 trades from top whale wallets
		// BUY at 15-55¬¢ (crashed odds), HOLD to resolution, NO stop loss
		WhaleEnabled:          getEnvBool("WHALE_ENABLED", true),  // Enable by default
		WhalePositionSizePct:  getEnvDecimal("WHALE_POSITION_SIZE_PCT", decimal.NewFromFloat(0.15)), // 15% per trade
		WhaleMinOdds:          getEnvDecimal("WHALE_MIN_ODDS", decimal.NewFromFloat(0.15)),  // Min 15¬¢
		WhaleMaxOdds:          getEnvDecimal("WHALE_MAX_ODDS", decimal.NewFromFloat(0.55)),  // Max 55¬¢
		WhaleMinTimeMin:       getEnvFloat("WHALE_MIN_TIME_MIN", 2.0),   // At least 2 min left
		WhaleMaxTimeMin:       getEnvFloat("WHALE_MAX_TIME_MIN", 14.0),  // Can enter at start
		// Per-asset optimal entry (ML-derived from whale data)
		WhaleBTCOptimalEntry:  getEnvDecimal("WHALE_BTC_OPTIMAL_ENTRY", decimal.NewFromFloat(0.35)), // R:R 1:1.86
		WhaleETHOptimalEntry:  getEnvDecimal("WHALE_ETH_OPTIMAL_ENTRY", decimal.NewFromFloat(0.40)), // R:R 1:1.50
		WhaleSOLOptimalEntry:  getEnvDecimal("WHALE_SOL_OPTIMAL_ENTRY", decimal.NewFromFloat(0.45)), // R:R 1:1.22
		// üéØ Whale Exit Strategy (TAKE PROFITS!)
		WhaleTakeProfitPct:    getEnvDecimal("WHALE_TAKE_PROFIT_PCT", decimal.NewFromFloat(0.20)),   // +20% take profit
		WhaleStopLossPct:      getEnvDecimal("WHALE_STOP_LOSS_PCT", decimal.NewFromFloat(0.30)),    // -30% stop loss
		WhaleTrailingStopPct:  getEnvDecimal("WHALE_TRAILING_STOP_PCT", decimal.NewFromFloat(0.15)), // 15% trailing
		WhaleTimeExitMin:      getEnvFloat("WHALE_TIME_EXIT_MIN", 0.5),                             // 30 sec before resolution
		WhaleHoldToResolution: getEnvBool("WHALE_HOLD_TO_RESOLUTION", false),                       // false = take profits

		// Triple Exit Strategy
		ArbExitOddsThreshold: getEnvDecimal("ARB_EXIT_ODDS", decimal.NewFromFloat(0.75)),       // Sell at 75¬¢+
		ArbHoldThreshold:     getEnvDecimal("ARB_HOLD_THRESHOLD", decimal.NewFromFloat(0.005)), // 0.5% BTC confirms direction
		ArbStopLossPct:       getEnvDecimal("ARB_STOP_LOSS", decimal.NewFromFloat(0.20)),       // üõë 20% stop-loss
		Bankroll:             getEnvDecimal("BANKROLL", decimal.NewFromFloat(5)),               // Your current balance

		// Database - supports PostgreSQL URL or SQLite path
		DatabasePath: getEnv("DATABASE_URL", getEnv("DATABASE_PATH", "data/polybot.db")),
	}

// Parse chat ID
if chatID := os.Getenv("TELEGRAM_CHAT_ID"); chatID != "" {
id, err := strconv.ParseInt(chatID, 10, 64)
if err != nil {
return nil, fmt.Errorf("invalid TELEGRAM_CHAT_ID: %w", err)
}
cfg.TelegramChatID = id
}

// Validate required fields
if cfg.TelegramToken == "" {
return nil, fmt.Errorf("TELEGRAM_BOT_TOKEN is required")
}

return cfg, nil
}

// Helper functions

func getEnv(key, defaultValue string) string {
if value := os.Getenv(key); value != "" {
return value
}
return defaultValue
}

func getEnvBool(key string, defaultValue bool) bool {
if value := os.Getenv(key); value != "" {
return value == "true" || value == "1" || value == "yes"
}
return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
if value := os.Getenv(key); value != "" {
if i, err := strconv.Atoi(value); err == nil {
return i
}
}
return defaultValue
}

func getEnvFloat(key string, defaultValue float64) float64 {
if value := os.Getenv(key); value != "" {
if f, err := strconv.ParseFloat(value, 64); err == nil {
return f
}
}
return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
if value := os.Getenv(key); value != "" {
if d, err := time.ParseDuration(value); err == nil {
return d
}
}
return defaultValue
}

func getEnvDecimal(key string, defaultValue decimal.Decimal) decimal.Decimal {
if value := os.Getenv(key); value != "" {
if d, err := decimal.NewFromString(value); err == nil {
return d
}
}
return defaultValue
}

func getEnvStringSlice(key string, defaultValue []string) []string {
if value := os.Getenv(key); value != "" {
// Split by comma and trim whitespace
parts := make([]string, 0)
for _, part := range splitAndTrim(value, ",") {
if part != "" {
parts = append(parts, part)
}
}
if len(parts) > 0 {
return parts
}
}
return defaultValue
}

func splitAndTrim(s, sep string) []string {
parts := make([]string, 0)
for _, p := range strings.Split(s, sep) {
parts = append(parts, strings.TrimSpace(p))
}
return parts
}


================================================================================
FILE: internal/arbitrage/engine.go
================================================================================
// Package arbitrage provides latency arbitrage functionality for Polymarket
//
// engine.go - Core arbitrage engine that exploits the lag between price
// movements and Polymarket odds updates. When BTC moves but Polymarket
// odds haven't caught up, we buy the mispriced outcome.
//
// Strategy:
// 1. Track window start price from Chainlink on-chain
// 2. Monitor real-time BTC price from CMC (same source as Polymarket!)
// 3. Detect significant price moves (>0.2% default)
// 4. Check if Polymarket odds are stale (still ~50/50)
// 5. Calculate edge: if expected value is positive, execute
// 6. Buy the winning side at discounted odds
// 7. Collect $1 on resolution
package arbitrage

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"

	"github.com/web3guy0/polybot/internal/binance"
	"github.com/web3guy0/polybot/internal/chainlink"
	"github.com/web3guy0/polybot/internal/cmc"
	"github.com/web3guy0/polybot/internal/config"
	"github.com/web3guy0/polybot/internal/database"
	"github.com/web3guy0/polybot/internal/polymarket"
)

// WindowState tracks the state of a prediction window
type WindowState struct {
	Window           *polymarket.PredictionWindow
	StartPrice       decimal.Decimal // BTC price when window started (from Binance/Chainlink)
	StartUpOdds      decimal.Decimal // Polymarket UP odds at window start
	StartDownOdds    decimal.Decimal // Polymarket DOWN odds at window start
	StartTime        time.Time
	LastOddsCheck    time.Time
	CurrentUpOdds    decimal.Decimal
	CurrentDownOdds  decimal.Decimal
	TradesThisWindow int
	LastTradeTime    time.Time
}

// Opportunity represents a detected arbitrage opportunity
type Opportunity struct {
	Window         *polymarket.PredictionWindow
	Direction      string          // "UP" or "DOWN"
	CurrentBTC     decimal.Decimal // Current Binance price
	StartBTC       decimal.Decimal // Window start price
	PriceChangePct decimal.Decimal // % change from window start
	MarketOdds     decimal.Decimal // Current odds on Polymarket for this direction
	FairOdds       decimal.Decimal // What odds should be given the move
	Edge           decimal.Decimal // Expected value per dollar
	Confidence     float64         // How confident we are (0-1)
	DetectedAt     time.Time
}

// Trade represents an executed arbitrage trade
type Trade struct {
	ID             string
	WindowID       string
	Question       string
	Direction      string          // "UP" or "DOWN"
	TokenID        string          // Token ID we bought
	EntryPrice     decimal.Decimal // What we paid (e.g., 0.45)
	ExitPrice      decimal.Decimal // What we sold at (0 if held to resolution)
	Amount         decimal.Decimal // Position size in USD
	Shares         decimal.Decimal // Number of shares purchased
	BTCAtEntry     decimal.Decimal // BTC price when we entered
	BTCAtStart     decimal.Decimal // BTC price at window start
	PriceChangePct decimal.Decimal // % move that triggered trade
	Edge           decimal.Decimal // Expected edge at entry
	Status         string          // "open", "exited", "won", "lost"
	ExitType       string          // "quick_flip", "resolution", ""
	EnteredAt      time.Time
	ExitedAt       *time.Time
	ResolvedAt     *time.Time
	Profit         decimal.Decimal
}

// OpenPosition represents an active position being monitored for exit
type OpenPosition struct {
	Trade          *Trade
	TokenID        string
	Direction      string          // "UP" or "DOWN"
	EntryPrice     decimal.Decimal
	Shares         decimal.Decimal
	BTCMoveAtEntry decimal.Decimal // The % BTC move when we entered
	WindowEndTime  time.Time
	EnteredAt      time.Time
}

// Engine is the core latency arbitrage engine
type Engine struct {
	cfg             *config.Config
	db              *database.Database // Database for storing window prices
	binanceClient   *binance.Client
	binanceMulti    *binance.MultiClient // Multi-asset Binance (BTC, ETH, SOL)
	chainlinkClient *chainlink.Client // Chainlink price feed (what Polymarket uses for resolution)
	multiChainlink  *chainlink.MultiClient // Multi-asset Chainlink feeds (BTC, ETH, SOL)
	cmcClient       *cmc.Client       // CMC price feed (fast updates, same source as Data Streams!)
	windowScanner   *polymarket.WindowScanner
	wsClient        *polymarket.WSClient // Real-time WebSocket for odds
	clobClient      *CLOBClient // CLOB trading client
	asset           string      // Asset this engine tracks (BTC, ETH, SOL)

	// Window tracking
	windowStates map[string]*WindowState
	windowsMu    sync.RWMutex
	
	// Pre-captured prices for upcoming windows (captured at exact T=0)
	scheduledCaptures map[string]time.Time   // windowID -> scheduled capture time
	capturedPrices    map[string]decimal.Decimal // windowID -> captured price at T=0
	capturesMu        sync.RWMutex

	// Trade tracking
	trades        []Trade
	tradesMu      sync.RWMutex
	totalTrades   int
	wonTrades     int
	lostTrades    int
	totalProfit   decimal.Decimal
	dailyPL       decimal.Decimal
	lastDailyReset time.Time

	// Open position tracking for exit monitoring
	openPositions map[string]*OpenPosition
	positionsMu   sync.RWMutex

	// Configuration
	minPriceMove     decimal.Decimal // Min % move to trigger (default 0.2%)
	minOddsForEntry  decimal.Decimal // Min odds to buy (default 0.35 for 35¬¢ floor)
	maxOddsForEntry  decimal.Decimal // Max odds we'll pay (default 0.65 for 35-65¬¢ range)
	minEdge          decimal.Decimal // Min expected edge (default 0.10)
	positionSize     decimal.Decimal // Base per-trade size in USD
	maxDailyTrades   int             // Max trades per day
	maxTradesPerWindow int           // Max trades per window
	cooldownSeconds  int             // Seconds between trades

	// Dynamic Position Sizing (trade bigger when more confident!)
	// Big move (>0.3%) ‚Üí 3x base position
	// Medium move (0.2-0.3%) ‚Üí 2x base position
	// Small move (0.1-0.2%) ‚Üí 1x base position
	dynamicSizingEnabled bool
	smallMoveMultiplier  decimal.Decimal // 1x for 0.1-0.2% moves
	mediumMoveMultiplier decimal.Decimal // 2x for 0.2-0.3% moves
	largeMoveMultiplier  decimal.Decimal // 3x for >0.3% moves

	// Exit Strategy Configuration (3 paths)
	// Exit Path A: Quick flip when odds reach 75¬¢+
	// Exit Path B: Hold to resolution when move is large and time is short
	// Exit Path C: STOP-LOSS when odds drop 20% from entry
	exitOddsThreshold  decimal.Decimal // Sell when odds reach this (default 0.75)
	holdThreshold      decimal.Decimal // Hold if price move exceeds this % (default 0.005 = 0.5%)
	stopLossPct        decimal.Decimal // Stop-loss: exit if odds drop this % from entry (default 0.20 = 20%)

	// Callbacks
	onOpportunity func(Opportunity)
	onTrade       func(Trade)
	onExit        func(Trade) // Called when position is exited

	running bool
	stopCh  chan struct{}
}

// EngineConfig allows runtime configuration of the engine
type EngineConfig struct {
	MinPriceMove       decimal.Decimal
	MaxOddsForEntry    decimal.Decimal
	MinEdge            decimal.Decimal
	PositionSize       decimal.Decimal
	MaxDailyTrades     int
	MaxTradesPerWindow int
	CooldownSeconds    int
}

// NewEngine creates a new arbitrage engine
// Uses CMC for fast price detection (same source as Polymarket Data Streams!)
func NewEngine(cfg *config.Config, bc *binance.Client, cl *chainlink.Client, cmcCl *cmc.Client, ws *polymarket.WindowScanner) *Engine {
	e := &Engine{
		cfg:              cfg,
		binanceClient:    bc,
		chainlinkClient:  cl,
		cmcClient:        cmcCl,
		windowScanner:    ws,
		windowStates:     make(map[string]*WindowState),
		scheduledCaptures: make(map[string]time.Time),
		capturedPrices:   make(map[string]decimal.Decimal),
		openPositions:    make(map[string]*OpenPosition),
		trades:           make([]Trade, 0),
		totalProfit:      decimal.Zero,
		dailyPL:          decimal.Zero,
		lastDailyReset:   time.Now(),
		stopCh:           make(chan struct{}),

		// Default config - FEE-ADJUSTED strategy (with 3.15% Polymarket fee)
		// Buy at 25-65¬¢, exit at 75¬¢ OR stop-loss at -20% OR hold to resolution
		minPriceMove:       decimal.NewFromFloat(0.001),  // 0.10% min move (~$90 on BTC) - with accurate parallel snapshot
		minOddsForEntry:    decimal.NewFromFloat(0.25),   // 25 cents min (aggressive!)
		maxOddsForEntry:    decimal.NewFromFloat(0.65),   // 65 cents max
		minEdge:            decimal.NewFromFloat(0.10),   // 10% min edge
		positionSize:       decimal.NewFromFloat(100),    // $100 base per trade
		maxDailyTrades:     200,
		maxTradesPerWindow: 3,
		cooldownSeconds:    10,

		// Dynamic Position Sizing - trade BIGGER when more confident!
		dynamicSizingEnabled: true,
		smallMoveMultiplier:  decimal.NewFromFloat(1),    // 0.1-0.2% ‚Üí 1x ($1)
		mediumMoveMultiplier: decimal.NewFromFloat(2),    // 0.2-0.3% ‚Üí 2x ($2)
		largeMoveMultiplier:  decimal.NewFromFloat(3),    // >0.3%   ‚Üí 3x ($3)

		// Triple exit strategy thresholds
		exitOddsThreshold:  decimal.NewFromFloat(0.75),   // Quick flip at 75¬¢
		holdThreshold:      decimal.NewFromFloat(0.002),  // Hold if move > 0.2% (~$180 on BTC)
		stopLossPct:        decimal.NewFromFloat(0.20),   // üõë STOP-LOSS: exit if odds drop 20%
	}

	// Override from config if set
	if cfg.ArbPositionSize.GreaterThan(decimal.Zero) {
		e.positionSize = cfg.ArbPositionSize
	}
	if cfg.ArbMinOddsForEntry.GreaterThan(decimal.Zero) {
		e.minOddsForEntry = cfg.ArbMinOddsForEntry
	}
	if cfg.ArbMaxOddsForEntry.GreaterThan(decimal.Zero) {
		e.maxOddsForEntry = cfg.ArbMaxOddsForEntry
	}
	if cfg.ArbExitOddsThreshold.GreaterThan(decimal.Zero) {
		e.exitOddsThreshold = cfg.ArbExitOddsThreshold
	}
	if cfg.ArbHoldThreshold.GreaterThan(decimal.Zero) {
		e.holdThreshold = cfg.ArbHoldThreshold
	}
	if cfg.ArbStopLossPct.GreaterThan(decimal.Zero) {
		e.stopLossPct = cfg.ArbStopLossPct
	}
	if cfg.ArbMaxTradesPerWindow > 0 {
		e.maxTradesPerWindow = cfg.ArbMaxTradesPerWindow
	}
	if cfg.ArbMaxDailyTrades > 0 {
		e.maxDailyTrades = cfg.ArbMaxDailyTrades
	}
	if cfg.ArbCooldownSeconds > 0 {
		e.cooldownSeconds = cfg.ArbCooldownSeconds
	}
	if cfg.ArbMinPriceMove.GreaterThan(decimal.Zero) {
		e.minPriceMove = cfg.ArbMinPriceMove
	}
	if cfg.ArbMinEdge.GreaterThan(decimal.Zero) {
		e.minEdge = cfg.ArbMinEdge
	}

	return e
}

// SetCLOBClient sets the CLOB client for order execution
func (e *Engine) SetCLOBClient(client *CLOBClient) {
	e.clobClient = client
	log.Info().Str("asset", e.asset).Msg("üîó CLOB client connected to engine")
}

// SetMultiChainlink sets the multi-asset Chainlink client
func (e *Engine) SetMultiChainlink(client *chainlink.MultiClient) {
	e.multiChainlink = client
	log.Info().Str("asset", e.asset).Msg("‚õìÔ∏è Multi-asset Chainlink connected to engine")
}

// SetBinanceMulti sets the multi-asset Binance client
func (e *Engine) SetBinanceMulti(client *binance.MultiClient) {
	e.binanceMulti = client
	log.Info().Str("asset", e.asset).Msg("üìà Multi-asset Binance connected to engine")
}

// SetWSClient sets the Polymarket WebSocket client for real-time odds
func (e *Engine) SetWSClient(client *polymarket.WSClient) {
	e.wsClient = client
	log.Info().Str("asset", e.asset).Msg("üì° Polymarket WebSocket connected to engine")
}

// SetDatabase sets the database for storing window prices
func (e *Engine) SetDatabase(db *database.Database) {
	e.db = db
	log.Info().Str("asset", e.asset).Msg("üíæ Database connected to engine")
}

// SetAsset sets the asset this engine tracks (BTC, ETH, SOL)
func (e *Engine) SetAsset(asset string) {
	e.asset = asset
}

// GetAsset returns the asset this engine tracks
func (e *Engine) GetAsset() string {
	if e.asset == "" {
		return "BTC" // Default
	}
	return e.asset
}

// GetWindowScanner returns the window scanner for this engine
func (e *Engine) GetWindowScanner() *polymarket.WindowScanner {
	return e.windowScanner
}

// SetExitCallback sets callback for position exits
func (e *Engine) SetExitCallback(cb func(Trade)) {
	e.onExit = cb
}

// SetConfig updates engine configuration
func (e *Engine) SetConfig(cfg EngineConfig) {
	if !cfg.MinPriceMove.IsZero() {
		e.minPriceMove = cfg.MinPriceMove
	}
	if !cfg.MaxOddsForEntry.IsZero() {
		e.maxOddsForEntry = cfg.MaxOddsForEntry
	}
	if !cfg.MinEdge.IsZero() {
		e.minEdge = cfg.MinEdge
	}
	if !cfg.PositionSize.IsZero() {
		e.positionSize = cfg.PositionSize
	}
	if cfg.MaxDailyTrades > 0 {
		e.maxDailyTrades = cfg.MaxDailyTrades
	}
	if cfg.MaxTradesPerWindow > 0 {
		e.maxTradesPerWindow = cfg.MaxTradesPerWindow
	}
	if cfg.CooldownSeconds > 0 {
		e.cooldownSeconds = cfg.CooldownSeconds
	}
}

// SetOpportunityCallback sets callback for detected opportunities (for alerts)
func (e *Engine) SetOpportunityCallback(cb func(Opportunity)) {
	e.onOpportunity = cb
}

// SetTradeCallback sets callback for executed trades
func (e *Engine) SetTradeCallback(cb func(Trade)) {
	e.onTrade = cb
}

// SetPositionSize updates the position size at runtime
func (e *Engine) SetPositionSize(size decimal.Decimal) {
	e.positionSize = size
	log.Info().Str("size", size.String()).Msg("Position size updated")
}

// GetPositionSize returns current position size
func (e *Engine) GetPositionSize() decimal.Decimal {
	return e.positionSize
}

// IsLive returns whether live trading is enabled
func (e *Engine) IsLive() bool {
	return !e.cfg.DryRun
}

// GetBTCPrice returns the current BTC price from Binance with Chainlink comparison
// Binance is used for real-time detection, Chainlink is what Polymarket uses for resolution
func (e *Engine) GetBTCPrice() (binancePrice, chainlinkPrice decimal.Decimal, priceDiff decimal.Decimal) {
	binancePrice = e.binanceClient.GetCurrentPrice()
	
	if e.chainlinkClient != nil {
		chainlinkPrice = e.chainlinkClient.GetCurrentPrice()
		if !chainlinkPrice.IsZero() && !binancePrice.IsZero() {
			priceDiff = binancePrice.Sub(chainlinkPrice).Div(chainlinkPrice).Mul(decimal.NewFromInt(100))
		}
	}
	
	return binancePrice, chainlinkPrice, priceDiff
}

// GetChainlinkPrice returns the Chainlink price (what Polymarket uses for resolution)
func (e *Engine) GetChainlinkPrice() decimal.Decimal {
	if e.chainlinkClient != nil {
		return e.chainlinkClient.GetCurrentPrice()
	}
	return decimal.Zero
}

// Start begins the arbitrage engine
func (e *Engine) Start() {
	e.running = true

	// Main arbitrage loop - check every 100ms for speed (critical for 30-90s lag window)
	go e.arbitrageLoop()

	// Window state updater - refresh window start prices
	go e.windowStateLoop()

	// Odds refresher - keep odds fresh
	go e.oddsRefreshLoop()

	// Position monitor - check for exit opportunities every 100ms
	go e.positionMonitorLoop()
	
	// Note: Price to Beat is now stored in database when window first detected
	// (see updateWindowStates - no longer need proactive capture loop)

	log.Info().
		Str("min_move", e.minPriceMove.Mul(decimal.NewFromInt(100)).String()+"%").
		Str("entry_range", e.minOddsForEntry.String()+"-"+e.maxOddsForEntry.String()).
		Str("exit_target", e.exitOddsThreshold.String()).
		Str("stop_loss", e.stopLossPct.Mul(decimal.NewFromInt(100)).String()+"%").
		Str("position_size", e.positionSize.String()).
		Msg("‚ö° Latency Arbitrage Engine started (100ms scan)")
}

// Stop stops the engine
func (e *Engine) Stop() {
	e.running = false
	close(e.stopCh)
	log.Info().Msg("Arbitrage engine stopped")
}

// GetWindowState returns the state for a specific window
func (e *Engine) GetWindowState(windowID string) *WindowState {
	e.windowsMu.RLock()
	defer e.windowsMu.RUnlock()
	return e.windowStates[windowID]
}

// GetCurrentPrice returns current price for the engine's asset (uses Chainlink as source of truth)
func (e *Engine) GetCurrentPrice() decimal.Decimal {
	asset := e.GetAsset()
	
	// Use multi-asset Chainlink if available
	if e.multiChainlink != nil {
		price := e.multiChainlink.GetPrice(asset)
		if !price.IsZero() {
			return price
		}
	}
	
	// Fallback to single Chainlink (BTC only)
	if e.chainlinkClient != nil {
		return e.chainlinkClient.GetCurrentPrice()
	}
	
	// Last resort: Binance
	return e.binanceClient.GetCurrentPrice()
}

// arbitrageLoop is the main loop checking for opportunities every 100ms
// Speed is critical - the 30-90 second lag window requires fast detection
func (e *Engine) arbitrageLoop() {
	ticker := time.NewTicker(100 * time.Millisecond)
	statusTicker := time.NewTicker(10 * time.Second) // Status update every 10s
	defer ticker.Stop()
	defer statusTicker.Stop()

	// Initial status after 2s startup
	go func() {
		time.Sleep(2 * time.Second)
		e.logStatus()
	}()

	for {
		select {
		case <-ticker.C:
			e.checkOpportunities()
		case <-statusTicker.C:
			e.logStatus() // Show current market analysis
		case <-e.stopCh:
			return
		}
	}
}

// logStatus logs current market analysis for debugging
func (e *Engine) logStatus() {
	e.windowsMu.RLock()
	defer e.windowsMu.RUnlock()

	asset := e.GetAsset()
	
	// Use CMC price for this asset (fastest, same source as Data Streams!)
	var currentPrice decimal.Decimal
	var priceSource string = "CMC"
	
	if e.cmcClient != nil && !e.cmcClient.IsAssetStale(asset) {
		currentPrice = e.cmcClient.GetAssetPrice(asset)
	}
	if currentPrice.IsZero() && e.chainlinkClient != nil && asset == "BTC" {
		currentPrice = e.chainlinkClient.GetCurrentPrice()
		priceSource = "CL"
	}
	_ = priceSource // Used in detailed log
	if currentPrice.IsZero() && asset == "BTC" {
		currentPrice = e.binanceClient.GetCurrentPrice()
		priceSource = "BN"
	}

	for _, state := range e.windowStates {
		if state.StartPrice.IsZero() {
			continue
		}

		priceChange := currentPrice.Sub(state.StartPrice)
		priceChangePct := priceChange.Div(state.StartPrice).Mul(decimal.NewFromInt(100))
		absChangePct := priceChangePct.Abs()

		var direction string
		var targetOdds decimal.Decimal
		if priceChangePct.IsPositive() {
			direction = "UP"
			targetOdds = state.CurrentUpOdds
		} else {
			direction = "DOWN"
			targetOdds = state.CurrentDownOdds
		}

		// Determine status
		minMovePct := e.minPriceMove.Mul(decimal.NewFromInt(100))
		var status string
		
		if absChangePct.LessThan(minMovePct) {
			status = fmt.Sprintf("‚è≥ %.2f%% < %.1f%%", absChangePct.InexactFloat64(), minMovePct.InexactFloat64())
		} else if targetOdds.GreaterThan(e.maxOddsForEntry) {
			status = fmt.Sprintf("üìà %.0f¬¢>%.0f¬¢", targetOdds.Mul(decimal.NewFromInt(100)).InexactFloat64(), e.maxOddsForEntry.Mul(decimal.NewFromInt(100)).InexactFloat64())
		} else if targetOdds.LessThan(e.minOddsForEntry) {
			status = fmt.Sprintf("üìâ %.0f¬¢<%.0f¬¢", targetOdds.Mul(decimal.NewFromInt(100)).InexactFloat64(), e.minOddsForEntry.Mul(decimal.NewFromInt(100)).InexactFloat64())
		} else {
			status = "üöÄ READY!"
		}

		// Full detailed log for dashboard
		log.Info().Msg(fmt.Sprintf("üìä %s $%.2f %s%.2f%% UP:%0.f¬¢ DN:%.0f¬¢ %s",
			asset,
			currentPrice.InexactFloat64(),
			direction[:1],
			absChangePct.InexactFloat64(),
			state.CurrentUpOdds.Mul(decimal.NewFromInt(100)).InexactFloat64(),
			state.CurrentDownOdds.Mul(decimal.NewFromInt(100)).InexactFloat64(),
			status,
		))
	}
}

// windowStateLoop updates window states every 30 seconds
func (e *Engine) windowStateLoop() {
	ticker := time.NewTicker(2 * time.Second) // Faster window state updates
	defer ticker.Stop()

	// Initial update
	e.updateWindowStates()

	for {
		select {
		case <-ticker.C:
			e.updateWindowStates()
		case <-e.stopCh:
			return
		}
	}
}

// oddsRefreshLoop refreshes odds every 2 seconds
func (e *Engine) oddsRefreshLoop() {
	ticker := time.NewTicker(200 * time.Millisecond) // Fast odds refresh
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			e.refreshOdds()
		case <-e.stopCh:
			return
		}
	}
}

// scheduledCaptureLoop PROACTIVELY captures prices at :00, :15, :30, :45 
// Polymarket windows aren't published until AFTER they start, so we predict start times
// and capture Chainlink+CMC+Binance prices at exact T=0
func (e *Engine) scheduledCaptureLoop() {
	ticker := time.NewTicker(100 * time.Millisecond) // Check every 100ms for precision
	defer ticker.Stop()
	
	var lastCaptureMinute int = -1 // Track which minute we last captured
	
	for {
		select {
		case <-ticker.C:
			now := time.Now()
			minute := now.Minute()
			second := now.Second()
			
			// Capture at :00, :15, :30, :45 (within first 2 seconds of window start)
			isWindowStart := (minute%15 == 0) && second < 2
			
			// Only capture once per window start
			if isWindowStart && minute != lastCaptureMinute {
				lastCaptureMinute = minute
				e.captureAtWindowStart(now)
			}
			
		case <-e.stopCh:
			return
		}
	}
}

// captureAtWindowStart captures prices at exact T=0 for the starting window
// Stores prices keyed by predicted window slug for later lookup
func (e *Engine) captureAtWindowStart(captureTime time.Time) {
	asset := e.GetAsset()
	
	// Get prices from all sources simultaneously
	var cmcPrice, chainlinkPrice, binancePrice decimal.Decimal
	
	if e.cmcClient != nil {
		cmcPrice = e.cmcClient.GetAssetPrice(asset)
	}
	if e.multiChainlink != nil {
		chainlinkPrice = e.multiChainlink.GetPrice(asset)
	}
	if e.binanceMulti != nil {
		binancePrice = e.binanceMulti.GetPrice(asset)
	}
	
	// Calculate captured price (Chainlink is what Polymarket actually uses!)
	var capturedPrice decimal.Decimal
	if !chainlinkPrice.IsZero() {
		// Chainlink is the SOURCE OF TRUTH for Polymarket resolution
		capturedPrice = chainlinkPrice
	} else if !cmcPrice.IsZero() {
		capturedPrice = cmcPrice
	} else if !binancePrice.IsZero() {
		capturedPrice = binancePrice
	}
	
	if capturedPrice.IsZero() {
		log.Warn().Str("asset", asset).Msg("‚ö†Ô∏è Failed to capture price at T=0")
		return
	}
	
	// Generate window slug for this capture (used to match with Polymarket windows)
	// Windows use 15-minute intervals aligned to Unix time
	windowTs := (captureTime.Unix() / 900) * 900
	windowSlug := fmt.Sprintf("%s-updown-15m-%d", strings.ToLower(asset), windowTs)
	
	e.capturesMu.Lock()
	e.capturedPrices[windowSlug] = capturedPrice
	e.capturesMu.Unlock()
	
	log.Info().
		Str("asset", asset).
		Str("window_slug", windowSlug).
		Str("price_to_beat", capturedPrice.StringFixed(2)).
		Str("chainlink", chainlinkPrice.StringFixed(2)).
		Str("cmc", cmcPrice.StringFixed(2)).
		Str("binance", binancePrice.StringFixed(2)).
		Msg("üéØ CAPTURED Price to Beat at T=0!")
}

// getCapturedPrice retrieves a pre-captured price for a window
func (e *Engine) getCapturedPrice(windowSlug string) (decimal.Decimal, bool) {
	e.capturesMu.RLock()
	defer e.capturesMu.RUnlock()
	price, ok := e.capturedPrices[windowSlug]
	return price, ok
}

// positionMonitorLoop monitors open positions for exit opportunities every 100ms
// Implements dual exit strategy:
// - Quick Flip: Sell when odds reach 70-80¬¢ (30-90 seconds after entry typically)
// - Hold to Resolution: Keep position if BTC move was large (>0.5%) and time remaining is short
func (e *Engine) positionMonitorLoop() {
	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			e.checkPositionExits()
		case <-e.stopCh:
			return
		}
	}
}

// checkPositionExits evaluates all open positions for exit conditions
func (e *Engine) checkPositionExits() {
	e.positionsMu.RLock()
	positions := make([]*OpenPosition, 0, len(e.openPositions))
	for _, pos := range e.openPositions {
		positions = append(positions, pos)
	}
	e.positionsMu.RUnlock()

	if len(positions) == 0 {
		return
	}

	oddsFetcher := NewOddsFetcher()

	for _, pos := range positions {
		// Get current odds for this token
		odds, err := oddsFetcher.GetLiveOdds(pos.TokenID)
		if err != nil {
			continue
		}

		// Check exit conditions
		exitType, shouldExit := e.shouldExitPosition(pos, odds)
		if shouldExit {
			e.executeExit(pos, odds, exitType)
		}
	}
}

// shouldExitPosition determines if we should exit a position and how
// Returns (exitType, shouldExit)
// DYNAMIC EXIT STRATEGY based on current price movement:
//   A) DANGER ZONE: Force exit 90s before window end (HIGHEST PRIORITY!)
//   B) STOP-LOSS at -20% (risk management - CRITICAL!)
//   C) REVERSAL EXIT: Price reversed against us - exit immediately
//   D) MOMENTUM EXIT: Dynamic target based on current vs entry movement
//   E) MIN PROFIT EXIT: Take any profit if move is weakening
func (e *Engine) shouldExitPosition(pos *OpenPosition, odds *LiveOdds) (string, bool) {
	timeRemaining := time.Until(pos.WindowEndTime)

	// ‚ö†Ô∏è EXIT PATH A: DANGER ZONE - Force exit 90 seconds before end!
	dangerZoneSeconds := 90
	if timeRemaining.Seconds() > 0 && int(timeRemaining.Seconds()) <= dangerZoneSeconds {
		log.Warn().
			Str("position", pos.Trade.ID).
			Str("time_remaining", timeRemaining.Round(time.Second).String()).
			Msg("‚ö†Ô∏è DANGER ZONE - Force exit before resolution chaos!")
		return "danger_zone", true
	}

	// ‚ö†Ô∏è EXIT PATH B: STOP-LOSS at -20%
	if !pos.EntryPrice.IsZero() && !odds.BestBid.IsZero() {
		priceDropPct := pos.EntryPrice.Sub(odds.BestBid).Div(pos.EntryPrice)
		
		if priceDropPct.GreaterThanOrEqual(e.stopLossPct) {
			loss := pos.EntryPrice.Sub(odds.BestBid).Mul(pos.Shares)
			log.Warn().
				Str("position", pos.Trade.ID).
				Str("entry", pos.EntryPrice.String()).
				Str("current", odds.BestBid.String()).
				Str("drop_pct", priceDropPct.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
				Str("loss", loss.Neg().String()).
				Msg("üõë STOP-LOSS TRIGGERED - Cutting losses!")
			return "stop_loss", true
		}
	}

	// üìä Get CURRENT price movement to compare with entry movement
	currentMove := e.getCurrentPriceMove(pos)
	entryMove := pos.BTCMoveAtEntry
	
	// ‚ö†Ô∏è EXIT PATH C: REVERSAL EXIT - Price reversed against our position!
	// If we bought UP but price is now DOWN (or vice versa), EXIT IMMEDIATELY
	if e.isMovementReversed(pos.Direction, currentMove) {
		log.Warn().
			Str("position", pos.Trade.ID).
			Str("direction", pos.Direction).
			Str("entry_move", entryMove.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
			Str("current_move", currentMove.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
			Msg("üîÑ REVERSAL DETECTED - Exiting to avoid resolution loss!")
		return "reversal", true
	}

	// üìà EXIT PATH D: DYNAMIC MOMENTUM-BASED EXIT
	// Calculate dynamic exit target based on move strength
	dynamicTarget := e.calculateDynamicExitTarget(pos, currentMove, entryMove)
	
	if odds.BestBid.GreaterThanOrEqual(dynamicTarget) {
		profit := odds.BestBid.Sub(pos.EntryPrice).Mul(pos.Shares)
		profitPct := odds.BestBid.Sub(pos.EntryPrice).Div(pos.EntryPrice).Mul(decimal.NewFromInt(100))

		log.Info().
			Str("position", pos.Trade.ID).
			Str("entry", pos.EntryPrice.String()).
			Str("exit", odds.BestBid.String()).
			Str("dynamic_target", dynamicTarget.String()).
			Str("profit", profit.String()).
			Str("profit_pct", profitPct.StringFixed(1)+"%").
			Str("current_move", currentMove.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
			Msg("üéØ DYNAMIC EXIT - Target reached!")
		return "momentum_exit", true
	}

	// üí∞ EXIT PATH E: TAKE ANY PROFIT if move is weakening significantly
	// If current move is less than 50% of entry move, take whatever profit we can
	moveRatio := decimal.Zero
	if !entryMove.IsZero() {
		moveRatio = currentMove.Div(entryMove)
	}
	
	minProfitThreshold := decimal.NewFromFloat(0.05) // 5% profit minimum
	profitPct := decimal.Zero
	if !pos.EntryPrice.IsZero() {
		profitPct = odds.BestBid.Sub(pos.EntryPrice).Div(pos.EntryPrice)
	}
	
	// Move weakened to <50% of entry AND we have at least 5% profit
	if moveRatio.LessThan(decimal.NewFromFloat(0.5)) && profitPct.GreaterThanOrEqual(minProfitThreshold) {
		profit := odds.BestBid.Sub(pos.EntryPrice).Mul(pos.Shares)
		log.Info().
			Str("position", pos.Trade.ID).
			Str("move_ratio", moveRatio.Mul(decimal.NewFromInt(100)).StringFixed(0)+"%").
			Str("profit", profit.String()).
			Str("profit_pct", profitPct.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
			Msg("üìâ WEAKENING MOVE - Taking available profit!")
		return "weak_move_exit", true
	}

	// Fallback: If less than 30 seconds remain and we're in profit, exit
	if timeRemaining < 30*time.Second && odds.BestBid.GreaterThan(pos.EntryPrice) {
		return "quick_flip", true
	}

	return "", false
}

// getCurrentPriceMove calculates current price movement from window start
func (e *Engine) getCurrentPriceMove(pos *OpenPosition) decimal.Decimal {
	// Get current price from CMC (fast source)
	currentPrice := decimal.Zero
	if e.cmcClient != nil {
		currentPrice = e.cmcClient.GetAssetPrice(e.asset)
	}
	if currentPrice.IsZero() && e.binanceClient != nil {
		currentPrice = e.binanceClient.GetCurrentPrice()
	}
	if currentPrice.IsZero() {
		return pos.BTCMoveAtEntry // Fallback to entry move
	}

	// Get window start price
	startPrice := decimal.Zero
	if pos.Trade != nil && !pos.Trade.BTCAtStart.IsZero() {
		startPrice = pos.Trade.BTCAtStart
	}
	if startPrice.IsZero() {
		return pos.BTCMoveAtEntry
	}

	// Calculate % change
	return currentPrice.Sub(startPrice).Div(startPrice)
}

// isMovementReversed checks if price has moved against our position
func (e *Engine) isMovementReversed(direction string, currentMove decimal.Decimal) bool {
	// Reversal threshold: 0.05% in wrong direction
	reversalThreshold := decimal.NewFromFloat(0.0005)
	
	if direction == "UP" {
		// We bet UP but price is now DOWN
		return currentMove.LessThan(reversalThreshold.Neg())
	} else {
		// We bet DOWN but price is now UP
		return currentMove.GreaterThan(reversalThreshold)
	}
}

// calculateDynamicExitTarget adjusts exit target based on momentum
// Strong move ‚Üí higher target (wait for 80¬¢+)
// Weak move ‚Üí lower target (take 55¬¢)
// Base: entry price + scaled profit based on move strength
func (e *Engine) calculateDynamicExitTarget(pos *OpenPosition, currentMove, entryMove decimal.Decimal) decimal.Decimal {
	// Base minimum: at least break even + 5%
	minTarget := pos.EntryPrice.Mul(decimal.NewFromFloat(1.05))
	
	// Maximum target: never wait for more than 85¬¢
	maxTarget := decimal.NewFromFloat(0.85)
	
	// Calculate move strength ratio
	moveRatio := decimal.NewFromFloat(1.0)
	if !entryMove.IsZero() {
		moveRatio = currentMove.Abs().Div(entryMove.Abs())
	}
	
	// Dynamic scaling:
	// - Move 2x stronger ‚Üí target 80¬¢
	// - Move same ‚Üí target 65¬¢  
	// - Move 50% weaker ‚Üí target 55¬¢
	// - Move reversed ‚Üí handled by reversal exit
	
	var target decimal.Decimal
	
	if moveRatio.GreaterThanOrEqual(decimal.NewFromFloat(2.0)) {
		// Move strengthened 2x+ ‚Üí wait for 80¬¢
		target = decimal.NewFromFloat(0.80)
	} else if moveRatio.GreaterThanOrEqual(decimal.NewFromFloat(1.5)) {
		// Move strengthened 1.5x ‚Üí wait for 75¬¢
		target = decimal.NewFromFloat(0.75)
	} else if moveRatio.GreaterThanOrEqual(decimal.NewFromFloat(1.0)) {
		// Move same or slightly stronger ‚Üí 65¬¢
		target = decimal.NewFromFloat(0.65)
	} else if moveRatio.GreaterThanOrEqual(decimal.NewFromFloat(0.7)) {
		// Move slightly weaker ‚Üí 58¬¢
		target = decimal.NewFromFloat(0.58)
	} else if moveRatio.GreaterThanOrEqual(decimal.NewFromFloat(0.5)) {
		// Move weakened to 50-70% ‚Üí 52¬¢
		target = decimal.NewFromFloat(0.52)
	} else {
		// Move very weak ‚Üí take any profit above entry+5%
		target = minTarget
	}
	
	// Ensure within bounds
	if target.LessThan(minTarget) {
		target = minTarget
	}
	if target.GreaterThan(maxTarget) {
		target = maxTarget
	}
	
	log.Debug().
		Str("position", pos.Trade.ID).
		Str("entry_move", entryMove.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
		Str("current_move", currentMove.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
		Str("move_ratio", moveRatio.StringFixed(2)+"x").
		Str("dynamic_target", target.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Msg("üìä Dynamic exit target calculated")
	
	return target
}

// executeExit sells the position
func (e *Engine) executeExit(pos *OpenPosition, odds *LiveOdds, exitType string) {
	if e.cfg.DryRun || e.clobClient == nil {
		// Dry run - just log and update state
		e.recordExit(pos, odds.BestBid, exitType, true)
		return
	}

	// Place market sell order
	resp, err := e.clobClient.PlaceMarketSell(pos.TokenID, pos.Shares)
	if err != nil {
		log.Error().Err(err).Str("position", pos.Trade.ID).Msg("Failed to execute exit")
		return
	}

	if resp.Status == "matched" || resp.Status == "filled" {
		e.recordExit(pos, odds.BestBid, exitType, true)
	} else {
		log.Warn().Str("status", resp.Status).Str("position", pos.Trade.ID).Msg("Exit order not filled")
	}
}

// recordExit updates trade state after exit
func (e *Engine) recordExit(pos *OpenPosition, exitPrice decimal.Decimal, exitType string, success bool) {
	now := time.Now()
	profit := exitPrice.Sub(pos.EntryPrice).Mul(pos.Shares)

	// Update trade
	e.tradesMu.Lock()
	for i := range e.trades {
		if e.trades[i].ID == pos.Trade.ID {
			e.trades[i].Status = "exited"
			e.trades[i].ExitType = exitType
			e.trades[i].ExitPrice = exitPrice
			e.trades[i].ExitedAt = &now
			e.trades[i].Profit = profit

			// Update stats
			e.totalProfit = e.totalProfit.Add(profit)
			e.dailyPL = e.dailyPL.Add(profit)
			if profit.IsPositive() {
				e.wonTrades++
			} else {
				e.lostTrades++
			}

			// Fire callback
			if e.onExit != nil {
				e.onExit(e.trades[i])
			}
			break
		}
	}
	e.tradesMu.Unlock()

	// Remove from open positions
	e.positionsMu.Lock()
	delete(e.openPositions, pos.Trade.ID)
	e.positionsMu.Unlock()

	log.Info().
		Str("id", pos.Trade.ID).
		Str("direction", pos.Direction).
		Str("entry", pos.EntryPrice.String()).
		Str("exit", exitPrice.String()).
		Str("profit", profit.String()).
		Str("exit_type", exitType).
		Msg("üí∞ Position exited")
}

// updateWindowStates tracks active windows and their start prices
func (e *Engine) updateWindowStates() {
	windows := e.windowScanner.GetActiveWindows()
	binancePrice, chainlinkPrice, priceDiff := e.GetBTCPrice()

	// Log both price sources for comparison
	logEvent := log.Debug().
		Int("active_windows", len(windows)).
		Str("binance", binancePrice.StringFixed(2))
	
	if !chainlinkPrice.IsZero() {
		logEvent = logEvent.
			Str("chainlink", chainlinkPrice.StringFixed(2)).
			Str("diff_pct", priceDiff.StringFixed(4)+"%")
	}
	logEvent.Msg("üìä Window state update")

	e.windowsMu.Lock()
	defer e.windowsMu.Unlock()

	// Track new windows
	for i := range windows {
		w := &windows[i]
		if _, exists := e.windowStates[w.ID]; !exists {
			// NEW WINDOW DETECTED - Get "Price to Beat"
			asset := e.GetAsset()
			var startPrice decimal.Decimal
			var priceSource string
			
			// PRIORITY 1: Check database for stored price (from when we first saw this window)
			if e.db != nil && w.Slug != "" {
				if stored, err := e.db.GetWindowPrice(w.Slug); err == nil && stored != nil {
					startPrice = stored.PriceToBeat
					priceSource = "Database (captured at first detection)"
					log.Info().
						Str("asset", asset).
						Str("slug", w.Slug).
						Str("price_to_beat", startPrice.StringFixed(2)).
						Str("captured_at", stored.CapturedAt.Format("15:04:05")).
						Msg("‚úÖ Using stored Price to Beat from database")
				}
			}
			
			// PRIORITY 2: If not in DB, capture current price and store it NOW
			if startPrice.IsZero() {
				// Get Chainlink price (what Polymarket uses for resolution!)
				if e.multiChainlink != nil {
					startPrice = e.multiChainlink.GetPrice(asset)
					priceSource = "Chainlink"
				}
				
				// Fallback to Binance
				if startPrice.IsZero() && e.binanceMulti != nil {
					startPrice = e.binanceMulti.GetPrice(asset)
					priceSource = "Binance"
				}
				
				// Store in database for persistence
				if !startPrice.IsZero() && e.db != nil && w.Slug != "" {
					wp := &database.WindowPrice{
						WindowSlug:  w.Slug,
						Asset:       asset,
						PriceToBeat: startPrice,
						Source:      priceSource,
						WindowStart: w.StartDate,
						CapturedAt:  time.Now(),
					}
					if err := e.db.SaveWindowPrice(wp); err != nil {
						log.Warn().Err(err).Str("slug", w.Slug).Msg("Failed to save window price to DB")
					} else {
						log.Info().
							Str("asset", asset).
							Str("slug", w.Slug).
							Str("price_to_beat", startPrice.StringFixed(2)).
							Str("source", priceSource).
							Msg("üíæ Stored Price to Beat in database")
					}
				}
			}
			
			// CAPTURE POLYMARKET ODDS AT WINDOW START
			var startUpOdds, startDownOdds decimal.Decimal
			
			// Try WebSocket first (real-time)
			if e.wsClient != nil && e.wsClient.IsConnected() && w.YesTokenID != "" {
				upPrice, downPrice, ok := e.wsClient.GetMarketPrices(w.YesTokenID, w.NoTokenID)
				if ok && !upPrice.IsZero() {
					startUpOdds = upPrice
					startDownOdds = downPrice
				}
			}
			
			// Fallback to window's current odds from scanner
			if startUpOdds.IsZero() {
				startUpOdds = w.YesPrice
				startDownOdds = w.NoPrice
			}
			
			// Skip if we still don't have a start price
			if startPrice.IsZero() {
				log.Warn().
					Str("asset", asset).
					Str("window", truncate(w.Question, 40)).
					Msg("‚ö†Ô∏è Could not determine start price - skipping window")
				continue
			}
			
			e.windowStates[w.ID] = &WindowState{
				Window:        w,
				StartPrice:    startPrice,
				StartUpOdds:   startUpOdds,    // Polymarket odds at window start!
				StartDownOdds: startDownOdds,  // Polymarket odds at window start!
				StartTime:     w.StartDate,
			}
			
			if e.windowStates[w.ID].StartTime.IsZero() {
				e.windowStates[w.ID].StartTime = time.Now()
			}
			
			log.Info().
				Str("window", truncate(w.Question, 50)).
				Str("price_to_beat", startPrice.StringFixed(2)).
				Str("start_up_odds", startUpOdds.StringFixed(3)).
				Str("start_down_odds", startDownOdds.StringFixed(3)).
				Str("source", priceSource).
				Str("start_time", e.windowStates[w.ID].StartTime.Format("15:04:05")).
				Msg("üìä Window tracked")
		}
	}

	// Clean up expired windows
	activeIDs := make(map[string]bool)
	for _, w := range windows {
		activeIDs[w.ID] = true
	}
	for id := range e.windowStates {
		if !activeIDs[id] {
			delete(e.windowStates, id)
		}
	}
}

// refreshOdds fetches latest odds for all tracked windows
// Priority: 1) WebSocket (real-time), 2) CLOB API, 3) Scanner cache
func (e *Engine) refreshOdds() {
	e.windowsMu.Lock()
	defer e.windowsMu.Unlock()

	for _, state := range e.windowStates {
		// PRIORITY 1: WebSocket for real-time odds (sub-100ms updates!)
		if e.wsClient != nil && e.wsClient.IsConnected() && state.Window.YesTokenID != "" {
			upPrice, downPrice, ok := e.wsClient.GetMarketPrices(state.Window.YesTokenID, state.Window.NoTokenID)
			if ok && !upPrice.IsZero() {
				state.CurrentUpOdds = upPrice
				state.CurrentDownOdds = downPrice
				state.LastOddsCheck = time.Now()
				continue
			}
		}
		
		// PRIORITY 2: CLOB API direct fetch
		if e.clobClient != nil && state.Window.YesTokenID != "" {
			// Fetch Yes token price directly from CLOB
			yesPrice, err := e.clobClient.GetMidPrice(state.Window.YesTokenID)
			if err == nil && !yesPrice.IsZero() {
				state.CurrentUpOdds = yesPrice
				state.CurrentDownOdds = decimal.NewFromInt(1).Sub(yesPrice)
				state.LastOddsCheck = time.Now()
				continue
			}
		}
		
		// PRIORITY 3: Scanner cache (HTTP polling)
		freshWindow := e.windowScanner.GetWindowByID(state.Window.ID)
		if freshWindow != nil {
			state.CurrentUpOdds = freshWindow.YesPrice
			state.CurrentDownOdds = freshWindow.NoPrice
			state.LastOddsCheck = time.Now()
		}
	}
}

// checkOpportunities scans for arbitrage opportunities
func (e *Engine) checkOpportunities() {
	// ‚ö° PRIORITY ORDER for current price:
	// 1. CMC - Updates every 1s, same source as Polymarket Data Streams (~$1 diff)
	// 2. Chainlink on-chain - Updates every 20-60s, ~$1 diff from Data Streams (BTC only)
	// 3. Binance - Fast but ~$80 diff from Data Streams (direction mismatch!)
	var currentPrice decimal.Decimal
	asset := e.GetAsset()
	
	// Try CMC first (fastest + most accurate) - works for BTC, ETH, SOL
	if e.cmcClient != nil && !e.cmcClient.IsAssetStale(asset) {
		currentPrice = e.cmcClient.GetAssetPrice(asset)
	}
	// Fallback to Chainlink on-chain (BTC only)
	if currentPrice.IsZero() && e.chainlinkClient != nil && asset == "BTC" {
		currentPrice = e.chainlinkClient.GetCurrentPrice()
	}
	// Last resort: Binance (BTC only, less accurate)
	if currentPrice.IsZero() && asset == "BTC" {
		currentPrice = e.binanceClient.GetCurrentPrice()
	}
	if currentPrice.IsZero() {
		return
	}

	// Reset daily stats if new day
	if time.Since(e.lastDailyReset) > 24*time.Hour {
		e.dailyPL = decimal.Zero
		e.lastDailyReset = time.Now()
	}

	e.windowsMu.RLock()
	states := make([]*WindowState, 0, len(e.windowStates))
	for _, s := range e.windowStates {
		states = append(states, s)
	}
	e.windowsMu.RUnlock()

	for _, state := range states {
		opp := e.analyzeWindow(state, currentPrice)
		if opp != nil {
			e.handleOpportunity(*opp, state)
		}
	}
}

// analyzeWindow checks if a window has a profitable opportunity
func (e *Engine) analyzeWindow(state *WindowState, currentPrice decimal.Decimal) *Opportunity {
	if state.StartPrice.IsZero() {
		return nil
	}

	// Calculate price change from window start
	priceChange := currentPrice.Sub(state.StartPrice)
	priceChangePct := priceChange.Div(state.StartPrice)

	// Check if move is significant enough
	absChangePct := priceChangePct.Abs()
	if absChangePct.LessThan(e.minPriceMove) {
		return nil // Move too small, no opportunity
	}
	
	// üß† PARALLEL MOMENTUM VALIDATION
	// Check if multiple sources agree on direction (reduces false signals)
	asset := e.GetAsset()
	var cmcPrice, chainlinkPrice decimal.Decimal
	if e.cmcClient != nil {
		cmcPrice = e.cmcClient.GetAssetPrice(asset)
	}
	if e.multiChainlink != nil {
		chainlinkPrice = e.multiChainlink.GetPrice(asset)
	}
	
	// Both sources must show same direction as our signal
	if !cmcPrice.IsZero() && !chainlinkPrice.IsZero() {
		cmcDirection := cmcPrice.Sub(state.StartPrice).Sign()
		chainlinkDirection := chainlinkPrice.Sub(state.StartPrice).Sign()
		ourDirection := priceChange.Sign()
		
		// If CMC and Chainlink disagree, skip (noise/lag, not real move)
		if cmcDirection != chainlinkDirection {
			log.Debug().
				Str("cmc_dir", directionStr(cmcDirection)).
				Str("chainlink_dir", directionStr(chainlinkDirection)).
				Msg("‚è≠Ô∏è Sources disagree - skipping noisy signal")
			return nil
		}
		
		// If our signal doesn't match confirmed direction, skip
		if cmcDirection != ourDirection {
			log.Debug().
				Str("signal_dir", directionStr(ourDirection)).
				Str("confirmed_dir", directionStr(cmcDirection)).
				Msg("‚è≠Ô∏è Signal doesn't match confirmed momentum")
			return nil
		}
	}

	// Determine direction we'd bet on
	var direction string
	var marketOdds decimal.Decimal

	if priceChangePct.IsPositive() {
		direction = "UP"
		marketOdds = state.CurrentUpOdds
	} else {
		direction = "DOWN"
		marketOdds = state.CurrentDownOdds
	}

	// Check if odds are stale (still cheap despite the move)
	// Entry range: 35¬¢-65¬¢ (with new Polymarket fees, wider range is better)
	if marketOdds.GreaterThan(e.maxOddsForEntry) {
		log.Debug().
			Str("odds", marketOdds.String()).
			Str("max", e.maxOddsForEntry.String()).
			Msg("‚è≠Ô∏è Odds too high - market already adjusted")
		return nil // Too expensive - market has already adjusted
	}
	if marketOdds.LessThan(e.minOddsForEntry) {
		log.Debug().
			Str("odds", marketOdds.String()).
			Str("min", e.minOddsForEntry.String()).
			Msg("‚è≠Ô∏è Odds too low - skipping")
		return nil // Too cheap - something is wrong or too risky
	}

	// Calculate fair odds based on historical data
	// With a significant move in one direction, the probability shifts
	fairOdds := e.calculateFairOdds(absChangePct)

	// Calculate edge: what we expect to win - what we pay
	// If fair odds are 0.80 and we pay 0.50, edge = 0.80 - 0.50 = 0.30 (30%)
	edge := fairOdds.Sub(marketOdds)

	if edge.LessThan(e.minEdge) {
		log.Debug().
			Str("edge", edge.Mul(decimal.NewFromInt(100)).String()+"%").
			Str("min_edge", e.minEdge.Mul(decimal.NewFromInt(100)).String()+"%").
			Msg("‚è≠Ô∏è Edge too small")
		return nil // Not enough edge
	}

	// üöÄ OPPORTUNITY FOUND! Log at Debug level to avoid spam
	log.Debug().
		Str("direction", direction).
		Str("btc_move", absChangePct.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
		Str("odds", marketOdds.String()).
		Str("edge", edge.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
		Msg("üéØ OPPORTUNITY DETECTED!")

	// Calculate confidence based on move size and time remaining
	confidence := e.calculateConfidence(absChangePct, state.Window.EndDate)

	return &Opportunity{
		Window:         state.Window,
		Direction:      direction,
		CurrentBTC:     currentPrice,
		StartBTC:       state.StartPrice,
		PriceChangePct: priceChangePct.Mul(decimal.NewFromInt(100)),
		MarketOdds:     marketOdds,
		FairOdds:       fairOdds,
		Edge:           edge,
		Confidence:     confidence,
		DetectedAt:     time.Now(),
	}
}

// calculateFairOdds estimates true probability based on price move
func (e *Engine) calculateFairOdds(absChangePct decimal.Decimal) decimal.Decimal {
	// Based on historical data from PurpleThunder's ~85% accuracy:
	// - 0.2% move ‚Üí ~65% probability of continuing
	// - 0.5% move ‚Üí ~80% probability of continuing
	// - 1.0% move ‚Üí ~90% probability of continuing
	//
	// Using a simple model: P = 0.5 + (move% * 80)
	// Capped at 0.95

	movePct, _ := absChangePct.Float64()
	fairProb := 0.50 + (movePct * 80) // 0.2% move ‚Üí 0.50 + 0.16 = 0.66

	if fairProb > 0.95 {
		fairProb = 0.95
	}

	return decimal.NewFromFloat(fairProb)
}

// calculateConfidence determines how confident we are in the opportunity
func (e *Engine) calculateConfidence(absChangePct decimal.Decimal, endTime time.Time) float64 {
	// Higher confidence with:
	// 1. Larger price moves
	// 2. More time remaining in window

	movePct, _ := absChangePct.Float64()
	moveScore := movePct * 200 // 0.5% move = 1.0 score

	timeRemaining := time.Until(endTime)
	timeScore := 0.5
	if timeRemaining > 10*time.Minute {
		timeScore = 0.3 // More time = less certain (could reverse)
	} else if timeRemaining > 5*time.Minute {
		timeScore = 0.5
	} else if timeRemaining > 2*time.Minute {
		timeScore = 0.7 // Sweet spot
	} else {
		timeScore = 0.9 // Very little time for reversal
	}

	confidence := (moveScore + timeScore) / 2
	if confidence > 1.0 {
		confidence = 1.0
	}

	return confidence
}

// handleOpportunity processes a detected opportunity
func (e *Engine) handleOpportunity(opp Opportunity, state *WindowState) {
	// Fire callback for alerts (always)
	if e.onOpportunity != nil {
		e.onOpportunity(opp)
	}

	// Check if we should trade
	if !e.shouldTrade(state) {
		return
	}

	// Execute trade
	trade := e.executeTrade(opp, state)
	if trade != nil {
		// Update state
		e.windowsMu.Lock()
		state.TradesThisWindow++
		state.LastTradeTime = time.Now()
		e.windowsMu.Unlock()

		// Fire callback
		if e.onTrade != nil {
			e.onTrade(*trade)
		}
	}
}

// shouldTrade determines if we should execute a trade
func (e *Engine) shouldTrade(state *WindowState) bool {
	// ‚õî ENGINE TRADING DISABLED - Only ScalperStrategy should trade!
	// The old arbitrage engine logic loses money - use Scalper instead
	log.Debug().Msg("‚õî Engine trading DISABLED - Scalper handles trades")
	return false

	// Check if in dry run mode
	if e.cfg.DryRun {
		log.Debug().Msg("‚ùå Trade blocked: DRY_RUN=true")
		return false
	}

	// Check if arbitrage is enabled
	if !e.cfg.ArbEnabled {
		log.Debug().Msg("‚ùå Trade blocked: ARB_ENABLED=false")
		return false
	}

	// Check daily trade limit
	if e.totalTrades >= e.maxDailyTrades {
		log.Debug().
			Int("total", e.totalTrades).
			Int("max", e.maxDailyTrades).
			Msg("‚ùå Trade blocked: daily limit reached")
		return false
	}

	// Check per-window limit
	if state.TradesThisWindow >= e.maxTradesPerWindow {
		log.Debug().
			Int("trades", state.TradesThisWindow).
			Int("max", e.maxTradesPerWindow).
			Msg("‚ùå Trade blocked: per-window limit")
		return false
	}

	// Check cooldown
	timeSince := time.Since(state.LastTradeTime)
	cooldown := time.Duration(e.cooldownSeconds) * time.Second
	if timeSince < cooldown {
		log.Debug().
			Dur("since", timeSince).
			Dur("cooldown", cooldown).
			Msg("‚ùå Trade blocked: cooldown active")
		return false
	}

	log.Info().
		Str("asset", e.GetAsset()).
		Int("daily_trades", e.totalTrades).
		Int("window_trades", state.TradesThisWindow).
		Msg("‚úÖ Trade checks passed - proceeding to execute")

	return true
}

// executeTrade executes an arbitrage trade
func (e *Engine) executeTrade(opp Opportunity, state *WindowState) *Trade {
	// Determine which token to buy (YES=Up, NO=Down)
	var tokenID string
	if opp.Direction == "UP" {
		tokenID = opp.Window.YesTokenID
	} else {
		tokenID = opp.Window.NoTokenID
	}

	// Check if tokenID is empty
	if tokenID == "" {
		log.Error().
			Str("direction", opp.Direction).
			Str("yes_token", opp.Window.YesTokenID).
			Str("no_token", opp.Window.NoTokenID).
			Str("window", opp.Window.Question).
			Msg("‚ùå Token ID is empty - cannot trade")
		return nil
	}

	// Safety check for zero odds
	if opp.MarketOdds.IsZero() || opp.MarketOdds.LessThanOrEqual(decimal.Zero) {
		log.Error().Msg("Cannot execute trade: MarketOdds is zero")
		return nil
	}

	// üöÄ DYNAMIC POSITION SIZING - Trade bigger when more confident!
	// Based on BTC move size:
	//   >0.3% move ‚Üí 3x base (high confidence)
	//   0.2-0.3%   ‚Üí 2x base (medium confidence)
	//   0.1-0.2%   ‚Üí 1x base (low confidence)
	tradeAmount := e.positionSize
	moveAbs := opp.PriceChangePct.Abs() // Already in % form (e.g., 0.25 = 0.25%)
	sizeMultiplier := "1x"
	
	if e.dynamicSizingEnabled {
		if moveAbs.GreaterThanOrEqual(decimal.NewFromFloat(0.3)) {
			// Large move (>0.3%) ‚Üí 3x
			tradeAmount = e.positionSize.Mul(e.largeMoveMultiplier)
			sizeMultiplier = "3x"
		} else if moveAbs.GreaterThanOrEqual(decimal.NewFromFloat(0.2)) {
			// Medium move (0.2-0.3%) ‚Üí 2x
			tradeAmount = e.positionSize.Mul(e.mediumMoveMultiplier)
			sizeMultiplier = "2x"
		} else {
			// Small move (0.1-0.2%) ‚Üí 1x
			tradeAmount = e.positionSize.Mul(e.smallMoveMultiplier)
			sizeMultiplier = "1x"
		}
	}

	// Calculate size: $amount / price = shares
	// E.g., $3 / 0.45 = 6.67 shares
	shares := tradeAmount.Div(opp.MarketOdds).Round(2)

	trade := &Trade{
		ID:             fmt.Sprintf("arb_%d", time.Now().UnixNano()),
		WindowID:       opp.Window.ID,
		Question:       opp.Window.Question,
		Direction:      opp.Direction,
		TokenID:        tokenID,
		EntryPrice:     opp.MarketOdds,
		Amount:         tradeAmount,
		Shares:         shares,
		BTCAtEntry:     opp.CurrentBTC,
		BTCAtStart:     opp.StartBTC,
		PriceChangePct: opp.PriceChangePct,
		Edge:           opp.Edge,
		Status:         "open",
		EnteredAt:      time.Now(),
	}

	log.Info().
		Str("direction", trade.Direction).
		Str("entry_price", trade.EntryPrice.String()).
		Str("amount", trade.Amount.String()).
		Str("sizing", sizeMultiplier).
		Str("shares", shares.String()).
		Str("btc_move", trade.PriceChangePct.String()+"%").
		Str("edge", trade.Edge.Mul(decimal.NewFromInt(100)).String()+"%").
		Str("window", truncate(trade.Question, 40)).
		Bool("live", !e.cfg.DryRun).
		Msg("‚ö° ARBITRAGE TRADE EXECUTING...")

	// ‚ö° Execute actual trade if CLOB client is available
	// Use PlaceMarketBuyAtPrice to avoid redundant odds fetch (SPEED CRITICAL!)
	if e.clobClient != nil && tokenID != "" {
		startOrder := time.Now()
		orderResp, err := e.clobClient.PlaceMarketBuyAtPrice(tokenID, shares, opp.MarketOdds)
		orderTime := time.Since(startOrder)
		
		if err != nil {
			log.Error().
				Err(err).
				Str("token", tokenID).
				Str("shares", shares.String()).
				Dur("order_time_ms", orderTime).
				Msg("‚ùå Order placement failed")
			trade.Status = "failed"
			return nil
		}

		log.Info().
			Str("order_id", orderResp.OrderID).
			Str("status", orderResp.Status).
			Dur("order_time_ms", orderTime).
			Msg("‚úÖ Order filled")
		trade.ID = orderResp.OrderID
		trade.Status = "filled"
	} else if e.clobClient == nil {
		log.Warn().Msg("‚ö†Ô∏è CLOB client not connected - trade simulated only")
		trade.Status = "simulated"
	} else {
		log.Warn().Str("direction", opp.Direction).Msg("‚ö†Ô∏è No token ID for direction - trade skipped")
		trade.Status = "skipped"
		return nil
	}

	// Track trade
	e.tradesMu.Lock()
	e.trades = append(e.trades, *trade)
	e.totalTrades++
	e.tradesMu.Unlock()

	// Add to open positions for exit monitoring (dual exit strategy)
	if trade.Status == "filled" || trade.Status == "simulated" {
		e.positionsMu.Lock()
		e.openPositions[trade.ID] = &OpenPosition{
			Trade:          trade,
			TokenID:        tokenID,
			Direction:      opp.Direction,
			EntryPrice:     opp.MarketOdds,
			Shares:         shares,
			BTCMoveAtEntry: opp.PriceChangePct.Div(decimal.NewFromInt(100)), // Convert back to decimal
			WindowEndTime:  opp.Window.EndDate,
			EnteredAt:      time.Now(),
		}
		e.positionsMu.Unlock()

		log.Debug().
			Str("trade_id", trade.ID).
			Str("exit_target", e.exitOddsThreshold.String()).
			Msg("üìä Position tracked for exit monitoring")
	}

	return trade
}

// GetStats returns current arbitrage stats
func (e *Engine) GetStats() map[string]interface{} {
	e.tradesMu.RLock()
	defer e.tradesMu.RUnlock()

	winRate := 0.0
	if e.totalTrades > 0 {
		winRate = float64(e.wonTrades) / float64(e.totalTrades) * 100
	}

	return map[string]interface{}{
		"total_trades":   e.totalTrades,
		"won":            e.wonTrades,
		"lost":           e.lostTrades,
		"win_rate":       fmt.Sprintf("%.1f%%", winRate),
		"total_profit":   e.totalProfit.String(),
		"daily_pl":       e.dailyPL.String(),
		"active_windows": len(e.windowStates),
	}
}

// GetActiveOpportunities returns current opportunities (for debugging)
func (e *Engine) GetActiveOpportunities() []Opportunity {
	currentBTC := e.binanceClient.GetCurrentPrice()
	if currentBTC.IsZero() {
		return nil
	}

	e.windowsMu.RLock()
	defer e.windowsMu.RUnlock()

	opps := make([]Opportunity, 0)
	for _, state := range e.windowStates {
		opp := e.analyzeWindow(state, currentBTC)
		if opp != nil {
			opps = append(opps, *opp)
		}
	}

	return opps
}

// GetRecentTrades returns recent trades
func (e *Engine) GetRecentTrades(limit int) []Trade {
	e.tradesMu.RLock()
	defer e.tradesMu.RUnlock()

	if len(e.trades) <= limit {
		result := make([]Trade, len(e.trades))
		copy(result, e.trades)
		return result
	}

	start := len(e.trades) - limit
	result := make([]Trade, limit)
	copy(result, e.trades[start:])
	return result
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}

// directionStr converts sign to readable string
func directionStr(sign int) string {
	switch sign {
	case 1:
		return "UP"
	case -1:
		return "DOWN"
	default:
		return "FLAT"
	}
}


================================================================================
FILE: internal/arbitrage/sniper_strategy.go
================================================================================
package arbitrage

import (
	"fmt"
	"sync"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"

	"github.com/web3guy0/polybot/internal/dashboard"
	"github.com/web3guy0/polybot/internal/database"
	"github.com/web3guy0/polybot/internal/polymarket"
)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LAST MINUTE SNIPER STRATEGY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//
// Strategy: Buy the "almost certain" winner in the last 2-3 minutes
//
// Logic:
// 1. Wait until last 3 minutes of window
// 2. Check if price moved significantly (>0.2%) from price-to-beat
// 3. If yes, the direction is almost certain
// 4. Buy the winning side at 85-92¬¢ (cheap compared to $1 resolution)
// 5. Quick flip at 95¬¢+ OR hold to resolution
// 6. Tight stop-loss at 75¬¢ if sudden reversal
//
// Math:
// - Buy at 90¬¢, sell at 95¬¢ = 5¬¢ profit (5.5% return)
// - Buy at 90¬¢, resolution $1 = 10¬¢ profit (11% return)
// - Buy at 90¬¢, stop at 75¬¢ = -15¬¢ loss
// - Need 75%+ win rate to be profitable
//
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// SniperConfig holds configuration for the sniper strategy
type SniperConfig struct {
	// Entry conditions
	MinTimeRemainingMin float64         // Minimum time left (e.g., 1 min)
	MaxTimeRemainingMin float64         // Maximum time left (e.g., 3 min)
	MinPriceMovePct     decimal.Decimal // Min price move % (e.g., 0.05 = 0.05%)
	MinOddsEntry        decimal.Decimal // Min odds to buy (e.g., 0.79)
	MaxOddsEntry        decimal.Decimal // Max odds to buy (e.g., 0.90)

	// Exit conditions
	QuickFlipTarget    decimal.Decimal // Sell at this price (e.g., 0.99)
	StopLoss           decimal.Decimal // Cut loss at this price (e.g., 0.50)
	HoldToResolution   bool            // Hold to resolution instead of quick flip

	// Position sizing (% based)
	PositionSizePct decimal.Decimal // % of balance per trade (e.g., 0.10 = 10%)

	// Safety
	MaxTradesPerWindow int           // Max 1 trade per window
	CooldownDuration   time.Duration // Cooldown after trade
	
	// Per-Asset Price Movement (CRITICAL - varies by volatility)
	// BTC = 0.02% (stable), ETH = 0.04% (medium), SOL = 0.08% (volatile)
	AssetMinPriceMove map[string]decimal.Decimal
}

// GetAssetConfig returns config for specific asset
// Entry odds and stop loss are GLOBAL, only price movement varies per-asset
func (c *SniperConfig) GetAssetConfig(asset string) (minOdds, maxOdds, stopLoss, minPriceMove decimal.Decimal) {
	// Global settings
	minOdds = c.MinOddsEntry
	maxOdds = c.MaxOddsEntry
	stopLoss = c.StopLoss
	
	// Per-asset price movement (CRITICAL - based on volatility)
	// BTC = 0.02% (stable), ETH = 0.04% (medium), SOL = 0.08% (volatile)
	if c.AssetMinPriceMove != nil {
		if v, ok := c.AssetMinPriceMove[asset]; ok {
			minPriceMove = v
		} else {
			minPriceMove = c.MinPriceMovePct
		}
	} else {
		minPriceMove = c.MinPriceMovePct
	}
	
	return
}

// SniperPosition represents an active sniper position
type SniperPosition struct {
	TradeID      string
	Asset        string
	Side         string // "UP" or "DOWN"
	TokenID      string
	ConditionID  string
	WindowID     string
	EntryPrice   decimal.Decimal
	Size         decimal.Decimal // Actual shares filled (decimal for precision)
	EntryTime    time.Time
	StopLoss     decimal.Decimal
	Target       decimal.Decimal
	WindowEnd    time.Time
	PriceMovePct decimal.Decimal // Price move % at entry (to decide hold vs flip)
	HighPrice    decimal.Decimal // Highest price seen (for trailing stop)
	TrailingStop decimal.Decimal // Dynamic trailing stop level
}

// MomentumTracker tracks price velocity for fast detection
type MomentumTracker struct {
	LastPrice     decimal.Decimal
	LastTime      time.Time
	Velocity      decimal.Decimal // Price change per second
	Accelerating  bool            // Is price accelerating in one direction
}

// SniperStrategy implements the last-minute sniper trading strategy
type SniperStrategy struct {
	mu sync.RWMutex

	// Components
	windowScanner *polymarket.WindowScanner
	clobClient    *CLOBClient
	engine        *Engine
	db            *database.Database
	notifier      TradeNotifier
	dash          *dashboard.ResponsiveDash

	// Configuration
	config SniperConfig

	// State
	positions        map[string]*SniperPosition // windowID -> position
	windowTradeCount map[string]int             // windowID -> trade count
	lastTradeTime    time.Time
	running          bool
	stopCh           chan struct{}

	// Momentum tracking for fast detection
	momentum map[string]*MomentumTracker // asset -> momentum

	// Stats
	totalTrades   int
	winningTrades int
	totalProfit   decimal.Decimal
	cachedBalance decimal.Decimal
}

// NewSniperStrategy creates a new last-minute sniper strategy
func NewSniperStrategy(
	scanner *polymarket.WindowScanner,
	clobClient *CLOBClient,
	positionSizePct decimal.Decimal,
) *SniperStrategy {
	return &SniperStrategy{
		windowScanner:    scanner,
		clobClient:       clobClient,
		positions:        make(map[string]*SniperPosition),
		windowTradeCount: make(map[string]int),
		momentum:         make(map[string]*MomentumTracker), // Fast momentum detection
		totalProfit:      decimal.Zero,
		stopCh:           make(chan struct{}),
		config: SniperConfig{
			MinTimeRemainingMin: 1.0,                             // At least 1 min left
			MaxTimeRemainingMin: 3.0,                             // Max 3 min left (last 3 minutes)
			MinPriceMovePct:     decimal.NewFromFloat(0.05),      // 0.05% price move minimum
			MinOddsEntry:        decimal.NewFromFloat(0.79),      // Buy at 79¬¢ minimum (new default)
			MaxOddsEntry:        decimal.NewFromFloat(0.90),      // Buy at 90¬¢ maximum (new default)
			QuickFlipTarget:     decimal.NewFromFloat(0.99),      // Sell at 99¬¢ (near resolution)
			StopLoss:            decimal.NewFromFloat(0.50),      // Stop at 50¬¢ (wide SL)
			PositionSizePct:     positionSizePct,                 // % of balance per trade
			MaxTradesPerWindow:  1,                               // Only 1 trade per window
			CooldownDuration:    30 * time.Second,                // 30s cooldown
		},
	}
}

// SetEngine sets the arbitrage engine reference
func (s *SniperStrategy) SetEngine(engine *Engine) {
	s.engine = engine
}

// SetDatabase sets the database for trade logging
func (s *SniperStrategy) SetDatabase(db *database.Database) {
	s.db = db
	log.Info().Msg("üìä [SNIPER] Database connected")
}

// SetNotifier sets the notifier for alerts
func (s *SniperStrategy) SetNotifier(n TradeNotifier) {
	s.notifier = n
	log.Info().Msg("üì± [SNIPER] Notifier connected")
}

// SetConfig updates the sniper configuration from external config
func (s *SniperStrategy) SetConfig(
	minTimeMin, maxTimeMin float64,
	minPriceMove, minOdds, maxOdds, target, stopLoss decimal.Decimal,
	holdToResolution bool,
) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	s.config.MinTimeRemainingMin = minTimeMin
	s.config.MaxTimeRemainingMin = maxTimeMin
	s.config.MinPriceMovePct = minPriceMove.Div(decimal.NewFromInt(100)) // Convert 0.05 -> 0.0005
	s.config.MinOddsEntry = minOdds
	s.config.MaxOddsEntry = maxOdds
	s.config.QuickFlipTarget = target
	s.config.StopLoss = stopLoss
	s.config.HoldToResolution = holdToResolution
	
	log.Info().
		Float64("min_time_min", minTimeMin).
		Float64("max_time_min", maxTimeMin).
		Str("min_price_move", minPriceMove.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
		Str("min_odds", minOdds.StringFixed(2)).
		Str("max_odds", maxOdds.StringFixed(2)).
		Str("target", target.StringFixed(2)).
		Str("stop", stopLoss.StringFixed(2)).
		Bool("hold_to_resolution", holdToResolution).
		Msg("üéØ [SNIPER] Config updated from env")
}

// SetPerAssetPriceMove sets per-asset price movement thresholds (CRITICAL for volatility)
// BTC = 0.02% (stable, small moves are significant)
// ETH = 0.04% (medium volatility)
// SOL = 0.08% (volatile, needs bigger move to filter noise)
func (s *SniperStrategy) SetPerAssetPriceMove(
	btcMinPriceMove, ethMinPriceMove, solMinPriceMove decimal.Decimal,
) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	// Initialize price move map
	s.config.AssetMinPriceMove = make(map[string]decimal.Decimal)
	
	// Convert from env format (0.02) to decimal (0.0002)
	s.config.AssetMinPriceMove["BTC"] = btcMinPriceMove.Div(decimal.NewFromInt(100))
	s.config.AssetMinPriceMove["ETH"] = ethMinPriceMove.Div(decimal.NewFromInt(100))
	s.config.AssetMinPriceMove["SOL"] = solMinPriceMove.Div(decimal.NewFromInt(100))
	
	log.Info().
		Str("btc", fmt.Sprintf("%.2f%%", btcMinPriceMove.InexactFloat64())).
		Str("eth", fmt.Sprintf("%.2f%%", ethMinPriceMove.InexactFloat64())).
		Str("sol", fmt.Sprintf("%.2f%%", solMinPriceMove.InexactFloat64())).
		Msg("üéØ [SNIPER] Per-asset price thresholds (volatility-based)")
}

// SetDashboard sets the dashboard
func (s *SniperStrategy) SetDashboard(d *dashboard.ResponsiveDash) {
	s.dash = d
	log.Info().Msg("üì∫ [SNIPER] Dashboard connected")
}

// Start begins the sniper strategy loop
func (s *SniperStrategy) Start() {
	s.mu.Lock()
	if s.running {
		s.mu.Unlock()
		return
	}
	s.running = true
	s.mu.Unlock()

	go s.mainLoop()
	go s.positionMonitorLoop()

	// Print ULTRA-SAFE v2.0 banner
	log.Info().Msg("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	log.Info().Msg("üéØ SNIPER v2.0 - ULTRA-SAFE MODE")
	log.Info().Msg("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	log.Info().Msg("")
	log.Info().Msgf("  Time Window:  %.0f-%.0f seconds before resolution", 
		s.config.MinTimeRemainingMin*60, s.config.MaxTimeRemainingMin*60)
	log.Info().Msgf("  Entry Range:  %s¬¢-%s¬¢ (high confidence only)",
		s.config.MinOddsEntry.Mul(decimal.NewFromInt(100)).StringFixed(0),
		s.config.MaxOddsEntry.Mul(decimal.NewFromInt(100)).StringFixed(0))
	log.Info().Msgf("  Stop Loss:    %s¬¢ (tight SL, small losses)",
		s.config.StopLoss.Mul(decimal.NewFromInt(100)).StringFixed(0))
	log.Info().Msgf("  Hold Mode:    %v (wait for $1 resolution)", s.config.HoldToResolution)
	log.Info().Msg("")
	log.Info().Msg("  ‚úÖ Reversal Protection: ENABLED")
	log.Info().Msg("  ‚úÖ Momentum Confirmation: ENABLED")
	log.Info().Msg("  ‚úÖ Trailing Stop: ENABLED")
	log.Info().Msg("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
}

// Stop stops the sniper strategy
func (s *SniperStrategy) Stop() {
	s.mu.Lock()
	defer s.mu.Unlock()

	if !s.running {
		return
	}

	s.running = false
	close(s.stopCh)
	log.Info().Msg("üõë [SNIPER] Strategy stopped")
}

// mainLoop is the main scanning loop
func (s *SniperStrategy) mainLoop() {
	ticker := time.NewTicker(200 * time.Millisecond) // Fast scanning for opportunities
	defer ticker.Stop()

	for {
		select {
		case <-s.stopCh:
			return
		case <-ticker.C:
			s.scanForOpportunities()
		}
	}
}

// scanForOpportunities looks for sniper opportunities
func (s *SniperStrategy) scanForOpportunities() {
	windows := s.windowScanner.GetActiveWindows()

	for i := range windows {
		s.evaluateWindow(&windows[i])
	}

	// Update dashboard stats
	s.dashUpdateStats()
}

// updateMomentum updates momentum tracking for an asset and returns velocity info
// Returns: velocity (price change per second), isAccelerating, isReady
func (s *SniperStrategy) updateMomentum(asset string, currentPrice decimal.Decimal) (velocity decimal.Decimal, accelerating bool, ready bool) {
	s.mu.Lock()
	defer s.mu.Unlock()

	now := time.Now()

	tracker, exists := s.momentum[asset]
	if !exists || time.Since(tracker.LastTime) > 30*time.Second {
		// New tracker or stale data - initialize
		s.momentum[asset] = &MomentumTracker{
			LastPrice: currentPrice,
			LastTime:  now,
			Velocity:  decimal.Zero,
		}
		return decimal.Zero, false, false
	}

	// Calculate velocity (price change per second)
	elapsed := now.Sub(tracker.LastTime).Seconds()
	if elapsed < 0.1 {
		// Too soon, use cached values
		return tracker.Velocity, tracker.Accelerating, true
	}

	priceChange := currentPrice.Sub(tracker.LastPrice)
	newVelocity := priceChange.Div(decimal.NewFromFloat(elapsed))

	// Check if accelerating (velocity magnitude increasing)
	oldVelAbs := tracker.Velocity.Abs()
	newVelAbs := newVelocity.Abs()
	isAccelerating := newVelAbs.GreaterThan(oldVelAbs)

	// Update tracker
	tracker.LastPrice = currentPrice
	tracker.LastTime = now
	tracker.Velocity = newVelocity
	tracker.Accelerating = isAccelerating

	return newVelocity, isAccelerating, true
}

// evaluateWindow checks if a window is ready for sniping
func (s *SniperStrategy) evaluateWindow(w *polymarket.PredictionWindow) {
	asset := w.Asset
	if asset == "" {
		asset = "BTC"
	}

	// Skip if we already have a position in this window
	s.mu.RLock()
	if _, exists := s.positions[w.ID]; exists {
		s.mu.RUnlock()
		return
	}

	// Check trade count for this window
	if s.windowTradeCount[w.ID] >= s.config.MaxTradesPerWindow {
		s.mu.RUnlock()
		return
	}

	// Check cooldown
	if time.Since(s.lastTradeTime) < s.config.CooldownDuration {
		s.mu.RUnlock()
		return
	}
	s.mu.RUnlock()

	// Calculate time remaining
	timeRemaining := time.Until(w.EndDate)
	timeRemainingMin := timeRemaining.Minutes()

	// Always update dashboard with time remaining (even if we're not in sniper window yet)
	if s.dash != nil && timeRemaining > 0 {
		s.dash.UpdateMarketTime(asset, timeRemaining)
	}

	// Check if we're in the sniper window (last 1-3 minutes)
	if timeRemainingMin > s.config.MaxTimeRemainingMin {
		// Too early, wait - but still update market data for display
		s.updateMarketDataOnly(w, asset)
		return
	}
	if timeRemainingMin < s.config.MinTimeRemainingMin {
		// Too late, skip
		return
	}

	// Get price data
	var priceToBeat, currentPrice decimal.Decimal

	if !w.PriceToBeat.IsZero() {
		priceToBeat = w.PriceToBeat
	} else if s.engine != nil {
		if state := s.engine.GetWindowState(w.ID); state != nil {
			priceToBeat = state.StartPrice
		}
	}

	if s.engine != nil {
		currentPrice = s.engine.GetCurrentPrice()
	}

	if priceToBeat.IsZero() || currentPrice.IsZero() {
		return
	}

	// üöÄ MOMENTUM TRACKING - rocket speed detection
	velocity, _, momentumReady := s.updateMomentum(asset, currentPrice)
	
	// Calculate price move
	priceMove := currentPrice.Sub(priceToBeat)
	priceMovePct := priceMove.Div(priceToBeat).Abs()

	// Get per-asset min price move (BTC/ETH: 0.10%, SOL: 0.15%)
	_, _, _, minPriceMove := s.config.GetAssetConfig(asset)
	
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	// ULTRA-SAFE v2.0: REVERSAL PROTECTION
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	// Check momentum direction - if price is REVERSING, don't enter!
	// This prevents buying at 94¬¢ just before price flips and goes to 0¬¢
	
	priceWentUp := currentPrice.GreaterThan(priceToBeat)
	
	// Velocity tells us CURRENT direction of price movement
	// If price went UP but velocity is NEGATIVE = price is falling back = DANGER
	// If price went DOWN but velocity is POSITIVE = price is rising back = DANGER
	if momentumReady {
		velocityPositive := velocity.GreaterThan(decimal.Zero)
		
		// REVERSAL CHECK: momentum must MATCH predicted direction
		if priceWentUp && !velocityPositive && velocity.Abs().GreaterThan(decimal.NewFromFloat(0.20)) {
			log.Info().
				Str("asset", asset).
				Str("direction", "UP").
				Str("velocity", velocity.StringFixed(2)+"$/sec (FALLING!)").
				Msg("‚ö†Ô∏è [SNIPER] REVERSAL DETECTED - price was UP but now falling, SKIPPING")
			return
		}
		if !priceWentUp && velocityPositive && velocity.Abs().GreaterThan(decimal.NewFromFloat(0.20)) {
			log.Info().
				Str("asset", asset).
				Str("direction", "DOWN").
				Str("velocity", velocity.StringFixed(2)+"$/sec (RISING!)").
				Msg("‚ö†Ô∏è [SNIPER] REVERSAL DETECTED - price was DOWN but now rising, SKIPPING")
			return
		}
		
		// MOMENTUM CONFIRMATION: velocity should support direction
		if priceWentUp && velocityPositive && velocity.GreaterThan(decimal.NewFromFloat(0.30)) {
			log.Info().
				Str("asset", asset).
				Str("velocity", velocity.StringFixed(2)+"$/sec").
				Msg("‚úÖ [SNIPER] Strong UP momentum confirmed")
		}
		if !priceWentUp && !velocityPositive && velocity.Abs().GreaterThan(decimal.NewFromFloat(0.30)) {
			log.Info().
				Str("asset", asset).
				Str("velocity", velocity.StringFixed(2)+"$/sec").
				Msg("‚úÖ [SNIPER] Strong DOWN momentum confirmed")
		}
	}
	
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	// PRICE MOVE CHECK (no momentum reduction - we want STRONG signals only)
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	if priceMovePct.LessThan(minPriceMove) {
		log.Debug().
			Str("asset", asset).
			Str("move", priceMovePct.Mul(decimal.NewFromInt(100)).StringFixed(3)+"%").
			Str("need", minPriceMove.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
			Str("velocity", velocity.StringFixed(2)+"$/sec").
			Msg("üéØ [SNIPER] Price move too small")
		return
	}

	// Get current odds
	upOdds := w.YesPrice
	downOdds := w.NoPrice

	// Update dashboard with market data and time remaining
	if s.dash != nil {
		s.dash.UpdateMarket(asset, currentPrice, priceToBeat, upOdds, downOdds)
		s.dash.UpdateMarketTime(asset, timeRemaining)
	}

	// Find the winning side
	var winningSide string
	var winningOdds decimal.Decimal
	var tokenID string

	if priceWentUp {
		// Price went UP, so UP should win
		winningSide = "UP"
		winningOdds = upOdds
		tokenID = w.YesTokenID
	} else {
		// Price went DOWN, so DOWN should win
		winningSide = "DOWN"
		winningOdds = downOdds
		tokenID = w.NoTokenID
	}

	// Check if odds are in our sniper range (per-asset or global)
	minOdds, maxOdds, assetStopLoss, _ := s.config.GetAssetConfig(asset)
	
	if winningOdds.LessThan(minOdds) {
		log.Debug().
			Str("asset", asset).
			Str("side", winningSide).
			Str("odds", winningOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("min", minOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Msg("üéØ [SNIPER] Odds too low - waiting for entry")
		return
	}

	if winningOdds.GreaterThan(maxOdds) {
		log.Debug().
			Str("asset", asset).
			Str("side", winningSide).
			Str("odds", winningOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("max", maxOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Msg("üéØ [SNIPER] Odds too high - not worth the risk")
		return
	}

	// üéØ SNIPER OPPORTUNITY FOUND!
	log.Info().
		Str("asset", asset).
		Str("side", winningSide).
		Str("odds", winningOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("range", fmt.Sprintf("%.0f¬¢-%.0f¬¢", minOdds.Mul(decimal.NewFromInt(100)).InexactFloat64(), maxOdds.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Str("sl", assetStopLoss.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("price_move", priceMovePct.Mul(decimal.NewFromInt(100)).StringFixed(3)+"%").
		Float64("time_remaining_min", timeRemainingMin).
		Bool("price_went_up", priceWentUp).
		Msg("üéØüéØüéØ [SNIPER] OPPORTUNITY DETECTED!")

	// Log to dashboard
	if s.dash != nil {
		s.dash.AddSignal(asset, winningSide, "üéØ SNIPE", winningOdds,
			fmt.Sprintf("Last %.1fmin, move %.2f%%", timeRemainingMin, priceMovePct.Mul(decimal.NewFromInt(100)).InexactFloat64()),
			0.90) // High confidence
	}

	// Execute the snipe!
	s.executeSnipe(w, winningSide, winningOdds, tokenID, timeRemaining, priceMovePct)
}

// executeSnipe executes a sniper trade
func (s *SniperStrategy) executeSnipe(w *polymarket.PredictionWindow, side string, odds decimal.Decimal, tokenID string, timeRemaining time.Duration, priceMovePct decimal.Decimal) {
	asset := w.Asset
	if asset == "" {
		asset = "BTC"
	}

	// Get per-asset stop loss
	_, _, assetStopLoss, _ := s.config.GetAssetConfig(asset)

	// Calculate position size using % of balance
	tickSize := decimal.NewFromFloat(0.01)
	roundedPrice := odds.Div(tickSize).Floor().Mul(tickSize)

	// Query current balance and use % of it
	var positionUSD decimal.Decimal
	if s.clobClient != nil {
		balance, err := s.clobClient.GetBalance()
		if err != nil {
			log.Error().Err(err).Msg("üéØ [SNIPER] Failed to get balance")
			return
		}
		positionUSD = balance.Mul(s.config.PositionSizePct) // e.g., 10% of balance
		log.Info().
			Str("balance", "$"+balance.StringFixed(2)).
			Str("pct", s.config.PositionSizePct.Mul(decimal.NewFromInt(100)).StringFixed(0)+"%").
			Str("position_usd", "$"+positionUSD.StringFixed(2)).
			Msg("üéØ [SNIPER] Position sizing")
	} else {
		// Paper trading fallback
		positionUSD = decimal.NewFromFloat(10.0)
	}

	// Calculate shares - keep 2 decimal places for precision
	size := positionUSD.Div(roundedPrice).Round(2)
	minSize := decimal.NewFromInt(5) // Polymarket minimum
	if size.LessThan(minSize) {
		size = minSize
	}

	actualCost := roundedPrice.Mul(size)
	potentialProfit := s.config.QuickFlipTarget.Sub(roundedPrice).Mul(size)
	maxLoss := roundedPrice.Sub(assetStopLoss).Mul(size)

	log.Info().
		Str("asset", asset).
		Str("side", side).
		Str("entry", roundedPrice.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("target", s.config.QuickFlipTarget.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("stop", assetStopLoss.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("shares", size.StringFixed(2)).
		Str("cost", "$"+actualCost.StringFixed(2)).
		Str("potential_profit", "+$"+potentialProfit.StringFixed(2)).
		Str("max_loss", "-$"+maxLoss.StringFixed(2)).
		Msg("üéØ [SNIPER] EXECUTING SNIPE!")

	// Create position with per-asset stop loss and trailing stop
	pos := &SniperPosition{
		TradeID:      fmt.Sprintf("snipe-%s-%d", asset, time.Now().UnixNano()),
		Asset:        asset,
		Side:         side,
		TokenID:      tokenID,
		ConditionID:  w.ConditionID,
		WindowID:     w.ID,
		EntryPrice:   roundedPrice,
		Size:         size, // Will be updated with actual filled size
		EntryTime:    time.Now(),
		StopLoss:     assetStopLoss, // Use per-asset stop loss
		Target:       s.config.QuickFlipTarget,
		WindowEnd:    w.EndDate,
		PriceMovePct: priceMovePct, // Track price move to decide hold vs flip
		HighPrice:    roundedPrice, // Initialize high price to entry
		TrailingStop: assetStopLoss, // Start trailing stop at base SL
	}

	// Place the order
	if s.clobClient == nil {
		log.Warn().Msg("üéØ [SNIPER] No CLOB client - paper trade only")
		s.recordPosition(pos)
		return
	}

	// Use limit order for fill
	slippage := decimal.NewFromFloat(0.02) // 2¬¢ slippage allowed
	orderPrice := roundedPrice.Add(slippage)

	orderID, err := s.clobClient.PlaceLimitOrder(
		tokenID,
		orderPrice,
		size, // Use decimal size directly
		"BUY",
	)

	if err != nil {
		log.Error().Err(err).Str("asset", asset).Msg("üéØ [SNIPER] Order failed!")
		if s.dash != nil {
			s.dash.AddLog(fmt.Sprintf("‚ùå SNIPE FAILED: %s %s - %v", asset, side, err))
		}
		return
	}

	// Query actual filled size after a brief delay
	time.Sleep(500 * time.Millisecond)
	_, filledSize, _, statusErr := s.clobClient.GetOrderStatus(orderID)
	if statusErr == nil && filledSize.GreaterThan(decimal.Zero) {
		pos.Size = filledSize // Use ACTUAL filled size
		log.Info().
			Str("order_id", orderID).
			Str("filled", filledSize.StringFixed(2)).
			Msg("üéØ [SNIPER] Actual fill recorded")
	}

	pos.TradeID = orderID
	s.recordPosition(pos)

	// Notify
	if s.notifier != nil {
		s.notifier.SendTradeAlert(asset, side, roundedPrice, pos.Size.IntPart(), "SNIPE BUY", decimal.Zero)
	}

	if s.dash != nil {
		s.dash.AddLog(fmt.Sprintf("üéØ SNIPE: %s %s @ %s¬¢ x%s", asset, side, roundedPrice.Mul(decimal.NewFromInt(100)).StringFixed(0), pos.Size.StringFixed(2)))
		s.dash.UpdatePosition(asset, side, roundedPrice, roundedPrice, pos.Size.IntPart(), "SNIPING")
	}

	log.Info().
		Str("asset", asset).
		Str("side", side).
		Str("order_id", orderID).
		Str("filled_size", pos.Size.StringFixed(2)).
		Msg("üéØ [SNIPER] Order placed successfully!")
}

// recordPosition records a new position
func (s *SniperStrategy) recordPosition(pos *SniperPosition) {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.positions[pos.WindowID] = pos
	s.windowTradeCount[pos.WindowID]++
	s.lastTradeTime = time.Now()
	s.totalTrades++
}

// positionMonitorLoop monitors positions for exit signals
func (s *SniperStrategy) positionMonitorLoop() {
	ticker := time.NewTicker(100 * time.Millisecond) // Fast position monitoring for quick SL
	defer ticker.Stop()

	for {
		select {
		case <-s.stopCh:
			return
		case <-ticker.C:
			s.checkPositions()
		}
	}
}

// checkPositions monitors all open positions
func (s *SniperStrategy) checkPositions() {
	s.mu.RLock()
	positions := make([]*SniperPosition, 0, len(s.positions))
	for _, pos := range s.positions {
		positions = append(positions, pos)
	}
	s.mu.RUnlock()

	for _, pos := range positions {
		s.checkPosition(pos)
	}
}

// checkPosition checks a single position for exit
func (s *SniperStrategy) checkPosition(pos *SniperPosition) {
	// Get current market price for this position
	windows := s.windowScanner.GetActiveWindows()
	var currentOdds decimal.Decimal

	for _, w := range windows {
		if w.ID == pos.WindowID {
			if pos.Side == "UP" {
				currentOdds = w.YesPrice
			} else {
				currentOdds = w.NoPrice
			}
			break
		}
	}

	if currentOdds.IsZero() {
		// Window might have ended
		if time.Now().After(pos.WindowEnd) {
			s.handleResolution(pos)
		}
		return
	}

	// Update dashboard
	if s.dash != nil {
		pnl := currentOdds.Sub(pos.EntryPrice).Mul(pos.Size)
		s.dash.UpdatePosition(pos.Asset, pos.Side, pos.EntryPrice, currentOdds, pos.Size.IntPart(), "ACTIVE")
		
		// Update ML signal display with current state
		edge := currentOdds.Sub(pos.EntryPrice).Mul(decimal.NewFromInt(100))
		s.dash.UpdateMLSignal(pos.Asset, pos.Side, currentOdds, 0.9, edge.StringFixed(0)+"¬¢", pnl.StringFixed(2), "SNIPING")
	}

	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	// TRAILING STOP LOGIC: Lock in profits as price rises
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	
	// Update high water mark
	if currentOdds.GreaterThan(pos.HighPrice) {
		pos.HighPrice = currentOdds
		
		// Update trailing stop: once we're 5¬¢+ in profit, trail 8¬¢ below high
		profitFromEntry := currentOdds.Sub(pos.EntryPrice)
		trailingDistance := decimal.NewFromFloat(0.08) // 8¬¢ trailing distance
		
		if profitFromEntry.GreaterThanOrEqual(decimal.NewFromFloat(0.05)) { // 5¬¢ in profit
			newTrailingStop := pos.HighPrice.Sub(trailingDistance)
			// Only move trailing stop UP, never down
			if newTrailingStop.GreaterThan(pos.TrailingStop) {
				pos.TrailingStop = newTrailingStop
				log.Info().
					Str("asset", pos.Asset).
					Str("high", pos.HighPrice.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
					Str("trailing_stop", pos.TrailingStop.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
					Msg("üìà [SNIPER] Trailing stop raised!")
			}
		}
	}

	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	// EXIT CONDITIONS
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

	// 1. TARGET HIT (99¬¢+) - Take profit
	if currentOdds.GreaterThanOrEqual(s.config.QuickFlipTarget) {
		if s.config.HoldToResolution {
			// Hold to resolution enabled - check if price move is strong enough
			holdThreshold := decimal.NewFromFloat(0.001) // 0.1%
			if pos.PriceMovePct.GreaterThanOrEqual(holdThreshold) {
				log.Info().
					Str("asset", pos.Asset).
					Str("side", pos.Side).
					Str("current", currentOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
					Str("price_move", pos.PriceMovePct.Mul(decimal.NewFromInt(100)).StringFixed(2)+"%").
					Msg("üéØ [SNIPER] STRONG MOVE (0.1%+) - HOLDING TO RESOLUTION for $1!")
				return // Don't quick flip, hold for resolution
			}
		}
		
		// Quick flip at target (default behavior)
		log.Info().
			Str("asset", pos.Asset).
			Str("side", pos.Side).
			Str("current", currentOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("target", s.config.QuickFlipTarget.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Msg("üéØ [SNIPER] TARGET HIT! Quick flipping...")
		
		s.exitPosition(pos, currentOdds, "TARGET")
		return
	}

	// 2. TRAILING STOP HIT - Lock in profit
	if pos.TrailingStop.GreaterThan(pos.StopLoss) && currentOdds.LessThanOrEqual(pos.TrailingStop) {
		profit := currentOdds.Sub(pos.EntryPrice).Mul(pos.Size)
		log.Info().
			Str("asset", pos.Asset).
			Str("entry", pos.EntryPrice.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("exit", currentOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("trailing_stop", pos.TrailingStop.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("profit", profit.StringFixed(2)).
			Msg("üìà [SNIPER] TRAILING STOP HIT! Locking in profit...")
		
		s.exitPosition(pos, currentOdds, "TRAILING_STOP")
		return
	}

	// 3. HARD STOP LOSS - Always active, protects capital
	if currentOdds.LessThanOrEqual(pos.StopLoss) {
		log.Warn().
			Str("asset", pos.Asset).
			Str("side", pos.Side).
			Str("current", currentOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("stop", pos.StopLoss.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Msg("üõë [SNIPER] STOP LOSS HIT! Exiting...")
		
		s.exitPosition(pos, currentOdds, "STOP_LOSS")
		return
	}

	// Last 30 seconds - just log, don't do anything special
	// Stop loss still active above, but orders might not fill this close to resolution
	if time.Until(pos.WindowEnd) < 30*time.Second {
		log.Debug().
			Str("asset", pos.Asset).
			Str("current", currentOdds.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
			Str("time_left", time.Until(pos.WindowEnd).String()).
			Msg("üéØ [SNIPER] Final 30s - stop loss still active")
	}
}

// exitPosition exits a position at market - SELLS 100% OF SHARES
func (s *SniperStrategy) exitPosition(pos *SniperPosition, exitPrice decimal.Decimal, reason string) {
	pnl := exitPrice.Sub(pos.EntryPrice).Mul(pos.Size)

	log.Info().
		Str("asset", pos.Asset).
		Str("side", pos.Side).
		Str("entry", pos.EntryPrice.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("exit", exitPrice.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("shares", pos.Size.StringFixed(2)).
		Str("pnl", pnl.StringFixed(2)).
		Str("reason", reason).
		Msg("üéØ [SNIPER] Exiting position - SELLING ALL SHARES")

	// Place sell order for EXACT SIZE we hold
	if s.clobClient != nil {
		slippage := decimal.NewFromFloat(0.03) // 3¬¢ slippage for exit
		sellPrice := exitPrice.Sub(slippage)
		if sellPrice.LessThan(decimal.NewFromFloat(0.01)) {
			sellPrice = decimal.NewFromFloat(0.01)
		}

		_, err := s.clobClient.PlaceLimitOrder(
			pos.TokenID,
			sellPrice,
			pos.Size, // SELL ALL SHARES (decimal precision)
			"SELL",
		)

		if err != nil {
			log.Error().Err(err).Str("asset", pos.Asset).Msg("üéØ [SNIPER] Sell order failed!")
			// Don't remove position, try again
			return
		}
	}

	// Update stats
	s.mu.Lock()
	s.totalProfit = s.totalProfit.Add(pnl)
	if pnl.GreaterThan(decimal.Zero) {
		s.winningTrades++
	}
	delete(s.positions, pos.WindowID)
	s.mu.Unlock()

	// Update dashboard
	if s.dash != nil {
		result := "‚úÖ"
		if pnl.LessThan(decimal.Zero) {
			result = "‚ùå"
		}
		s.dash.AddLog(fmt.Sprintf("%s SNIPE EXIT: %s %s @ %s¬¢ P&L: %s", 
			result, pos.Asset, pos.Side, 
			exitPrice.Mul(decimal.NewFromInt(100)).StringFixed(0),
			pnl.StringFixed(2)))
		s.dash.RemovePosition(pos.Asset)
	}

	// Notify
	if s.notifier != nil {
		s.notifier.SendTradeAlert(pos.Asset, pos.Side, exitPrice, pos.Size.IntPart(), "SNIPE SELL", pnl)
	}
}

// handleResolution handles position at window end
func (s *SniperStrategy) handleResolution(pos *SniperPosition) {
	// Position held to resolution
	// We'll assume we won since we bet with the price direction
	pnl := decimal.NewFromInt(1).Sub(pos.EntryPrice).Mul(pos.Size)

	log.Info().
		Str("asset", pos.Asset).
		Str("side", pos.Side).
		Str("entry", pos.EntryPrice.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("shares", pos.Size.StringFixed(2)).
		Str("resolution", "$1.00").
		Str("pnl", "+$"+pnl.StringFixed(2)).
		Msg("üéØ [SNIPER] Position resolved (assuming win)")

	// Update stats
	s.mu.Lock()
	s.totalProfit = s.totalProfit.Add(pnl)
	s.winningTrades++
	delete(s.positions, pos.WindowID)
	s.mu.Unlock()

	// Update dashboard
	if s.dash != nil {
		s.dash.AddLog(fmt.Sprintf("üèÜ SNIPE WON: %s %s ‚Üí $1.00 P&L: +$%s", 
			pos.Asset, pos.Side, pnl.StringFixed(2)))
		s.dash.RemovePosition(pos.Asset)
	}

	// Notify
	if s.notifier != nil {
		s.notifier.SendTradeAlert(pos.Asset, pos.Side, decimal.NewFromInt(1), pos.Size.IntPart(), "SNIPE WON", pnl)
	}
}

// dashUpdateStats updates dashboard with current stats
func (s *SniperStrategy) dashUpdateStats() {
	if s.dash == nil {
		return
	}

	s.mu.RLock()
	totalTrades := s.totalTrades
	winningTrades := s.winningTrades
	totalProfit := s.totalProfit
	balance := s.cachedBalance
	s.mu.RUnlock()

	// Fetch balance periodically
	if s.clobClient != nil && time.Since(s.lastTradeTime) > 30*time.Second {
		go func() {
			if bal, err := s.clobClient.GetBalance(); err == nil {
				s.mu.Lock()
				s.cachedBalance = bal
				s.mu.Unlock()
			}
		}()
	}

	s.dash.UpdateStats(totalTrades, winningTrades, totalProfit, balance)
}

// updateMarketDataOnly updates dashboard market data without evaluating for trade
func (s *SniperStrategy) updateMarketDataOnly(w *polymarket.PredictionWindow, asset string) {
	if s.dash == nil {
		return
	}

	// Get current prices
	var priceToBeat, currentPrice decimal.Decimal

	if !w.PriceToBeat.IsZero() {
		priceToBeat = w.PriceToBeat
	} else if s.engine != nil {
		if state := s.engine.GetWindowState(w.ID); state != nil {
			priceToBeat = state.StartPrice
		}
	}

	if s.engine != nil {
		currentPrice = s.engine.GetCurrentPrice()
	}

	// Update dashboard with market data
	upOdds := w.YesPrice
	downOdds := w.NoPrice
	s.dash.UpdateMarket(asset, currentPrice, priceToBeat, upOdds, downOdds)
}


================================================================================
FILE: internal/arbitrage/whale_strategy.go
================================================================================
package arbitrage

import (
	"fmt"
	"sync"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"

	"github.com/web3guy0/polybot/internal/database"
	"github.com/web3guy0/polybot/internal/polymarket"
)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üêã WHALE STRATEGY - CONTRARIAN DIP BUYING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//
// ML-TRAINED STRATEGY based on 150,000+ trades from top whale wallets
//
// KEY INSIGHT: Whales buy when odds CRASH, not when they're high
//   - Whale avg entry: 41¬¢ (vs your old 83¬¢)
//   - Whales buy at 15-55¬¢, not 60-85¬¢
//   - They hold to expiry, not quick flip
//
// STRATEGY:
// 1. Wait for odds to DROP significantly (panic selling)
// 2. Buy the crashed side at 15-55¬¢ (deep value)
// 3. Hold to resolution for full $1 payout
// 4. NO stop loss - binary outcome, ride to expiry
//
// R:R MATH (vs Old Strategy):
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ  Metric          ‚îÇ Old (Sniper)  ‚îÇ Whale           ‚îÇ Diff    ‚îÇ
// ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
// ‚îÇ  Entry Range     ‚îÇ 60-85¬¢        ‚îÇ 15-55¬¢          ‚îÇ -45¬¢    ‚îÇ
// ‚îÇ  Avg Entry       ‚îÇ 83¬¢           ‚îÇ 35¬¢             ‚îÇ -48¬¢    ‚îÇ
// ‚îÇ  Max Reward      ‚îÇ 17¬¢ (to 100)  ‚îÇ 65¬¢ (to 100)    ‚îÇ +48¬¢    ‚îÇ
// ‚îÇ  Max Risk        ‚îÇ 33¬¢ (to 50 SL)‚îÇ 35¬¢ (to 0)      ‚îÇ +2¬¢     ‚îÇ
// ‚îÇ  R:R Ratio       ‚îÇ 1:0.52        ‚îÇ 1:1.86          ‚îÇ +258%   ‚îÇ
// ‚îÇ  Breakeven WR    ‚îÇ 66%           ‚îÇ 35%             ‚îÇ -31%    ‚îÇ
// ‚îÇ  EV at 50% WR    ‚îÇ -$0.17/share  ‚îÇ +$0.15/share    ‚îÇ +$0.32  ‚îÇ
// ‚îÇ  EV at 55% WR    ‚îÇ -$0.12/share  ‚îÇ +$0.20/share    ‚îÇ +$0.32  ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//
// ASSET-SPECIFIC PARAMETERS (from ML training):
//   BTC: 15-55¬¢ entry, optimal 35¬¢, R:R 1:1.86
//   ETH: 20-60¬¢ entry, optimal 40¬¢, R:R 1:1.50
//   SOL: 25-65¬¢ entry, optimal 45¬¢, R:R 1:1.22
//
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// WhaleConfig holds ML-derived configuration for whale strategy
type WhaleConfig struct {
	// Entry conditions (CONTRARIAN - buy crashed odds)
	MinOddsEntry        decimal.Decimal // Min odds to buy (e.g., 0.15 = 15¬¢)
	MaxOddsEntry        decimal.Decimal // Max odds to buy (e.g., 0.55 = 55¬¢)
	OptimalEntry        decimal.Decimal // Sweet spot entry (e.g., 0.35)
	
	// Time window (can trade anytime, but prefer early/mid)
	MinTimeRemainingMin float64         // Minimum time left (e.g., 2 min)
	MaxTimeRemainingMin float64         // Maximum time left (no limit, enter early)
	
	// Drop detection (look for crashes)
	MinOddsDrop         decimal.Decimal // Min drop from high (e.g., 0.15 = 15¬¢ drop)
	
	// üéØ EXIT CONDITIONS (PROFIT TAKING)
	TakeProfitPct       decimal.Decimal // Take profit at +X% (e.g., 0.15 = +15%)
	StopLossPct         decimal.Decimal // Stop loss at -X% (e.g., 0.25 = -25%)
	TrailingStopPct     decimal.Decimal // Trailing stop % from high (e.g., 0.10 = 10%)
	TimeExitMinutes     float64         // Exit X minutes before resolution (e.g., 1.0)
	MinProfitToExit     decimal.Decimal // Min profit to exit early (e.g., 0.03 = 3¬¢)
	
	// Exit mode
	HoldToResolution    bool            // If true, ignore TP/SL and hold to end
	
	// Position sizing
	PositionSizePct     decimal.Decimal // % of balance per trade (e.g., 0.15 = 15%)
	MaxConcurrentPositions int          // Max positions at once
	
	// Per-Asset Entry Zones (ML-derived)
	AssetMinEntry       map[string]decimal.Decimal // Min entry per asset
	AssetMaxEntry       map[string]decimal.Decimal // Max entry per asset
	AssetOptimalEntry   map[string]decimal.Decimal // Optimal entry per asset
	
	// Safety
	MaxTradesPerWindow  int           // Max trades per window
	CooldownDuration    time.Duration // Cooldown after trade
}

// DefaultWhaleConfig returns ML-trained default configuration
func DefaultWhaleConfig() WhaleConfig {
	return WhaleConfig{
		// Global entry range (contrarian)
		MinOddsEntry:     decimal.NewFromFloat(0.15),
		MaxOddsEntry:     decimal.NewFromFloat(0.55),
		OptimalEntry:     decimal.NewFromFloat(0.35),
		
		// Time window (enter with time to recover)
		MinTimeRemainingMin: 2.0,  // At least 2 min left
		MaxTimeRemainingMin: 14.0, // Can enter at start of window
		
		// Crash detection
		MinOddsDrop:      decimal.NewFromFloat(0.10), // 10¬¢ drop triggers interest
		
		// üéØ EXIT CONDITIONS (TAKE PROFITS!)
		TakeProfitPct:    decimal.NewFromFloat(0.20), // +20% take profit (35¬¢‚Üí42¬¢)
		StopLossPct:      decimal.NewFromFloat(0.30), // -30% stop loss (35¬¢‚Üí24.5¬¢)
		TrailingStopPct:  decimal.NewFromFloat(0.15), // 15% trailing from high
		TimeExitMinutes:  0.5,                        // Exit 30 sec before resolution
		MinProfitToExit:  decimal.NewFromFloat(0.02), // Min 2¬¢ profit to exit
		
		// Exit mode - FALSE = take profits actively
		HoldToResolution: false,
		
		// Position sizing
		PositionSizePct: decimal.NewFromFloat(0.15), // 15% per trade (fewer, larger)
		MaxConcurrentPositions: 2,
		
		// ML-derived per-asset zones
		AssetMinEntry: map[string]decimal.Decimal{
			"BTC": decimal.NewFromFloat(0.15), // Whales buy BTC dips hard
			"ETH": decimal.NewFromFloat(0.20),
			"SOL": decimal.NewFromFloat(0.25),
		},
		AssetMaxEntry: map[string]decimal.Decimal{
			"BTC": decimal.NewFromFloat(0.55),
			"ETH": decimal.NewFromFloat(0.60),
			"SOL": decimal.NewFromFloat(0.65),
		},
		AssetOptimalEntry: map[string]decimal.Decimal{
			"BTC": decimal.NewFromFloat(0.35), // R:R 1:1.86
			"ETH": decimal.NewFromFloat(0.40), // R:R 1:1.50
			"SOL": decimal.NewFromFloat(0.45), // R:R 1:1.22
		},
		
		// Safety
		MaxTradesPerWindow: 1,
		CooldownDuration:   5 * time.Second,
	}
}

// GetAssetEntryZone returns entry zone for specific asset
func (c *WhaleConfig) GetAssetEntryZone(asset string) (minEntry, maxEntry, optimalEntry decimal.Decimal) {
	// Get asset-specific zones, fall back to global
	if v, ok := c.AssetMinEntry[asset]; ok {
		minEntry = v
	} else {
		minEntry = c.MinOddsEntry
	}
	
	if v, ok := c.AssetMaxEntry[asset]; ok {
		maxEntry = v
	} else {
		maxEntry = c.MaxOddsEntry
	}
	
	if v, ok := c.AssetOptimalEntry[asset]; ok {
		optimalEntry = v
	} else {
		optimalEntry = c.OptimalEntry
	}
	
	return
}

// CalculateRR calculates Risk:Reward ratio for entry price
func (c *WhaleConfig) CalculateRR(entryPrice decimal.Decimal) decimal.Decimal {
	// Risk = entry price (lose all if 0)
	// Reward = 1 - entry (gain to 100¬¢)
	risk := entryPrice
	reward := decimal.NewFromFloat(1.0).Sub(entryPrice)
	
	if risk.IsZero() {
		return decimal.NewFromFloat(999)
	}
	
	return reward.Div(risk)
}

// CalculateBreakevenWinRate returns win rate needed to break even
func (c *WhaleConfig) CalculateBreakevenWinRate(entryPrice decimal.Decimal) decimal.Decimal {
	// Breakeven WR = Risk / (Risk + Reward) = Entry / 1.0 = Entry
	return entryPrice
}

// WhalePosition represents an active whale position (contrarian hold)
type WhalePosition struct {
	TradeID       string
	Asset         string
	Side          string // "UP" or "DOWN" (bought the crashed side)
	TokenID       string
	ConditionID   string
	WindowID      string
	EntryPrice    decimal.Decimal
	CurrentPrice  decimal.Decimal // Latest price
	HighPrice     decimal.Decimal // Highest price since entry (for trailing stop)
	Size          decimal.Decimal // Shares owned
	EntryTime     time.Time
	WindowEnd     time.Time
	OddsDropPct   decimal.Decimal // How much odds dropped before entry
	ExpectedRR    decimal.Decimal // R:R at entry
	BreakevenWR   decimal.Decimal // Win rate needed
	Status        string          // "holding", "exited_tp", "exited_sl", "exited_time", "resolved_win", "resolved_loss"
	ExitPrice     decimal.Decimal // Price we exited at
	ExitReason    string          // Why we exited
	PnL           decimal.Decimal // Realized P&L
}

// PriceHistory tracks historical odds for crash detection
type PriceHistory struct {
	Prices     []decimal.Decimal
	Timestamps []time.Time
	High       decimal.Decimal // Highest seen
	Low        decimal.Decimal // Lowest seen
	LastUpdate time.Time
}

// GetDrop calculates drop from high
func (ph *PriceHistory) GetDrop() decimal.Decimal {
	if ph.High.IsZero() {
		return decimal.Zero
	}
	return ph.High.Sub(ph.Low)
}

// GetDropPct calculates drop percentage from high
func (ph *PriceHistory) GetDropPct() decimal.Decimal {
	if ph.High.IsZero() {
		return decimal.Zero
	}
	drop := ph.High.Sub(ph.Low)
	return drop.Div(ph.High).Mul(decimal.NewFromFloat(100))
}

// WhaleStrategy implements the ML-trained contrarian whale strategy
type WhaleStrategy struct {
	mu sync.RWMutex

	// Components
	windowScanner *polymarket.WindowScanner
	clobClient    *CLOBClient
	db            *database.Database

	// Paper trading mode
	paperTrade bool
	
	// Bankroll for position sizing
	bankroll decimal.Decimal

	// Configuration
	config WhaleConfig

	// Active positions (fewer, larger, hold to resolution)
	positions map[string]*WhalePosition // keyed by windowID

	// Price history for crash detection
	priceHistory map[string]*PriceHistory // keyed by windowID+side

	// Trade tracking
	tradesExecuted int
	tradedWindows  map[string]time.Time // windows we've traded

	// Statistics
	stats WhaleStats
}

// WhaleStats tracks performance metrics
type WhaleStats struct {
	TotalTrades     int
	Wins            int
	Losses          int
	TotalPnL        decimal.Decimal
	AvgEntryPrice   decimal.Decimal
	AvgRR           decimal.Decimal
	BestTrade       decimal.Decimal
	WorstTrade      decimal.Decimal
}

// NewWhaleStrategy creates a new whale strategy instance
func NewWhaleStrategy(
	scanner *polymarket.WindowScanner,
	clobClient *CLOBClient,
	db *database.Database,
	paperTrade bool,
	bankroll decimal.Decimal,
) *WhaleStrategy {
	return &WhaleStrategy{
		windowScanner: scanner,
		clobClient:    clobClient,
		db:            db,
		paperTrade:    paperTrade,
		bankroll:      bankroll,
		config:        DefaultWhaleConfig(),
		positions:     make(map[string]*WhalePosition),
		priceHistory:  make(map[string]*PriceHistory),
		tradedWindows: make(map[string]time.Time),
		stats:         WhaleStats{},
	}
}

// Start begins the whale strategy monitoring
func (ws *WhaleStrategy) Start() {
	go ws.mainLoop()
	go ws.exitMonitorLoop() // üéØ Monitor positions for exit conditions
	log.Info().
		Str("min_entry", ws.config.MinOddsEntry.String()).
		Str("max_entry", ws.config.MaxOddsEntry.String()).
		Str("take_profit", fmt.Sprintf("+%.0f%%", ws.config.TakeProfitPct.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Str("stop_loss", fmt.Sprintf("-%.0f%%", ws.config.StopLossPct.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Bool("hold_to_resolution", ws.config.HoldToResolution).
		Msg("üêã Whale strategy started - hunting for crashed odds")
}

// mainLoop monitors for whale entry opportunities
func (ws *WhaleStrategy) mainLoop() {
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	for range ticker.C {
		ws.scanForCrashedOdds()
	}
}

// exitMonitorLoop monitors open positions for exit conditions
func (ws *WhaleStrategy) exitMonitorLoop() {
	ticker := time.NewTicker(100 * time.Millisecond) // Check exits FAST - 100ms
	defer ticker.Stop()

	for range ticker.C {
		ws.checkExitConditions()
	}
}

// checkExitConditions evaluates all open positions for exit signals
func (ws *WhaleStrategy) checkExitConditions() {
	if ws.config.HoldToResolution {
		return // Skip exit checks if holding to resolution
	}

	if ws.windowScanner == nil {
		return
	}

	windows := ws.windowScanner.GetActiveWindows()
	windowMap := make(map[string]*polymarket.PredictionWindow)
	for i := range windows {
		windowMap[windows[i].ID] = &windows[i]
	}

	ws.mu.Lock()
	defer ws.mu.Unlock()

	for windowID, position := range ws.positions {
		if position.Status != "holding" {
			// Skip positions that are not holding (failed, exited, etc.)
			// Also delete exit_failed positions to prevent memory leak
			if position.Status == "exit_failed" {
				log.Warn().
					Str("asset", position.Asset).
					Str("side", position.Side).
					Msg("üêã‚ö†Ô∏è Position exit failed - removing from tracking")
				delete(ws.positions, windowID)
			}
			continue
		}

		window, exists := windowMap[windowID]
		if !exists {
			continue
		}

		// Get current price for our side
		var currentPrice decimal.Decimal
		if position.Side == "UP" {
			currentPrice = window.YesPrice
		} else {
			currentPrice = window.NoPrice
		}

		// Update position tracking
		position.CurrentPrice = currentPrice
		if currentPrice.GreaterThan(position.HighPrice) {
			position.HighPrice = currentPrice
		}

		// Calculate P&L percentage
		pnlPct := currentPrice.Sub(position.EntryPrice).Div(position.EntryPrice)
		pnlAbs := currentPrice.Sub(position.EntryPrice).Mul(position.Size)

		// Time until resolution
		timeLeft := time.Until(position.WindowEnd).Minutes()

		// üéØ CHECK EXIT CONDITIONS

		// 1. TAKE PROFIT - Price rose enough
		if pnlPct.GreaterThanOrEqual(ws.config.TakeProfitPct) {
			ws.executeExit(position, currentPrice, "take_profit", 
				fmt.Sprintf("üéØ TAKE PROFIT +%.1f%% (%.0f¬¢‚Üí%.0f¬¢)", 
					pnlPct.Mul(decimal.NewFromInt(100)).InexactFloat64(),
					position.EntryPrice.Mul(decimal.NewFromInt(100)).InexactFloat64(),
					currentPrice.Mul(decimal.NewFromInt(100)).InexactFloat64()))
			continue
		}

		// 2. STOP LOSS - Price dropped too much
		if pnlPct.LessThanOrEqual(ws.config.StopLossPct.Neg()) {
			ws.executeExit(position, currentPrice, "stop_loss",
				fmt.Sprintf("üõë STOP LOSS %.1f%% (%.0f¬¢‚Üí%.0f¬¢)",
					pnlPct.Mul(decimal.NewFromInt(100)).InexactFloat64(),
					position.EntryPrice.Mul(decimal.NewFromInt(100)).InexactFloat64(),
					currentPrice.Mul(decimal.NewFromInt(100)).InexactFloat64()))
			continue
		}

		// 3. TRAILING STOP - Price fell from high water mark
		if position.HighPrice.GreaterThan(position.EntryPrice) {
			dropFromHigh := position.HighPrice.Sub(currentPrice).Div(position.HighPrice)
			if dropFromHigh.GreaterThanOrEqual(ws.config.TrailingStopPct) {
				// Only trigger if we're still in profit
				if currentPrice.GreaterThan(position.EntryPrice) {
					ws.executeExit(position, currentPrice, "trailing_stop",
						fmt.Sprintf("üìâ TRAILING STOP (high %.0f¬¢‚Üí%.0f¬¢, drop %.1f%%)",
							position.HighPrice.Mul(decimal.NewFromInt(100)).InexactFloat64(),
							currentPrice.Mul(decimal.NewFromInt(100)).InexactFloat64(),
							dropFromHigh.Mul(decimal.NewFromInt(100)).InexactFloat64()))
					continue
				}
			}
		}

		// 4. TIME EXIT - Near resolution with profit
		if timeLeft <= ws.config.TimeExitMinutes && timeLeft > 0 {
			if pnlAbs.GreaterThanOrEqual(ws.config.MinProfitToExit) {
				ws.executeExit(position, currentPrice, "time_exit",
					fmt.Sprintf("‚è∞ TIME EXIT (%.1f min left, +%.2f¬¢ profit)",
						timeLeft, pnlAbs.Mul(decimal.NewFromInt(100)).InexactFloat64()))
				continue
			}
		}

		// Log position status periodically (every ~5 seconds based on loop)
		if time.Since(position.EntryTime).Seconds() > 5 && 
			int(time.Since(position.EntryTime).Seconds())%10 == 0 {
			log.Debug().
				Str("asset", position.Asset).
				Str("side", position.Side).
				Str("entry", fmt.Sprintf("%.0f¬¢", position.EntryPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
				Str("current", fmt.Sprintf("%.0f¬¢", currentPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
				Str("high", fmt.Sprintf("%.0f¬¢", position.HighPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
				Str("pnl", fmt.Sprintf("%+.1f%%", pnlPct.Mul(decimal.NewFromInt(100)).InexactFloat64())).
				Str("time_left", fmt.Sprintf("%.1fm", timeLeft)).
				Msg("üêã Position status")
		}
	}
}

// executeExit sells position and records P&L
func (ws *WhaleStrategy) executeExit(position *WhalePosition, exitPrice decimal.Decimal, reason, message string) {
	// Calculate P&L
	pnl := exitPrice.Sub(position.EntryPrice).Mul(position.Size)
	
	modeStr := "LIVE"
	if ws.paperTrade {
		modeStr = "PAPER"
	}

	log.Info().
		Str("mode", modeStr).
		Str("asset", position.Asset).
		Str("side", position.Side).
		Str("entry", fmt.Sprintf("%.0f¬¢", position.EntryPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Str("exit", fmt.Sprintf("%.0f¬¢", exitPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Str("pnl", fmt.Sprintf("%+$%.4f", pnl.InexactFloat64())).
		Str("reason", reason).
		Msg(message)

	if ws.paperTrade {
		// PAPER TRADE - just log
		log.Info().
			Str("asset", position.Asset).
			Str("shares", position.Size.String()).
			Str("pnl", fmt.Sprintf("%+$%.4f", pnl.InexactFloat64())).
			Msg("üìù [WHALE] Paper SELL recorded")
	} else {
		// LIVE TRADE - execute sell order with actual shares (not dollars)
		_, err := ws.clobClient.SellSharesAtPrice(position.TokenID, position.Size, exitPrice)
		if err != nil {
			log.Error().Err(err).
				Str("asset", position.Asset).
				Str("shares", position.Size.String()).
				Msg("üêã‚ùå Failed to execute exit order")
			// CRITICAL: Mark position as failed to prevent retry spam
			position.Status = "exit_failed"
			return
		}
	}

	// Update position
	position.Status = "exited_" + reason
	position.ExitPrice = exitPrice
	position.ExitReason = reason
	position.PnL = pnl

	// Update stats
	if pnl.GreaterThan(decimal.Zero) {
		ws.stats.Wins++
	} else {
		ws.stats.Losses++
	}
	ws.stats.TotalPnL = ws.stats.TotalPnL.Add(pnl)
	
	if pnl.GreaterThan(ws.stats.BestTrade) {
		ws.stats.BestTrade = pnl
	}
	if pnl.LessThan(ws.stats.WorstTrade) || ws.stats.WorstTrade.IsZero() {
		ws.stats.WorstTrade = pnl
	}

	// Remove from active positions
	delete(ws.positions, position.WindowID)

	// Log cumulative stats
	winRate := decimal.Zero
	if ws.stats.TotalTrades > 0 {
		winRate = decimal.NewFromInt(int64(ws.stats.Wins)).Div(decimal.NewFromInt(int64(ws.stats.TotalTrades))).Mul(decimal.NewFromInt(100))
	}
	
	log.Info().
		Int("total_trades", ws.stats.TotalTrades).
		Int("wins", ws.stats.Wins).
		Int("losses", ws.stats.Losses).
		Str("win_rate", fmt.Sprintf("%.1f%%", winRate.InexactFloat64())).
		Str("total_pnl", fmt.Sprintf("%+$%.4f", ws.stats.TotalPnL.InexactFloat64())).
		Msg("üêãüìä Whale stats update")
}

// scanForCrashedOdds looks for odds that have crashed into our buy zone
func (ws *WhaleStrategy) scanForCrashedOdds() {
	if ws.windowScanner == nil {
		return
	}

	windows := ws.windowScanner.GetActiveWindows()
	
	for i := range windows {
		window := &windows[i]
		
		// Update price history for both sides
		ws.updatePriceHistory(window.ID, "UP", window.YesPrice)
		ws.updatePriceHistory(window.ID, "DOWN", window.NoPrice)
		
		// Check for entry signal
		signal, err := ws.CheckEntry(window)
		if err != nil {
			continue
		}
		
		if signal != nil && signal.Strength.GreaterThanOrEqual(decimal.NewFromFloat(50)) {
			// Skip if already traded this window
			ws.mu.RLock()
			_, alreadyTraded := ws.tradedWindows[window.ID]
			ws.mu.RUnlock()
			if alreadyTraded {
				continue
			}
			
			// Calculate position size: bankroll √ó position_size_pct
			// Polymarket minimum for market orders is $1
			positionSize := ws.bankroll.Mul(ws.config.PositionSizePct)
			minMarketOrder := decimal.NewFromFloat(1.0) // $1 minimum for market orders
			if positionSize.LessThan(minMarketOrder) {
				positionSize = minMarketOrder
			}
			
			log.Info().
				Str("asset", window.Asset).
				Str("side", signal.Side).
				Str("odds", signal.CurrentOdds.String()).
				Str("rr", fmt.Sprintf("1:%.2f", signal.ExpectedRR.InexactFloat64())).
				Str("strength", signal.Strength.String()).
				Str("reason", signal.Reason).
				Msg("üêã WHALE SIGNAL DETECTED!")
			
			// Execute trade (paper or live)
			_, err := ws.ExecuteTrade(signal, positionSize)
			if err != nil {
				log.Error().Err(err).Msg("üêã Failed to execute whale trade")
			}
		}
	}
}

// SetConfig updates the whale strategy configuration
func (ws *WhaleStrategy) SetConfig(config WhaleConfig) {
	ws.mu.Lock()
	defer ws.mu.Unlock()
	ws.config = config
	log.Info().
		Str("min_entry", config.MinOddsEntry.String()).
		Str("max_entry", config.MaxOddsEntry.String()).
		Str("optimal", config.OptimalEntry.String()).
		Msg("üêã Whale strategy config updated")
}

// updatePriceHistory tracks price for crash detection
func (ws *WhaleStrategy) updatePriceHistory(windowID, side string, price decimal.Decimal) {
	key := windowID + "_" + side
	
	ws.mu.Lock()
	defer ws.mu.Unlock()
	
	history, exists := ws.priceHistory[key]
	if !exists {
		history = &PriceHistory{
			Prices:     make([]decimal.Decimal, 0),
			Timestamps: make([]time.Time, 0),
			High:       price,
			Low:        price,
		}
		ws.priceHistory[key] = history
	}
	
	// Update history
	history.Prices = append(history.Prices, price)
	history.Timestamps = append(history.Timestamps, time.Now())
	history.LastUpdate = time.Now()
	
	// Update high/low
	if price.GreaterThan(history.High) {
		history.High = price
	}
	if price.LessThan(history.Low) {
		history.Low = price
	}
	
	// Keep last 100 prices only
	if len(history.Prices) > 100 {
		history.Prices = history.Prices[len(history.Prices)-100:]
		history.Timestamps = history.Timestamps[len(history.Timestamps)-100:]
	}
}

// CheckEntry evaluates if current conditions warrant a whale entry
func (ws *WhaleStrategy) CheckEntry(window *polymarket.PredictionWindow) (*WhaleSignal, error) {
	ws.mu.RLock()
	defer ws.mu.RUnlock()

	// Skip if already traded this window
	if _, traded := ws.tradedWindows[window.ID]; traded {
		return nil, nil
	}

	// Check time remaining
	timeRemaining := time.Until(window.EndDate).Minutes()
	if timeRemaining < ws.config.MinTimeRemainingMin {
		return nil, nil
	}
	if timeRemaining > ws.config.MaxTimeRemainingMin {
		return nil, nil
	}

	// Get asset-specific entry zones
	minEntry, maxEntry, optimalEntry := ws.config.GetAssetEntryZone(window.Asset)

	// Check both UP and DOWN sides for crash opportunities
	for _, side := range []string{"UP", "DOWN"} {
		var currentOdds decimal.Decimal
		if side == "UP" {
			currentOdds = window.YesPrice
		} else {
			currentOdds = window.NoPrice
		}

		// Is price in our entry zone?
		if currentOdds.LessThan(minEntry) || currentOdds.GreaterThan(maxEntry) {
			continue
		}

		// Check for crash (price dropped from high)
		key := window.ID + "_" + side
		history, exists := ws.priceHistory[key]
		
		var dropFromHigh decimal.Decimal
		var priceHist *PriceHistory
		if exists && !history.High.IsZero() {
			dropFromHigh = history.High.Sub(currentOdds)
			priceHist = history
		}

		// Calculate R:R for this entry
		rr := ws.config.CalculateRR(currentOdds)
		breakevenWR := ws.config.CalculateBreakevenWinRate(currentOdds)

		// Determine signal strength (now checks momentum too!)
		strength := ws.calculateSignalStrength(currentOdds, optimalEntry, dropFromHigh, priceHist)

		// Generate signal if conditions met
		if strength.GreaterThan(decimal.Zero) {
			signal := &WhaleSignal{
				Window:       window,
				Side:         side,
				CurrentOdds:  currentOdds,
				EntryZone:    fmt.Sprintf("%.0f-%.0f¬¢", minEntry.Mul(decimal.NewFromInt(100)).InexactFloat64(), maxEntry.Mul(decimal.NewFromInt(100)).InexactFloat64()),
				DropFromHigh: dropFromHigh,
				ExpectedRR:   rr,
				BreakevenWR:  breakevenWR,
				Strength:     strength,
				Reason:       ws.getSignalReason(currentOdds, optimalEntry, dropFromHigh, rr),
			}
			return signal, nil
		}
	}

	return nil, nil
}

// WhaleSignal represents a trading signal from whale strategy
type WhaleSignal struct {
	Window       *polymarket.PredictionWindow
	Side         string          // "UP" or "DOWN"
	CurrentOdds  decimal.Decimal
	EntryZone    string
	DropFromHigh decimal.Decimal
	ExpectedRR   decimal.Decimal
	BreakevenWR  decimal.Decimal
	Strength     decimal.Decimal // 0-100 signal strength
	Reason       string
}

// calculateSignalStrength determines how good the entry is (0-100)
// CRITICAL: Now REQUIRES a meaningful drop from high AND positive momentum to generate a signal!
func (ws *WhaleStrategy) calculateSignalStrength(
	currentOdds, optimalEntry, dropFromHigh decimal.Decimal,
	priceHistory *PriceHistory,
) decimal.Decimal {
	// CRITICAL CHECK: No drop from high = NO SIGNAL
	// We don't buy just because price is at 35¬¢
	// We ONLY buy if price DROPPED to 35¬¢ from higher!
	minDropRequired := decimal.NewFromFloat(0.10) // Require at least 10¬¢ drop from high
	if dropFromHigh.LessThan(minDropRequired) {
		return decimal.Zero // No crash detected = no entry!
	}
	
	// MOMENTUM CHECK: Only buy when price is RISING (bouncing), not still falling!
	// This prevents buying into a falling knife
	// Require at least 5 data points (25+ seconds of history) for reliable momentum
	if priceHistory == nil || len(priceHistory.Prices) < 5 {
		log.Debug().Msg("‚è∏Ô∏è MOMENTUM: Waiting for more price history (need 5 data points)")
		return decimal.Zero // Not enough data to confirm momentum
	}
	
	n := len(priceHistory.Prices)
	// Check last 5 prices for trend
	p1 := priceHistory.Prices[n-5]
	p2 := priceHistory.Prices[n-4]
	p3 := priceHistory.Prices[n-3]
	p4 := priceHistory.Prices[n-2]
	p5 := priceHistory.Prices[n-1] // current
	
	// REQUIRE V-SHAPE BOUNCE:
	// Price must have fallen (p1 > p2 > p3) then recovered (p3 < p4 < p5)
	// This confirms we're buying AFTER the bottom, not during the fall
	wasFalling := p1.GreaterThan(p2) && p2.GreaterThan(p3)
	isRising := p3.LessThan(p4) && p4.LessThan(p5)
	
	if !wasFalling {
		log.Debug().
			Str("p1", p1.StringFixed(2)).
			Str("p2", p2.StringFixed(2)).
			Str("p3", p3.StringFixed(2)).
			Msg("‚è∏Ô∏è MOMENTUM BLOCKED: No prior crash detected (p1 > p2 > p3 required)")
		return decimal.Zero
	}
	
	if !isRising {
		log.Debug().
			Str("p3", p3.StringFixed(2)).
			Str("p4", p4.StringFixed(2)).
			Str("p5", p5.StringFixed(2)).
			Msg("‚è∏Ô∏è MOMENTUM BLOCKED: Price not bouncing yet (p3 < p4 < p5 required)")
		return decimal.Zero
	}
	
	// V-SHAPE CONFIRMED!
	log.Info().
		Str("fell_from", p1.StringFixed(2)).
		Str("bottom", p3.StringFixed(2)).
		Str("bounced_to", p5.StringFixed(2)).
		Msg("üîÑ V-SHAPE BOUNCE CONFIRMED! Good entry timing")
	
	strength := decimal.Zero

	// Distance from optimal entry (closer = better)
	// If at optimal, +30 points
	// If within 10¬¢, +20 points
	optimalDiff := currentOdds.Sub(optimalEntry).Abs()
	if optimalDiff.LessThanOrEqual(decimal.NewFromFloat(0.05)) {
		strength = strength.Add(decimal.NewFromFloat(30))
	} else if optimalDiff.LessThanOrEqual(decimal.NewFromFloat(0.10)) {
		strength = strength.Add(decimal.NewFromFloat(20))
	} else if optimalDiff.LessThanOrEqual(decimal.NewFromFloat(0.15)) {
		strength = strength.Add(decimal.NewFromFloat(15))
	} else {
		strength = strength.Add(decimal.NewFromFloat(10))
	}

	// Crash detection bonus (bigger drop = better) - THIS IS NOW MANDATORY
	if dropFromHigh.GreaterThanOrEqual(decimal.NewFromFloat(0.25)) {
		strength = strength.Add(decimal.NewFromFloat(40)) // 25¬¢+ drop = panic selling
	} else if dropFromHigh.GreaterThanOrEqual(decimal.NewFromFloat(0.20)) {
		strength = strength.Add(decimal.NewFromFloat(35)) // 20¬¢+ drop = strong crash
	} else if dropFromHigh.GreaterThanOrEqual(decimal.NewFromFloat(0.15)) {
		strength = strength.Add(decimal.NewFromFloat(30)) // 15¬¢+ drop = good crash
	} else if dropFromHigh.GreaterThanOrEqual(decimal.NewFromFloat(0.10)) {
		strength = strength.Add(decimal.NewFromFloat(20)) // 10¬¢+ drop = minimum crash
	}

	// R:R bonus (higher R:R = better)
	rr := ws.config.CalculateRR(currentOdds)
	if rr.GreaterThanOrEqual(decimal.NewFromFloat(2.0)) {
		strength = strength.Add(decimal.NewFromFloat(30)) // 1:2 or better
	} else if rr.GreaterThanOrEqual(decimal.NewFromFloat(1.5)) {
		strength = strength.Add(decimal.NewFromFloat(20)) // 1:1.5
	} else if rr.GreaterThanOrEqual(decimal.NewFromFloat(1.0)) {
		strength = strength.Add(decimal.NewFromFloat(10)) // 1:1
	}

	return strength
}

// getSignalReason returns human-readable reason for signal
func (ws *WhaleStrategy) getSignalReason(
	currentOdds, optimalEntry, dropFromHigh, rr decimal.Decimal,
) string {
	reasons := []string{}

	// Entry quality
	optimalDiff := currentOdds.Sub(optimalEntry).Abs()
	if optimalDiff.LessThanOrEqual(decimal.NewFromFloat(0.05)) {
		reasons = append(reasons, "üéØ At optimal entry")
	} else if currentOdds.LessThan(optimalEntry) {
		reasons = append(reasons, "üíé Below optimal (deep value)")
	}

	// Crash quality
	if dropFromHigh.GreaterThanOrEqual(decimal.NewFromFloat(0.15)) {
		reasons = append(reasons, fmt.Sprintf("üìâ %.0f¬¢ crash detected", dropFromHigh.Mul(decimal.NewFromInt(100)).InexactFloat64()))
	}

	// R:R quality
	if rr.GreaterThanOrEqual(decimal.NewFromFloat(2.0)) {
		reasons = append(reasons, fmt.Sprintf("üöÄ Excellent R:R 1:%.2f", rr.InexactFloat64()))
	} else if rr.GreaterThanOrEqual(decimal.NewFromFloat(1.5)) {
		reasons = append(reasons, fmt.Sprintf("‚úÖ Good R:R 1:%.2f", rr.InexactFloat64()))
	}

	if len(reasons) == 0 {
		return "Standard entry conditions met"
	}

	result := ""
	for i, r := range reasons {
		if i > 0 {
			result += " | "
		}
		result += r
	}
	return result
}

// ExecuteTrade executes a whale strategy trade
func (ws *WhaleStrategy) ExecuteTrade(signal *WhaleSignal, positionSize decimal.Decimal) (*WhalePosition, error) {
	ws.mu.Lock()
	defer ws.mu.Unlock()

	// Check concurrent positions
	if len(ws.positions) >= ws.config.MaxConcurrentPositions {
		return nil, fmt.Errorf("max concurrent positions reached (%d)", ws.config.MaxConcurrentPositions)
	}

	// Get token ID
	var tokenID string
	if signal.Side == "UP" {
		tokenID = signal.Window.YesTokenID
	} else {
		tokenID = signal.Window.NoTokenID
	}

	modeStr := "LIVE"
	if ws.paperTrade {
		modeStr = "PAPER"
	}

	log.Info().
		Str("mode", modeStr).
		Str("asset", signal.Window.Asset).
		Str("side", signal.Side).
		Str("odds", signal.CurrentOdds.String()).
		Str("rr", fmt.Sprintf("1:%.2f", signal.ExpectedRR.InexactFloat64())).
		Str("breakeven_wr", fmt.Sprintf("%.0f%%", signal.BreakevenWR.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Str("reason", signal.Reason).
		Msg("üêã WHALE ENTRY SIGNAL")

	var orderID string

	if ws.paperTrade {
		// PAPER TRADE - simulate the order
		orderID = fmt.Sprintf("paper_%s_%d", signal.Window.Asset, time.Now().UnixNano())
		log.Info().
			Str("asset", signal.Window.Asset).
			Str("side", signal.Side).
			Str("odds", signal.CurrentOdds.String()).
			Str("size", positionSize.String()).
			Str("order_id", orderID).
			Msg("üìù [WHALE] Paper BUY recorded")
	} else {
		// LIVE TRADE - execute real order at the current entry odds
		// IMPORTANT: Pass the actual entry price to avoid fetching wrong price
		order, err := ws.clobClient.PlaceMarketBuyAtPrice(tokenID, positionSize, signal.CurrentOdds)
		if err != nil {
			return nil, fmt.Errorf("failed to place whale order: %w", err)
		}
		orderID = order.OrderID
	}

	// Create position with high water mark for trailing stop
	// CRITICAL: Calculate shares same way as CLOB client to ensure consistency
	// shares = dollars / price, with minimum 5 shares
	actualShares := positionSize.Div(signal.CurrentOdds)
	minShares := decimal.NewFromInt(5)
	if actualShares.LessThan(minShares) {
		actualShares = minShares
	}
	actualShares = actualShares.Round(2) // Match CLOB rounding
	
	position := &WhalePosition{
		TradeID:      orderID,
		Asset:        signal.Window.Asset,
		Side:         signal.Side,
		TokenID:      tokenID,
		ConditionID:  signal.Window.ConditionID,
		WindowID:     signal.Window.ID,
		EntryPrice:   signal.CurrentOdds,
		CurrentPrice: signal.CurrentOdds,
		HighPrice:    signal.CurrentOdds, // Initialize high water mark
		Size:         actualShares,        // Use calculated shares matching CLOB
		EntryTime:    time.Now(),
		WindowEnd:    signal.Window.EndDate,
		OddsDropPct:  signal.DropFromHigh,
		ExpectedRR:   signal.ExpectedRR,
		BreakevenWR:  signal.BreakevenWR,
		Status:       "holding",
	}
	
	log.Info().
		Str("asset", signal.Window.Asset).
		Str("side", signal.Side).
		Str("dollars", positionSize.String()).
		Str("shares", actualShares.String()).
		Str("entry_price", signal.CurrentOdds.String()).
		Msg("üêã Position tracked")

	// Store position
	ws.positions[signal.Window.ID] = position
	ws.tradedWindows[signal.Window.ID] = time.Now()
	ws.tradesExecuted++

	// Update stats
	ws.stats.TotalTrades++
	if ws.stats.AvgEntryPrice.IsZero() {
		ws.stats.AvgEntryPrice = signal.CurrentOdds
	} else {
		ws.stats.AvgEntryPrice = ws.stats.AvgEntryPrice.Add(signal.CurrentOdds).Div(decimal.NewFromInt(2))
	}

	log.Info().
		Str("trade_id", orderID).
		Str("asset", signal.Window.Asset).
		Str("side", signal.Side).
		Str("entry", fmt.Sprintf("%.0f¬¢", signal.CurrentOdds.Mul(decimal.NewFromInt(100)).InexactFloat64())).
		Str("size", positionSize.String()).
		Str("rr", fmt.Sprintf("1:%.2f", signal.ExpectedRR.InexactFloat64())).
		Msg("üêã WHALE POSITION OPENED - HOLDING TO RESOLUTION")

	return position, nil
}

// ProcessResolution handles position resolution
func (ws *WhaleStrategy) ProcessResolution(windowID string, winnerSide string) {
	ws.mu.Lock()
	defer ws.mu.Unlock()

	position, exists := ws.positions[windowID]
	if !exists {
		return
	}

	// Calculate P&L
	if position.Side == winnerSide {
		// WIN: Get $1 per share
		pnl := decimal.NewFromFloat(1.0).Sub(position.EntryPrice).Mul(position.Size)
		position.Status = "resolved_win"
		ws.stats.Wins++
		ws.stats.TotalPnL = ws.stats.TotalPnL.Add(pnl)

		log.Info().
			Str("asset", position.Asset).
			Str("side", position.Side).
			Str("entry", fmt.Sprintf("%.0f¬¢", position.EntryPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
			Str("pnl", fmt.Sprintf("+$%.2f", pnl.InexactFloat64())).
			Msg("üêã‚úÖ WHALE WIN!")
	} else {
		// LOSS: Lose entry price per share
		pnl := position.EntryPrice.Neg().Mul(position.Size)
		position.Status = "resolved_loss"
		ws.stats.Losses++
		ws.stats.TotalPnL = ws.stats.TotalPnL.Add(pnl)

		log.Info().
			Str("asset", position.Asset).
			Str("side", position.Side).
			Str("entry", fmt.Sprintf("%.0f¬¢", position.EntryPrice.Mul(decimal.NewFromInt(100)).InexactFloat64())).
			Str("pnl", fmt.Sprintf("-$%.2f", pnl.Abs().InexactFloat64())).
			Msg("üêã‚ùå WHALE LOSS")
	}

	// Remove from active positions
	delete(ws.positions, windowID)
}

// GetStats returns current strategy statistics
func (ws *WhaleStrategy) GetStats() WhaleStats {
	ws.mu.RLock()
	defer ws.mu.RUnlock()
	
	stats := ws.stats
	if stats.TotalTrades > 0 {
		stats.AvgRR = ws.config.CalculateRR(stats.AvgEntryPrice)
	}
	return stats
}

// GetActivePositions returns currently held positions
func (ws *WhaleStrategy) GetActivePositions() []*WhalePosition {
	ws.mu.RLock()
	defer ws.mu.RUnlock()
	
	positions := make([]*WhalePosition, 0, len(ws.positions))
	for _, p := range ws.positions {
		positions = append(positions, p)
	}
	return positions
}

// PrintStrategyInfo logs whale strategy explanation
func (ws *WhaleStrategy) PrintStrategyInfo() {
	log.Info().Msg("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	log.Info().Msg("üêã WHALE STRATEGY - BUY LOW SELL HIGH")
	log.Info().Msg("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	log.Info().Msg("")
	log.Info().Msg("üìä Entry Requirements:")
	log.Info().Msg("   1. Price in range (15-55¬¢)")
	log.Info().Msg("   2. Crash detected (10¬¢+ drop from high)")
	log.Info().Msg("   3. Momentum UP (price bouncing, not falling)")
	log.Info().Msg("")
	log.Info().Msg("üìà Exit Strategy:")
	if ws.config.HoldToResolution {
		log.Info().Msg("   Mode: HOLD TO RESOLUTION ($1 payout)")
		log.Info().Msg("   - No stop loss (binary outcome)")
		log.Info().Msg("   - Wait for window to resolve")
	} else {
		log.Info().Msgf("   Mode: BUY LOW SELL HIGH")
		log.Info().Msgf("   - Take Profit: +%.0f%%", ws.config.TakeProfitPct.Mul(decimal.NewFromInt(100)).InexactFloat64())
		log.Info().Msgf("   - Stop Loss: -%.0f%%", ws.config.StopLossPct.Mul(decimal.NewFromInt(100)).InexactFloat64())
		log.Info().Msgf("   - Trailing Stop: %.0f%% from high", ws.config.TrailingStopPct.Mul(decimal.NewFromInt(100)).InexactFloat64())
	}
	log.Info().Msg("")
	log.Info().Msg("üéØ PER-ASSET ENTRY ZONES:")
	log.Info().Msg("   BTC: 15-55¬¢ (optimal 35¬¢)")
	log.Info().Msg("   ETH: 20-60¬¢ (optimal 40¬¢)")
	log.Info().Msg("   SOL: 25-65¬¢ (optimal 45¬¢)")
	log.Info().Msg("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
}


================================================================================
FILE: internal/arbitrage/scalper.go
================================================================================
package arbitrage

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
	"github.com/web3guy0/polybot/internal/dashboard"
	"github.com/web3guy0/polybot/internal/database"
	"github.com/web3guy0/polybot/internal/polymarket"
)

// ScalperStrategy - Quick in-and-out trades exploiting temporary mispricings
// When one side drops to extreme low (<25¬¢) without matching price movement,
// buy it and sell when it bounces back to 30-35¬¢
//
// CRITICAL: Must consider "price to beat" - if price already moved significantly
// from window start, there's no time for reversal in 15-minute windows!
//
// Now with DYNAMIC THRESHOLDS powered by ML-style feature analysis:
// - Volatility-adjusted entry thresholds
// - Time-decay consideration
// - Momentum detection
// - Historical win rate learning
// - Kelly criterion position sizing

// TradeNotifier interface for sending trade alerts
type TradeNotifier interface {
	SendTradeAlert(asset, side string, price decimal.Decimal, size int64, action string, pnl decimal.Decimal)
}

type ScalperStrategy struct {
	windowScanner *polymarket.WindowScanner
	clobClient    *CLOBClient
	engine        *Engine // Reference to engine for price-to-beat data
	db            *database.Database // Database for trade logging
	notifier      TradeNotifier // For Telegram alerts
	dash          *dashboard.ResponsiveDash // Terminal dashboard
	
	// ML-powered dynamic thresholds (legacy)
	dynamicThreshold *DynamicThreshold
	useML            bool // Enable intelligent mode
	
	// NEW: Smart probability model
	probModel *ProbabilityModel
	
	// Configuration (fallback if ML disabled)
	entryThreshold decimal.Decimal // Buy when price drops to this (e.g., 0.20)
	profitTarget   decimal.Decimal // Sell when price rises to this (e.g., 0.33)
	stopLoss       decimal.Decimal // Cut losses if drops to this (e.g., 0.15)
	positionSize   decimal.Decimal // USDC per trade
	
	// Late entry protection
	maxWindowAge     time.Duration   // Don't enter if window is older than this
	maxPriceMovePct  decimal.Decimal // Don't enter if price moved more than this from start
	
	// Paper trading mode
	paperTrade bool

	mu sync.RWMutex

	// Active positions we're scalping
	positions map[string]*ScalpPosition
	
	// Cooldowns to prevent spam after failed orders
	orderCooldowns map[string]time.Time // asset -> next allowed order time
	
	// Stats
	totalTrades   int
	winningTrades int
	totalProfit   decimal.Decimal
	cachedBalance decimal.Decimal // Cached account balance
	lastBalanceFetch time.Time    // When we last fetched balance
	
	stopCh chan struct{}
}

type ScalpPosition struct {
	TradeID     string // UUID for DB
	Asset       string
	Side        string // "UP" or "DOWN"
	EntryPrice  decimal.Decimal
	Size        int64
	EntryTime   time.Time
	TargetPrice decimal.Decimal // Sell target (e.g., 0.33)
	StopLoss    decimal.Decimal // Cut losses if drops further
	OrderID     string
	ConditionID string
	TokenID     string
	WindowID    string
	WindowTitle string
	
	// ML features at entry for DB logging
	MLProbability    decimal.Decimal
	MLEntryThreshold decimal.Decimal
	Volatility15m    decimal.Decimal
	Momentum1m       decimal.Decimal
	Momentum5m       decimal.Decimal
	PriceAtEntry     decimal.Decimal
	TimeRemainingMin int
}

// Scalping parameters - defaults
const (
	DefaultScalpEntry      = 0.20 // Buy if <= 20¬¢ (super cheap)
	DefaultScalpTarget     = 0.33 // Sell at 33¬¢
	DefaultScalpStop       = 0.15 // Stop loss at 15¬¢
	DefaultMaxWindowAge    = 10 * time.Minute // Don't enter after 10 mins (only 5 mins left for reversal)
	DefaultMaxPriceMovePct = 0.005 // 0.5% - if price moved more than this, odds are justified
)

func NewScalperStrategy(scanner *polymarket.WindowScanner, clobClient *CLOBClient, paperTrade bool, positionSize decimal.Decimal) *ScalperStrategy {
	baseEntry := decimal.NewFromFloat(DefaultScalpEntry)
	baseProfit := decimal.NewFromFloat(DefaultScalpTarget)
	baseStop := decimal.NewFromFloat(DefaultScalpStop)
	
	return &ScalperStrategy{
		windowScanner:    scanner,
		clobClient:       clobClient,
		paperTrade:       paperTrade,
		entryThreshold:   baseEntry,
		profitTarget:     baseProfit,
		stopLoss:         baseStop,
		positionSize:     positionSize,
		maxWindowAge:     DefaultMaxWindowAge,
		maxPriceMovePct:  decimal.NewFromFloat(DefaultMaxPriceMovePct),
		positions:        make(map[string]*ScalpPosition),
		orderCooldowns:   make(map[string]time.Time),
		totalProfit:      decimal.Zero,
		stopCh:           make(chan struct{}),
		// Initialize ML-powered dynamic thresholds
		dynamicThreshold: NewDynamicThreshold(baseEntry, baseProfit, baseStop),
		useML:            true, // Enable intelligent mode by default
		// NEW: Smart probability model
		probModel:        NewProbabilityModel(),
	}
}

// SetEngine sets the arbitrage engine reference for price-to-beat data
func (s *ScalperStrategy) SetEngine(engine *Engine) {
	s.engine = engine
}

// SetDatabase sets the database for trade logging
func (s *ScalperStrategy) SetDatabase(db *database.Database) {
	s.db = db
	log.Info().Msg("üìä [SCALP] Database connected for trade logging")
}

// SetNotifier sets the notifier for trade alerts (Telegram)
func (s *ScalperStrategy) SetNotifier(n TradeNotifier) {
	s.notifier = n
	log.Info().Msg("üì± [SCALP] Notifier connected for trade alerts")
}

// SetDashboard sets the terminal dashboard
func (s *ScalperStrategy) SetDashboard(d *dashboard.ResponsiveDash) {
	s.dash = d
	log.Info().Msg("üì∫ [SCALP] Dashboard connected")
}

// EnableML enables/disables ML-powered dynamic thresholds
func (s *ScalperStrategy) EnableML(enabled bool) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.useML = enabled
	log.Info().Bool("ml_enabled", enabled).Msg("üß† Scalper ML mode changed")
}

func (s *ScalperStrategy) Start() {
	log.Info().
		Str("entry_threshold", s.entryThreshold.String()).
		Str("profit_target", s.profitTarget.String()).
		Str("stop_loss", s.stopLoss.String()).
		Str("position_size", s.positionSize.String()).
		Bool("paper", s.paperTrade).
		Bool("ml_enabled", s.useML).
		Msg("üß† Intelligent Scalper starting...")

	go s.monitorLoop()
}

func (s *ScalperStrategy) monitorLoop() {
	ticker := time.NewTicker(100 * time.Millisecond) // ULTRA-FAST 100ms scanning!
	defer ticker.Stop()

	for {
		select {
		case <-s.stopCh:
			log.Info().Msg("üõë Scalper strategy stopped")
			return
		case <-ticker.C:
			s.checkWindows()
		}
	}
}

func (s *ScalperStrategy) checkWindows() {
	windows := s.windowScanner.GetActiveWindows()
	if len(windows) == 0 {
		return
	}

	for i := range windows {
		w := &windows[i]
		asset := w.Asset
		
		s.mu.Lock()
		pos, hasPos := s.positions[asset]  // Use ASSET as key, not window ID!
		cooldownTime, onCooldown := s.orderCooldowns[asset]
		numPositions := len(s.positions)
		s.mu.Unlock()

		// Update dashboard with prices
		// Use pre-captured Price to Beat from engine (not from Polymarket API - they don't expose it!)
		binPrice := decimal.Zero
		priceToBeat := decimal.Zero
		if s.engine != nil {
			binPrice = s.engine.GetCurrentPrice()
			// Get price to beat from our captured window state
			if state := s.engine.GetWindowState(w.ID); state != nil && !state.StartPrice.IsZero() {
				priceToBeat = state.StartPrice
			}
		}
		s.dashUpdatePrices(asset, binPrice, priceToBeat, w.YesPrice, w.NoPrice)

		// Log position state periodically (every ~5 seconds)
		if time.Now().Second()%5 == 0 {
			log.Debug().
				Str("asset", asset).
				Bool("has_position", hasPos).
				Int("total_positions", numPositions).
				Str("price_to_beat", priceToBeat.StringFixed(2)).
				Str("window_id", w.ID).
				Msg("üìä [SCALP] Position check")
		}

		// Check if we're on cooldown (failed order recently)
		if onCooldown && time.Now().Before(cooldownTime) {
			log.Info().
				Str("asset", asset).
				Str("cooldown_until", cooldownTime.Format("15:04:05")).
				Msg("‚è≥ [SCALP] On cooldown - skipping")
			continue
		}

		if hasPos {
			// Update dashboard with position
			var currentPrice decimal.Decimal
			if pos.Side == "UP" {
				currentPrice = w.YesPrice
			} else {
				currentPrice = w.NoPrice
			}
			s.dashUpdatePosition(pos, currentPrice, "OPEN")
			
			// Manage existing position
			s.managePosition(pos, w)
		} else {
			// Look for new opportunity
			s.findScalpOpportunity(w)
		}
	}
	
	// Update stats on dashboard
	s.dashUpdateStats()
}

func (s *ScalperStrategy) findScalpOpportunity(w *polymarket.PredictionWindow) {
	asset := w.Asset

	// Get current odds (YesPrice = UP, NoPrice = DOWN)
	upPrice := w.YesPrice
	downPrice := w.NoPrice

	// Calculate time remaining
	windowAge := time.Since(w.StartDate)
	windowDuration := 15 * time.Minute
	timeRemaining := windowDuration - windowAge
	if timeRemaining < 0 {
		timeRemaining = 0
	}

	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	// SMART PROBABILITY MODEL - The brain of our trading!
	// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
	
	// Get price data - CRITICAL: Must have accurate Price to Beat!
	priceToBeat := decimal.Zero
	currentPrice := decimal.Zero
	momentum := 0.0
	
	// PRIORITY 1: Get from engine's tracked state (most reliable!)
	if s.engine != nil {
		currentPrice = s.engine.GetCurrentPrice()
		
		// Get start price from engine's window state
		if state := s.engine.GetWindowState(w.ID); state != nil && !state.StartPrice.IsZero() {
			priceToBeat = state.StartPrice
		}
	}
	
	// PRIORITY 2: Use window's PriceToBeat if engine doesn't have it
	if priceToBeat.IsZero() && !w.PriceToBeat.IsZero() {
		priceToBeat = w.PriceToBeat
	}
	
	// Log if we're missing critical data
	if priceToBeat.IsZero() {
		log.Debug().Str("asset", asset).Msg("‚ö†Ô∏è [SCALP] No Price to Beat - waiting for next window")
		return
	}
	
	if currentPrice.IsZero() {
		log.Debug().Str("asset", asset).Msg("‚ö†Ô∏è [SCALP] No current price - waiting for feed")
		return
	}
	
	// Record price for volatility tracking
	s.dynamicThreshold.GetCollector(asset).RecordPrice(currentPrice)
	
	// Use the probability model to decide
	if s.probModel != nil && !priceToBeat.IsZero() && !currentPrice.IsZero() {
		decision := s.probModel.Analyze(
			asset,
			priceToBeat,
			currentPrice,
			upPrice,
			downPrice,
			timeRemaining,
			momentum,
		)
		
		// Always update ML signal display with latest analysis
		signalStr := "HOLD"
		if decision.ShouldTrade {
			if decision.WinProb >= 0.7 {
				signalStr = "STRONG_BUY"
			} else {
				signalStr = "BUY"
			}
		} else if decision.WinProb < 0.3 {
			signalStr = "SKIP"
		}
		s.dashUpdateMLSignal(
			asset,
			decision.Side,
			decision.MarketPrice,
			decision.WinProb,
			decision.Edge.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢",
			decision.ExpectedValue.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%",
			signalStr,
		)
		
		if decision.ShouldTrade {
			// Model says GO!
			s.dashAddOpportunity(asset, decision.Side, decision.MarketPrice, decimal.NewFromFloat(decision.WinProb), "üß† BUY", decision.Reason)
			
			log.Info().
				Str("asset", asset).
				Str("side", decision.Side).
				Str("market_price", decision.MarketPrice.StringFixed(2)).
				Str("fair_price", decision.FairPrice.StringFixed(2)).
				Str("edge", decision.Edge.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
				Float64("win_prob", decision.WinProb).
				Str("ev", decision.ExpectedValue.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
				Str("risk", decision.RiskLevel).
				Msg("üß† [PROB] SMART ENTRY!")
			
			// Execute the trade with model's recommendation
			s.executeSmartEntry(w, &decision)
			return
		} else {
			// Model says NO
			log.Debug().
				Str("asset", asset).
				Str("up", upPrice.String()).
				Str("down", downPrice.String()).
				Str("reason", decision.Reason).
				Msg("üß† [PROB] No opportunity")
			return
		}
	}
	
	// If probability model couldn't run (missing price data), DON'T TRADE
	// The fallback ML path caused losses by betting against price direction
	log.Debug().
		Str("asset", asset).
		Str("price_to_beat", priceToBeat.String()).
		Str("current_price", currentPrice.String()).
		Msg("‚ö†Ô∏è [SCALP] No trade - probability model requires price data")
	return
}

// executeEntry executes an entry trade with ML-recommended parameters
func (s *ScalperStrategy) executeEntry(w *polymarket.PredictionWindow, features *Features, targetPrice, stopPrice decimal.Decimal) {
	asset := w.Asset
	cheapSide := features.CheapSide
	cheapPrice := features.CheapPrice
	recommendedSize := features.RecommendedSize
	
	var tokenID string
	if cheapSide == "UP" {
		tokenID = w.YesTokenID
	} else {
		tokenID = w.NoTokenID
	}

	// Calculate position size
	tickSize := decimal.NewFromFloat(0.01)
	roundedPrice := cheapPrice.Div(tickSize).Floor().Mul(tickSize)
	if roundedPrice.LessThan(tickSize) {
		roundedPrice = tickSize
	}

	// Use ML-recommended size or fallback
	posSize := recommendedSize
	if posSize.IsZero() || posSize.LessThan(decimal.NewFromInt(1)) {
		posSize = s.positionSize
	}

	size := posSize.Div(roundedPrice).Floor().IntPart()
	if size < 5 {
		size = 5 // Minimum 5 shares
	}

	// Calculate time remaining
	windowAge := time.Since(w.StartDate)
	timeRemainingMin := int((15*time.Minute - windowAge).Minutes())
	if timeRemainingMin < 0 {
		timeRemainingMin = 0
	}
	
	// Get current BTC/ETH/SOL price for reference
	var priceAtEntry decimal.Decimal
	if s.engine != nil {
		priceAtEntry = s.engine.GetCurrentPrice()
	}

	// Create position with dynamic targets and ML features
	pos := &ScalpPosition{
		TradeID:          uuid.New().String(),
		Asset:            asset,
		Side:             cheapSide,
		EntryPrice:       roundedPrice,
		Size:             size,
		EntryTime:        time.Now(),
		TargetPrice:      targetPrice,
		StopLoss:         stopPrice,
		ConditionID:      w.ConditionID,
		TokenID:          tokenID,
		WindowID:         w.ID,
		WindowTitle:      w.Question,
		MLProbability:    features.ProfitProbability,
		MLEntryThreshold: features.CheapPrice, // Entry price = threshold used
		Volatility15m:    features.Volatility15m,
		Momentum1m:       features.PriceVelocity1m,
		Momentum5m:       features.PriceVelocity5m,
		PriceAtEntry:     priceAtEntry,
		TimeRemainingMin: timeRemainingMin,
	}

	actualCost := roundedPrice.Mul(decimal.NewFromInt(size))
	potentialProfit := targetPrice.Sub(roundedPrice).Mul(decimal.NewFromInt(size))

	log.Info().
		Str("asset", asset).
		Str("side", cheapSide).
		Str("entry", roundedPrice.String()).
		Str("target", targetPrice.String()).
		Str("stop_loss", stopPrice.String()).
		Int64("size", size).
		Str("cost", actualCost.String()).
		Str("potential_profit", potentialProfit.String()).
		Str("P(profit)", features.ProfitProbability.StringFixed(2)).
		Bool("ml_mode", true).
		Msg("üß† [ML] INTELLIGENT ENTRY")

	// Place the order
	s.placeOrder(pos, w, "BUY")
}

// executeSmartEntry executes a trade based on the probability model's decision
func (s *ScalperStrategy) executeSmartEntry(w *polymarket.PredictionWindow, decision *TradeDecision) {
	asset := w.Asset
	side := decision.Side
	marketPrice := decision.MarketPrice
	
	var tokenID string
	if side == "UP" {
		tokenID = w.YesTokenID
	} else {
		tokenID = w.NoTokenID
	}

	// Calculate position size based on model's recommendation
	tickSize := decimal.NewFromFloat(0.01)
	roundedPrice := marketPrice.Div(tickSize).Floor().Mul(tickSize)
	if roundedPrice.LessThan(tickSize) {
		roundedPrice = tickSize
	}

	// Use Kelly-based size from model, scaled to our position size
	kellyFraction := decision.RecommendedSize.InexactFloat64()
	posValue := s.positionSize.Mul(decimal.NewFromFloat(kellyFraction))
	if posValue.LessThan(decimal.NewFromFloat(0.50)) {
		posValue = decimal.NewFromFloat(0.50) // Minimum $0.50
	}

	size := posValue.Div(roundedPrice).Floor().IntPart()
	if size < 5 {
		size = 5 // Minimum 5 shares
	}

	// Calculate dynamic stop loss based on edge
	// Tighter stops for trades with high confidence
	stopPct := decimal.NewFromFloat(0.75) // Default 25% loss
	if decision.Confidence > 0.7 {
		stopPct = decimal.NewFromFloat(0.80) // 20% loss for high confidence
	}
	stopPrice := roundedPrice.Mul(stopPct)
	if stopPrice.LessThan(decimal.NewFromFloat(0.02)) {
		stopPrice = decimal.NewFromFloat(0.02)
	}

	// Target = fair price (model's estimate of true value)
	targetPrice := decision.FairPrice
	if targetPrice.LessThanOrEqual(roundedPrice) {
		// If fair is below market (shouldn't happen), use 50% profit target
		targetPrice = roundedPrice.Mul(decimal.NewFromFloat(1.5))
	}

	// Get current asset price for logging
	priceAtEntry := decimal.Zero
	if s.engine != nil {
		priceAtEntry = s.engine.GetCurrentPrice()
	}

	pos := &ScalpPosition{
		TradeID:          uuid.New().String(),
		Asset:            asset,
		Side:             side,
		EntryPrice:       roundedPrice,
		Size:             size,
		EntryTime:        time.Now(),
		TargetPrice:      targetPrice,
		StopLoss:         stopPrice,
		ConditionID:      w.ConditionID,
		TokenID:          tokenID,
		WindowID:         w.ID,
		WindowTitle:      w.Question,
		MLProbability:    decimal.NewFromFloat(decision.WinProb),
		MLEntryThreshold: roundedPrice,
		PriceAtEntry:     priceAtEntry,
	}

	actualCost := roundedPrice.Mul(decimal.NewFromInt(size))
	potentialProfit := targetPrice.Sub(roundedPrice).Mul(decimal.NewFromInt(size))

	log.Info().
		Str("asset", asset).
		Str("side", side).
		Str("entry", roundedPrice.String()).
		Str("fair", decision.FairPrice.String()).
		Str("target", targetPrice.String()).
		Str("stop_loss", stopPrice.String()).
		Int64("size", size).
		Str("cost", actualCost.String()).
		Str("potential", potentialProfit.String()).
		Float64("win_prob", decision.WinProb).
		Str("edge", decision.Edge.Mul(decimal.NewFromInt(100)).StringFixed(0)+"¬¢").
		Str("ev", decision.ExpectedValue.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
		Str("risk", decision.RiskLevel).
		Msg("üß† [SMART] PROBABILITY-BASED ENTRY!")

	// Place the order
	s.placeOrder(pos, w, "BUY")
}

func (s *ScalperStrategy) managePosition(pos *ScalpPosition, w *polymarket.PredictionWindow) {
	// Get current price of our position's side (YesPrice = UP, NoPrice = DOWN)
	var currentPrice decimal.Decimal

	if pos.Side == "UP" {
		currentPrice = w.YesPrice
	} else {
		currentPrice = w.NoPrice
	}

	holdTime := time.Since(pos.EntryTime)

	// Check profit target - SELL!
	// Also sell if we've made 50%+ profit on entry (e.g., bought at 8¬¢, now 12¬¢+)
	profitPct := currentPrice.Sub(pos.EntryPrice).Div(pos.EntryPrice)
	minProfitPct := decimal.NewFromFloat(0.50) // Take profit at 50% gain
	
	if currentPrice.GreaterThanOrEqual(pos.TargetPrice) || profitPct.GreaterThanOrEqual(minProfitPct) {
		profit := currentPrice.Sub(pos.EntryPrice).Mul(decimal.NewFromInt(pos.Size))
		log.Info().
			Str("asset", pos.Asset).
			Str("side", pos.Side).
			Str("entry", pos.EntryPrice.String()).
			Str("current", currentPrice.String()).
			Str("profit_pct", profitPct.Mul(decimal.NewFromInt(100)).StringFixed(1)+"%").
			Str("profit", profit.String()).
			Str("hold_time", holdTime.Round(time.Second).String()).
			Msg("üí∞ [SCALP] PROFIT TARGET HIT - SELLING!")

		s.placeOrder(pos, w, "SELL")
		return
	}

	// Check stop loss - CUT LOSSES!
	if currentPrice.LessThanOrEqual(pos.StopLoss) {
		loss := pos.EntryPrice.Sub(currentPrice).Mul(decimal.NewFromInt(pos.Size))
		log.Warn().
			Str("asset", pos.Asset).
			Str("side", pos.Side).
			Str("entry", pos.EntryPrice.String()).
			Str("current", currentPrice.String()).
			Str("loss", loss.String()).
			Msg("üõë [SCALP] STOP LOSS HIT!")

		s.placeOrder(pos, w, "SELL")
		return
	}

	// Check time-based exit - if held too long without hitting target, exit
	if holdTime > 3*time.Minute {
		// Force exit after 3 minutes - don't baghold
		pnl := currentPrice.Sub(pos.EntryPrice).Mul(decimal.NewFromInt(pos.Size))
		log.Warn().
			Str("asset", pos.Asset).
			Str("side", pos.Side).
			Str("hold_time", holdTime.String()).
			Str("pnl", pnl.String()).
			Msg("‚è∞ [SCALP] TIME EXIT - exiting position")

		s.placeOrder(pos, w, "SELL")
		return
	}

	// Still waiting for target
	pnl := currentPrice.Sub(pos.EntryPrice).Mul(decimal.NewFromInt(pos.Size))
	log.Debug().
		Str("asset", pos.Asset).
		Str("side", pos.Side).
		Str("entry", pos.EntryPrice.String()).
		Str("current", currentPrice.String()).
		Str("target", pos.TargetPrice.String()).
		Str("pnl", pnl.String()).
		Str("hold_time", holdTime.Round(time.Second).String()).
		Msg("‚è≥ [SCALP] Holding - waiting for target")
}

func (s *ScalperStrategy) placeOrder(pos *ScalpPosition, w *polymarket.PredictionWindow, side string) {
	s.mu.Lock()
	defer s.mu.Unlock()

	var tokenID string
	var currentPrice decimal.Decimal
	
	if pos.Side == "UP" {
		tokenID = w.YesTokenID
		currentPrice = w.YesPrice
	} else {
		tokenID = w.NoTokenID
		currentPrice = w.NoPrice
	}

	tickSize := decimal.NewFromFloat(0.01)
	var orderPrice decimal.Decimal
	
	if side == "BUY" {
		orderPrice = pos.EntryPrice // Already rounded
	} else {
		// SELL - use current market price (floored)
		orderPrice = currentPrice.Div(tickSize).Floor().Mul(tickSize)
	}

	modeStr := "LIVE"
	if s.paperTrade {
		modeStr = "PAPER"
	}

	log.Info().
		Str("mode", modeStr).
		Str("action", side).
		Str("asset", pos.Asset).
		Str("side", pos.Side).
		Str("price", orderPrice.String()).
		Int64("size", pos.Size).
		Msg(fmt.Sprintf("üì§ [SCALP] %s order", side))

	if s.paperTrade {
		// Paper trade - just track it
		if side == "BUY" {
			s.positions[pos.Asset] = pos
			
			// Save entry to database
			s.saveEntryToDB(pos, "")
			
			// Dashboard updates
			s.dashUpdatePosition(pos, orderPrice, "OPEN")
			s.dashAddTrade(pos.Asset, "BUY", orderPrice, pos.Size, decimal.Zero, "‚úÖ")
			
			log.Info().Str("asset", pos.Asset).Msg("üìù [SCALP] Paper BUY recorded")
		} else {
			// Calculate P&L
			pnl := orderPrice.Sub(pos.EntryPrice).Mul(decimal.NewFromInt(pos.Size))
			s.totalProfit = s.totalProfit.Add(pnl)
			s.totalTrades++
			won := pnl.GreaterThan(decimal.Zero)
			if won {
				s.winningTrades++
			}
			
			// Record outcome for ML learning
			s.dynamicThreshold.RecordTradeOutcome(pos.Asset, pos.EntryPrice, won, pnl)
			
			// Determine exit type
			exitType := s.determineExitType(pos, currentPrice)
			
			// Update database with exit
			s.saveExitToDB(pos, "", orderPrice, pnl, exitType)
			
			// Dashboard updates
			s.dashRemovePosition(pos.Asset)
			resultIcon := "‚úÖ"
			if !won {
				resultIcon = "‚ùå"
			}
			s.dashAddTrade(pos.Asset, "SELL", orderPrice, pos.Size, pnl, resultIcon)
			s.dashUpdateStats()
			
			delete(s.positions, pos.Asset)
			log.Info().
				Str("asset", pos.Asset).
				Str("pnl", pnl.String()).
				Str("total_profit", s.totalProfit.String()).
				Bool("won", won).
				Str("exit_type", exitType).
				Msg("üìù [SCALP] Paper SELL recorded (ML + DB updated)")
		}
		return
	}

	// LIVE TRADE
	if s.clobClient == nil {
		log.Error().Msg("‚ùå [SCALP] CLOB client not available")
		return
	}

	// Place the order - PlaceLimitOrder(tokenID, price, size, side)
	sizeDecimal := decimal.NewFromInt(pos.Size)
	orderID, err := s.clobClient.PlaceLimitOrder(tokenID, orderPrice, sizeDecimal, side)
	if err != nil {
		errStr := err.Error()
		
		// Check if it's a balance issue
		isBalanceError := strings.Contains(errStr, "balance") || strings.Contains(errStr, "allowance")
		
		if isBalanceError {
			log.Error().
				Str("asset", pos.Asset).
				Str("price", orderPrice.String()).
				Int64("size", pos.Size).
				Msg("üí∏ [SCALP] NOT ENOUGH BALANCE - Need to deposit more USDC!")
		} else {
			log.Error().Err(err).Str("asset", pos.Asset).Msg("‚ùå [SCALP] Failed to place order")
		}
		
		if side == "BUY" {
			// Failed to enter - SET COOLDOWN to prevent spam retries!
			// Longer cooldown for balance errors since depositing takes time
			cooldownDuration := 5 * time.Minute
			if !isBalanceError {
				cooldownDuration = 2 * time.Minute
			}
			s.orderCooldowns[pos.Asset] = time.Now().Add(cooldownDuration)
			log.Warn().
				Str("asset", pos.Asset).
				Str("cooldown", cooldownDuration.String()).
				Msg("‚è≥ [SCALP] Order failed - cooling down")
			return
		}
		// Failed to exit - keep position for retry (shorter cooldown)
		s.orderCooldowns[pos.Asset] = time.Now().Add(30 * time.Second)
		return
	}
	
	// Clear any cooldown on success
	delete(s.orderCooldowns, pos.Asset)

	if side == "BUY" {
		// CRITICAL: Verify the order was actually filled!
		// FAK orders may partially fill - we need to know how much
		time.Sleep(500 * time.Millisecond) // Brief wait for order to process
		
		status, filledSize, _, err := s.clobClient.GetOrderStatus(orderID)
		if err != nil {
			log.Warn().Err(err).Str("order_id", orderID).Msg("‚ö†Ô∏è [SCALP] Could not verify order status")
			// Assume filled if we got an order ID back
		} else if status != "matched" && status != "filled" && filledSize.IsZero() {
			log.Warn().
				Str("order_id", orderID).
				Str("status", status).
				Str("filled", filledSize.String()).
				Msg("‚ùå [SCALP] Order NOT filled - not tracking position!")
			// Set cooldown since the trade opportunity passed
			s.orderCooldowns[pos.Asset] = time.Now().Add(1 * time.Minute)
			return
		} else if !filledSize.IsZero() {
			// Update position size to ACTUAL filled amount (handles partial fills)
			actualSize := filledSize.IntPart()
			if actualSize > 0 && actualSize != pos.Size {
				log.Info().
					Int64("ordered", pos.Size).
					Int64("filled", actualSize).
					Msg("üìä [SCALP] Partial fill - adjusting position size")
				pos.Size = actualSize
			}
		}
		
		pos.OrderID = orderID
		s.positions[pos.Asset] = pos
		
		// Save entry to database
		s.saveEntryToDB(pos, orderID)
		
		// Dashboard updates
		s.dashUpdatePosition(pos, orderPrice, "OPEN")
		s.dashAddTrade(pos.Asset, "BUY", orderPrice, pos.Size, decimal.Zero, "‚úÖ")
		
		// Send Telegram alert
		if s.notifier != nil {
			s.notifier.SendTradeAlert(pos.Asset, pos.Side, orderPrice, pos.Size, "BUY", decimal.Zero)
		}
		
		log.Info().
			Str("order_id", orderID).
			Str("asset", pos.Asset).
			Int64("size", pos.Size).
			Str("status", "FILLED").
			Msg("‚úÖ [SCALP] BUY order FILLED - tracking position!")
	} else {
		// SELL order - verify it filled before updating state
		time.Sleep(500 * time.Millisecond) // Brief wait for order to process
		
		status, filledSize, _, err := s.clobClient.GetOrderStatus(orderID)
		if err != nil {
			log.Warn().Err(err).Str("order_id", orderID).Msg("‚ö†Ô∏è [SCALP] Could not verify SELL status")
			// Keep position for retry
			s.orderCooldowns[pos.Asset] = time.Now().Add(30 * time.Second)
			return
		}
		
		if filledSize.IsZero() && status != "matched" && status != "filled" {
			log.Warn().
				Str("order_id", orderID).
				Str("status", status).
				Msg("‚ùå [SCALP] SELL NOT filled - keeping position for retry!")
			s.orderCooldowns[pos.Asset] = time.Now().Add(30 * time.Second)
			return
		}
		
		// Check for partial SELL - but DON'T retry, just accept the partial and move on
		// Retrying partial sells causes multiple sales at progressively worse prices!
		actualSold := filledSize.IntPart()
		if actualSold > 0 && actualSold < pos.Size {
			log.Warn().
				Int64("ordered", pos.Size).
				Int64("sold", actualSold).
				Int64("unsold", pos.Size - actualSold).
				Msg("‚ö†Ô∏è [SCALP] Partial SELL - accepting loss on remaining shares")
			// Accept the partial fill and close position - don't retry at worse prices!
			pos.Size = actualSold // Update to actual sold amount for P&L calc
			// Fall through to close position
		}
		
		// Calculate P&L
		pnl := orderPrice.Sub(pos.EntryPrice).Mul(decimal.NewFromInt(pos.Size))
		s.totalProfit = s.totalProfit.Add(pnl)
		s.totalTrades++
		won := pnl.GreaterThan(decimal.Zero)
		if won {
			s.winningTrades++
		}
		
		// Record outcome for ML learning
		s.dynamicThreshold.RecordTradeOutcome(pos.Asset, pos.EntryPrice, won, pnl)
		
		// Determine exit type
		exitType := s.determineExitType(pos, currentPrice)
		
		// Update database with exit
		s.saveExitToDB(pos, orderID, orderPrice, pnl, exitType)
		
		// Dashboard updates
		s.dashRemovePosition(pos.Asset)
		resultIcon := "‚úÖ"
		action := "SELL"
		if exitType == "stop_loss" {
			resultIcon = "‚ùå"
			action = "STOP"
		}
		s.dashAddTrade(pos.Asset, action, orderPrice, pos.Size, pnl, resultIcon)
		s.dashUpdateStats()
		
		// Send Telegram alert with P&L
		if s.notifier != nil {
			s.notifier.SendTradeAlert(pos.Asset, pos.Side, orderPrice, pos.Size, action, pnl)
		}
		
		delete(s.positions, pos.Asset)
		log.Info().
			Str("order_id", orderID).
			Str("asset", pos.Asset).
			Str("pnl", pnl.String()).
			Str("total_profit", s.totalProfit.String()).
			Int("wins", s.winningTrades).
			Int("total", s.totalTrades).
			Str("exit_type", exitType).
			Bool("verified", true).
			Msg("‚úÖ [SCALP] SELL VERIFIED & FILLED!")
	}
}

// determineExitType figures out why we exited
func (s *ScalperStrategy) determineExitType(pos *ScalpPosition, currentPrice decimal.Decimal) string {
	holdTime := time.Since(pos.EntryTime)
	profitPct := currentPrice.Sub(pos.EntryPrice).Div(pos.EntryPrice)
	
	if currentPrice.GreaterThanOrEqual(pos.TargetPrice) {
		return "profit_target"
	}
	if profitPct.GreaterThanOrEqual(decimal.NewFromFloat(0.50)) {
		return "early_exit"
	}
	if currentPrice.LessThanOrEqual(pos.StopLoss) {
		return "stop_loss"
	}
	if holdTime > 3*time.Minute {
		return "timeout"
	}
	return "manual"
}

// saveEntryToDB saves an entry trade to the database
func (s *ScalperStrategy) saveEntryToDB(pos *ScalpPosition, orderID string) {
	if s.db == nil {
		return
	}
	
	entryCost := pos.EntryPrice.Mul(decimal.NewFromInt(pos.Size))
	
	trade := &database.ScalpTrade{
		TradeID:          pos.TradeID,
		Asset:            pos.Asset,
		WindowID:         pos.WindowID,
		WindowTitle:      pos.WindowTitle,
		Side:             pos.Side,
		TokenID:          pos.TokenID,
		EntryPrice:       pos.EntryPrice,
		EntrySize:        pos.Size,
		EntryCost:        entryCost,
		EntryTime:        pos.EntryTime,
		EntryOrderID:     orderID,
		MLProbability:    pos.MLProbability,
		MLEntryThreshold: pos.MLEntryThreshold,
		MLProfitTarget:   pos.TargetPrice,
		MLStopLoss:       pos.StopLoss,
		Volatility15m:    pos.Volatility15m,
		Momentum1m:       pos.Momentum1m,
		Momentum5m:       pos.Momentum5m,
		PriceAtEntry:     pos.PriceAtEntry,
		TimeRemainingMin: pos.TimeRemainingMin,
		Status:           "OPEN",
	}
	
	if err := s.db.SaveScalpTrade(trade); err != nil {
		log.Error().Err(err).Str("asset", pos.Asset).Msg("‚ùå Failed to save entry to DB")
	} else {
		log.Debug().Str("trade_id", pos.TradeID).Msg("üìä Entry saved to DB")
	}
}

// saveExitToDB updates the trade with exit info
func (s *ScalperStrategy) saveExitToDB(pos *ScalpPosition, orderID string, exitPrice, pnl decimal.Decimal, exitType string) {
	if s.db == nil {
		return
	}
	
	// Fetch the existing trade
	trade, err := s.db.GetScalpTrade(pos.TradeID)
	if err != nil {
		log.Error().Err(err).Str("trade_id", pos.TradeID).Msg("‚ùå Failed to find trade in DB")
		return
	}
	
	// Update exit fields
	exitTime := time.Now()
	exitValue := exitPrice.Mul(decimal.NewFromInt(pos.Size))
	profitPct := decimal.Zero
	if !pos.EntryPrice.IsZero() {
		profitPct = pnl.Div(pos.EntryPrice.Mul(decimal.NewFromInt(pos.Size))).Mul(decimal.NewFromInt(100))
	}
	
	trade.ExitPrice = exitPrice
	trade.ExitSize = pos.Size
	trade.ExitValue = exitValue
	trade.ExitTime = &exitTime
	trade.ExitOrderID = orderID
	trade.ExitType = exitType
	trade.ProfitLoss = pnl
	trade.ProfitPct = profitPct
	trade.Status = "CLOSED"
	
	if err := s.db.UpdateScalpTrade(trade); err != nil {
		log.Error().Err(err).Str("trade_id", pos.TradeID).Msg("‚ùå Failed to update exit in DB")
	} else {
		log.Debug().
			Str("trade_id", pos.TradeID).
			Str("pnl", pnl.String()).
			Str("exit_type", exitType).
			Msg("üìä Exit saved to DB")
	}
	
	// Update ML learning and daily stats
	won := pnl.GreaterThan(decimal.Zero)
	priceBucket := int(pos.EntryPrice.Mul(decimal.NewFromInt(100)).IntPart()) // 0.08 -> 8
	
	if err := s.db.UpdateMLLearning(pos.Asset, priceBucket, pnl, won); err != nil {
		log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to update ML learning")
	}
	
	if err := s.db.UpdateDailyStats(pnl, pos.Asset, won); err != nil {
		log.Warn().Err(err).Msg("‚ö†Ô∏è Failed to update daily stats")
	}
}

func (s *ScalperStrategy) Stop() {
	close(s.stopCh)
	log.Info().
		Int("total_trades", s.totalTrades).
		Int("winning_trades", s.winningTrades).
		Str("total_profit", s.totalProfit.String()).
		Msg("üõë [SCALP] Strategy stopped")
}

// ScalperStats holds scalper performance statistics
type ScalperStats struct {
	TotalTrades   int
	WinningTrades int
	TotalProfit   decimal.Decimal
}

// GetStats returns scalper statistics
func (s *ScalperStrategy) GetStats() ScalperStats {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return ScalperStats{
		TotalTrades:   s.totalTrades,
		WinningTrades: s.winningTrades,
		TotalProfit:   s.totalProfit,
	}
}

// GetPositions returns all open positions
func (s *ScalperStrategy) GetPositions() []*ScalpPosition {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	positions := make([]*ScalpPosition, 0, len(s.positions))
	for _, pos := range s.positions {
		positions = append(positions, pos)
	}
	return positions
}

func (s *ScalperStrategy) modeStr() string {
	if s.paperTrade {
		return "PAPER"
	}
	return "LIVE"
}

// Helper to truncate question for logs
func truncateQuestion(q string) string {
	if len(q) > 40 {
		return q[:40] + "..."
	}
	return q
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DASHBOARD HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// dashUpdatePosition updates the dashboard with current position state
func (s *ScalperStrategy) dashUpdatePosition(pos *ScalpPosition, currentPrice decimal.Decimal, status string) {
	if s.dash != nil {
		s.dash.UpdatePosition(pos.Asset, pos.Side, pos.EntryPrice, currentPrice, pos.Size, status)
	}
}

// dashRemovePosition removes a position from dashboard
func (s *ScalperStrategy) dashRemovePosition(asset string) {
	if s.dash != nil {
		s.dash.RemovePosition(asset)
	}
}

// dashAddTrade logs a trade to dashboard
func (s *ScalperStrategy) dashAddTrade(asset, action string, price decimal.Decimal, size int64, pnl decimal.Decimal, result string) {
	if s.dash != nil {
		s.dash.AddLog(fmt.Sprintf("%s %s %s @ %s¬¢ x%d %s", result, action, asset, price.Mul(decimal.NewFromInt(100)).StringFixed(0), size, pnl.StringFixed(2)))
	}
}

// dashUpdateStats updates overall stats on dashboard
func (s *ScalperStrategy) dashUpdateStats() {
	s.mu.RLock()
	totalTrades := s.totalTrades
	winningTrades := s.winningTrades
	totalProfit := s.totalProfit
	cachedBalance := s.cachedBalance
	lastFetch := s.lastBalanceFetch
	s.mu.RUnlock()
	
	// Fetch balance every 30 seconds
	if time.Since(lastFetch) > 30*time.Second && s.clobClient != nil {
		go func() {
			balance, err := s.clobClient.GetBalance()
			if err == nil {
				s.mu.Lock()
				s.cachedBalance = balance
				s.lastBalanceFetch = time.Now()
				s.mu.Unlock()
			}
		}()
	}
	
	if s.dash != nil {
		s.dash.UpdateStats(totalTrades, winningTrades, totalProfit, cachedBalance)
	}
}

// dashUpdatePrices updates price display on dashboard
func (s *ScalperStrategy) dashUpdatePrices(asset string, binPrice, priceToBeat, upOdds, downOdds decimal.Decimal) {
	if s.dash != nil {
		s.dash.UpdateMarket(asset, binPrice, priceToBeat, upOdds, downOdds)
	}
}

// dashLog logs a message to dashboard
func (s *ScalperStrategy) dashLog(msg string) {
	if s.dash != nil {
		s.dash.AddLog(msg)
	}
}

// dashAddOpportunity logs an opportunity/signal to dashboard
func (s *ScalperStrategy) dashAddOpportunity(asset, side string, price, probability decimal.Decimal, signal, reason string) {
	if s.dash != nil {
		s.dash.AddSignal(asset, side, signal, price, reason, probability.InexactFloat64())
	}
}

// dashUpdateMLSignal updates ML signal display on dashboard
func (s *ScalperStrategy) dashUpdateMLSignal(asset, side string, price decimal.Decimal, probRev float64, edge, ev, signal string) {
	if s.dash != nil {
		s.dash.UpdateMLSignal(asset, side, price, probRev, edge, ev, signal)
	}
}

================================================================================
FILE: internal/arbitrage/clob.go
================================================================================
// Package arbitrage provides latency arbitrage functionality
//
// clob.go - Polymarket CLOB trading client
// Handles order placement, cancellation, and position management.
// Requires API key and wallet private key for signing.
//
// Reference: https://docs.polymarket.com/
// Python client: https://github.com/Polymarket/py-clob-client
package arbitrage

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
)

// OrderSide represents buy or sell
type OrderSide string

const (
	OrderSideBuy  OrderSide = "BUY"
	OrderSideSell OrderSide = "SELL"
)

// OrderType represents the order type
type OrderType string

const (
	OrderTypeGTC OrderType = "GTC" // Good til cancelled
	OrderTypeFOK OrderType = "FOK" // Fill or kill
	OrderTypeGTD OrderType = "GTD" // Good til date
)

// Order represents a CLOB order
type Order struct {
	TokenID    string          `json:"tokenID"`
	Price      decimal.Decimal `json:"price"`
	Size       decimal.Decimal `json:"size"`
	Side       OrderSide       `json:"side"`
	OrderType  OrderType       `json:"type"`
	Expiration int64           `json:"expiration,omitempty"`
}

// OrderResponse from CLOB API
type OrderResponse struct {
	OrderID   string `json:"orderID"`
	Status    string `json:"status"`
	TxHash    string `json:"transactionHash,omitempty"`
	ErrorCode string `json:"errorCode,omitempty"`
	Message   string `json:"message,omitempty"`
}

// Position represents an open position
type Position struct {
	TokenID  string          `json:"asset"`
	Size     decimal.Decimal `json:"size"`
	AvgPrice decimal.Decimal `json:"avgPrice"`
	Side     OrderSide       `json:"side"`
}

// BalanceAllowance represents the balance/allowance response
type BalanceAllowance struct {
	Balance   string `json:"balance"`
	Allowance string `json:"allowance"`
}

// TradeRecord represents a trade from history
type TradeRecord struct {
	ID              string `json:"id"`
	TakerOrderID    string `json:"taker_order_id"`
	Market          string `json:"market"`
	AssetID         string `json:"asset_id"`
	Side            string `json:"side"`
	Size            string `json:"size"`
	FeeRateBps      string `json:"fee_rate_bps"`
	Price           string `json:"price"`
	Status          string `json:"status"`
	MatchTime       string `json:"match_time"`
	LastUpdate      string `json:"last_update"`
	Outcome         string `json:"outcome"`
	BucketIndex     int    `json:"bucket_index"`
	Owner           string `json:"owner"`
	MakerAddress    string `json:"maker_address"`
	TransactionHash string `json:"transaction_hash"`
	TraderSide      string `json:"trader_side"`
	Type            string `json:"type"`
}

// CLOBClient handles trading on Polymarket CLOB
type CLOBClient struct {
	baseURL       string
	apiKey        string
	apiSecret     string
	passphrase    string
	privateKey    *ecdsa.PrivateKey
	address       common.Address // Signing address
	funderAddress common.Address // Address that holds funds (may differ for proxy wallets)
	httpClient    *http.Client
	signatureType int // 0=EOA, 1=Magic/Email, 2=Proxy
}

// ApiCreds represents derived API credentials
type ApiCreds struct {
	ApiKey     string `json:"apiKey"`
	Secret     string `json:"secret"`
	Passphrase string `json:"passphrase"`
}

// NewCLOBClient creates a new CLOB trading client
// If apiKey/apiSecret are empty but walletPrivateKey is provided, credentials will be derived
func NewCLOBClient(apiKey, apiSecret, passphrase, walletPrivateKey, signerAddress, funderAddress string, signatureType int) (*CLOBClient, error) {
	client := &CLOBClient{
		baseURL:       "https://clob.polymarket.com",
		apiKey:        apiKey,
		apiSecret:     apiSecret,
		passphrase:    passphrase,
		httpClient:    &http.Client{Timeout: 2 * time.Second}, // ‚ö° FAST timeout - 2s max
		signatureType: signatureType,
	}

	// Set signer address if provided (needed for API auth headers)
	if signerAddress != "" {
		client.address = common.HexToAddress(signerAddress)
	}

	// Set funder address if provided
	if funderAddress != "" {
		client.funderAddress = common.HexToAddress(funderAddress)
	}

	// Parse wallet private key if provided
	if walletPrivateKey != "" {
		// Remove 0x prefix if present
		if len(walletPrivateKey) > 2 && walletPrivateKey[:2] == "0x" {
			walletPrivateKey = walletPrivateKey[2:]
		}
		pk, err := crypto.HexToECDSA(walletPrivateKey)
		if err != nil {
			return nil, fmt.Errorf("invalid private key: %w", err)
		}
		client.privateKey = pk
		client.address = crypto.PubkeyToAddress(pk.PublicKey)
		
		// Set funder address (defaults to signing address if not specified)
		if funderAddress != "" {
			log.Info().
				Str("signer", client.address.Hex()).
				Str("funder", client.funderAddress.Hex()).
				Int("sig_type", signatureType).
				Msg("Wallet loaded (proxy mode)")
		} else {
			client.funderAddress = client.address
			log.Info().Str("address", client.address.Hex()).Msg("Wallet loaded")
		}

		// If no API credentials provided, derive them
		if apiKey == "" || apiSecret == "" {
			log.Info().Msg("Deriving API credentials from wallet...")
			creds, err := client.deriveApiCreds()
			if err != nil {
				return nil, fmt.Errorf("failed to derive API credentials: %w", err)
			}
			client.apiKey = creds.ApiKey
			client.apiSecret = creds.Secret
			client.passphrase = creds.Passphrase
			log.Info().Str("api_key", creds.ApiKey[:20]+"...").Msg("API credentials derived successfully")
		}
	} else if apiKey != "" && apiSecret != "" {
		// No private key but we have pre-derived credentials
		log.Info().
			Str("signer", signerAddress).
			Str("funder", funderAddress).
			Msg("CLOB client with pre-derived credentials")
	}

	if client.apiKey == "" || client.apiSecret == "" {
		return nil, fmt.Errorf("wallet private key required (add WALLET_PRIVATE_KEY to .env)")
	}

	if client.address == (common.Address{}) {
		return nil, fmt.Errorf("signer address required (add SIGNER_ADDRESS to .env)")
	}

	return client, nil
}

// GetBalance returns USDC balance from Polymarket
func (c *CLOBClient) GetBalance() (decimal.Decimal, error) {
	// Endpoint: /balance-allowance?asset_type=COLLATERAL&signature_type=0
	endpoint := "/balance-allowance"
	sigType := c.signatureType
	
	url := fmt.Sprintf("%s%s?asset_type=COLLATERAL&signature_type=%d", c.baseURL, endpoint, sigType)
	
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return decimal.Zero, err
	}

	c.signL2Request(req, "GET", endpoint, nil)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return decimal.Zero, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return decimal.Zero, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	var result BalanceAllowance
	if err := json.Unmarshal(body, &result); err != nil {
		return decimal.Zero, fmt.Errorf("parse error: %w, body: %s", err, string(body))
	}

	balance, err := decimal.NewFromString(result.Balance)
	if err != nil {
		return decimal.Zero, fmt.Errorf("invalid balance value: %s", result.Balance)
	}

	// Balance is in wei (6 decimals for USDC)
	return balance.Div(decimal.NewFromInt(1000000)), nil
}

// GetTrades returns trade history
func (c *CLOBClient) GetTrades() ([]TradeRecord, error) {
	endpoint := "/data/trades"
	url := fmt.Sprintf("%s%s", c.baseURL, endpoint)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	c.signL2Request(req, "GET", endpoint, nil)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	// Response format: {"data": [...], "next_cursor": "..."}
	var result struct {
		Data       []TradeRecord `json:"data"`
		NextCursor string        `json:"next_cursor"`
	}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("parse error: %w", err)
	}

	return result.Data, nil
}

// GetPositions returns current positions (open orders)
func (c *CLOBClient) GetPositions() ([]Position, error) {
	// Polymarket doesn't have a direct positions endpoint
	// We can get open orders instead
	endpoint := "/data/orders"
	url := fmt.Sprintf("%s%s", c.baseURL, endpoint)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	c.signL2Request(req, "GET", endpoint, nil)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	// Response format: {"data": [...], "next_cursor": "..."}
	var result struct {
		Data []struct {
			Asset    string `json:"asset_id"`
			Side     string `json:"side"`
			Size     string `json:"original_size"`
			Price    string `json:"price"`
			Status   string `json:"status"`
			OrderID  string `json:"id"`
			SizeFill string `json:"size_matched"`
		} `json:"data"`
	}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("parse error: %w", err)
	}

	positions := make([]Position, 0)
	for _, order := range result.Data {
		size, _ := decimal.NewFromString(order.Size)
		price, _ := decimal.NewFromString(order.Price)
		
		side := OrderSideBuy
		if order.Side == "SELL" {
			side = OrderSideSell
		}
		
		positions = append(positions, Position{
			TokenID:  order.Asset,
			Size:     size,
			AvgPrice: price,
			Side:     side,
		})
	}

	return positions, nil
}

// PlaceOrder places a limit order on the CLOB
func (c *CLOBClient) PlaceOrder(order Order) (*OrderResponse, error) {
	if c.apiKey == "" {
		return nil, fmt.Errorf("API key required")
	}

	// Build order payload
	payload := map[string]interface{}{
		"tokenID":    order.TokenID,
		"price":      order.Price.String(),
		"size":       order.Size.String(),
		"side":       order.Side,
		"type":       order.OrderType,
		"feeRateBps": "1000",
	}

	if order.Expiration > 0 {
		payload["expiration"] = order.Expiration
	}

	body, _ := json.Marshal(payload)

	req, err := http.NewRequest("POST", c.baseURL+"/order", bytes.NewReader(body))
	if err != nil {
		return nil, err
	}

	c.signL2Request(req, "POST", "/order", body)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("order failed (HTTP %d): %s", resp.StatusCode, string(respBody))
	}

	var orderResp OrderResponse
	if err := json.Unmarshal(respBody, &orderResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w, body: %s", err, string(respBody))
	}

	return &orderResp, nil
}

// PlaceMarketBuy places a market buy order using native Go EIP-712 signing
func (c *CLOBClient) PlaceMarketBuy(tokenID string, size decimal.Decimal) (*OrderResponse, error) {
	return c.placeOrder(tokenID, SideBuy, size, decimal.Zero) // Zero = fetch price
}

// PlaceMarketSell places a market sell order using native Go EIP-712 signing
func (c *CLOBClient) PlaceMarketSell(tokenID string, size decimal.Decimal) (*OrderResponse, error) {
	return c.placeOrder(tokenID, SideSell, size, decimal.Zero) // Zero = fetch price
}

// PlaceMarketBuyAtPrice places a market buy WITHOUT fetching price again (FAST!)
func (c *CLOBClient) PlaceMarketBuyAtPrice(tokenID string, size decimal.Decimal, marketPrice decimal.Decimal) (*OrderResponse, error) {
	return c.placeOrder(tokenID, SideBuy, size, marketPrice)
}

// PlaceMarketSellAtPrice places a market sell WITHOUT fetching price again (FAST!)
func (c *CLOBClient) PlaceMarketSellAtPrice(tokenID string, size decimal.Decimal, marketPrice decimal.Decimal) (*OrderResponse, error) {
	return c.placeOrder(tokenID, SideSell, size, marketPrice)
}

// SellSharesAtPrice sells a specific number of shares at a given price
// Unlike PlaceMarketSell, this does NOT convert dollars to shares - it uses shares directly
func (c *CLOBClient) SellSharesAtPrice(tokenID string, shares decimal.Decimal, exitPrice decimal.Decimal) (*OrderResponse, error) {
	start := time.Now()

	// For sells, use AGGRESSIVE slippage to ensure fill in fast markets
	// Problem: TP triggers at 70¬¢, but price drops to 50¬¢ before order executes
	// Solution: Set sell price LOW enough to guarantee fill
	// 
	// Slippage strategy:
	// - For high prices (>50¬¢): use 15% slippage (70¬¢ ‚Üí sell at 60¬¢)
	// - For low prices (<50¬¢): use 20% slippage (30¬¢ ‚Üí sell at 24¬¢)
	// This ensures we get SOME profit rather than missing the exit entirely
	
	var price decimal.Decimal
	fiftyPercent := decimal.NewFromFloat(0.50)
	
	if exitPrice.GreaterThan(fiftyPercent) {
		// High price - 15% slippage
		slippage := exitPrice.Mul(decimal.NewFromFloat(0.15))
		price = exitPrice.Sub(slippage)
	} else {
		// Low price - 20% slippage  
		slippage := exitPrice.Mul(decimal.NewFromFloat(0.20))
		price = exitPrice.Sub(slippage)
	}
	
	// Minimum price floor
	if price.LessThan(decimal.NewFromFloat(0.01)) {
		price = decimal.NewFromFloat(0.01)
	}

	// For SELLS: sell what we own, no minimum (unlike buys which need 5 min)
	// Just ensure at least some shares to sell
	if shares.LessThanOrEqual(decimal.Zero) {
		return nil, fmt.Errorf("cannot sell 0 or negative shares")
	}

	// Round shares to 2 decimal places
	shares = shares.Round(2)

	// Create order signer
	signer := NewOrderSigner(c.privateKey, c.address, c.funderAddress, c.signatureType)

	// Create and sign order with actual share count
	signedOrder, err := signer.CreateSignedOrder(tokenID, SideSell, price, shares)
	if err != nil {
		return nil, fmt.Errorf("failed to sign sell order: %w", err)
	}

	signTime := time.Since(start)

	log.Info().
		Str("token", tokenID[:20]+"...").
		Str("side", "SELL").
		Str("shares", shares.String()).
		Str("price", price.String()).
		Str("exit_price", exitPrice.String()).
		Dur("sign_time_ms", signTime).
		Msg("‚ö° SELL order signed (shares)")

	// Submit order to CLOB
	return c.submitSignedOrder(signedOrder)
}

// placeOrder places an order using native Go EIP-712 signing (fast!)
// If marketPrice is provided (non-zero), skip the odds fetch for speed
// NOTE: size is in DOLLARS for market orders, will be converted to shares
func (c *CLOBClient) placeOrder(tokenID string, side int, sizeInDollars decimal.Decimal, marketPrice decimal.Decimal) (*OrderResponse, error) {
	start := time.Now()

	var price decimal.Decimal
	
	// ‚ö° SPEED: If price already provided, skip the API call
	if !marketPrice.IsZero() {
		if side == SideBuy {
			// Add 3% slippage to ensure fill
			slippage := decimal.NewFromFloat(0.03)
			price = marketPrice.Add(slippage)
			if price.GreaterThan(decimal.NewFromFloat(0.99)) {
				price = decimal.NewFromFloat(0.99)
			}
		} else {
			// Subtract 3% for sells
			slippage := decimal.NewFromFloat(0.03)
			price = marketPrice.Sub(slippage)
			if price.LessThan(decimal.NewFromFloat(0.01)) {
				price = decimal.NewFromFloat(0.01)
			}
		}
	} else {
		// Fetch current best price (slower)
		fetcher := NewOddsFetcher()
		odds, err := fetcher.GetLiveOdds(tokenID)
		if err != nil {
			return nil, fmt.Errorf("failed to get odds: %w", err)
		}

		if side == SideBuy {
			slippage := decimal.NewFromFloat(0.03)
			price = odds.BestAsk.Add(slippage)
			if price.GreaterThan(decimal.NewFromFloat(0.99)) {
				price = decimal.NewFromFloat(0.99)
			}
		} else {
			slippage := decimal.NewFromFloat(0.03)
			price = odds.BestBid.Sub(slippage)
			if price.LessThan(decimal.NewFromFloat(0.01)) {
				price = decimal.NewFromFloat(0.01)
			}
		}
	}

	// Create order signer
	signer := NewOrderSigner(c.privateKey, c.address, c.funderAddress, c.signatureType)

	// Convert dollar amount to shares: shares = dollars / price
	// For a $1 order at 44¬¢, that's 1 / 0.44 = 2.27 shares
	size := sizeInDollars.Div(price)
	
	// Polymarket minimum is 5 shares for limit orders
	// For FOK orders we can go lower but let's ensure at least $1 worth
	minShares := decimal.NewFromInt(5)
	if size.LessThan(minShares) {
		size = minShares
	}
	
	// Round to reasonable precision (avoid dust)
	size = size.Round(2)

	// Create and sign order
	signedOrder, err := signer.CreateSignedOrder(tokenID, side, price, size)
	if err != nil {
		return nil, fmt.Errorf("failed to sign order: %w", err)
	}

	// Log timing
	signTime := time.Since(start)

	sideStr := "BUY"
	if side == SideSell {
		sideStr = "SELL"
	}

	log.Info().
		Str("token", tokenID[:20]+"...").
		Str("side", sideStr).
		Str("dollars", sizeInDollars.String()).
		Str("shares", size.String()).
		Str("price", price.String()).
		Dur("sign_time_ms", signTime).
		Msg("‚ö° Order signed (native Go)")

	// Submit order to CLOB
	return c.submitSignedOrder(signedOrder)
}

// submitSignedOrder posts a signed order to the CLOB API (defaults to FOK)
func (c *CLOBClient) submitSignedOrder(signedOrder *SignedCTFOrder) (*OrderResponse, error) {
	return c.submitSignedOrderWithType(signedOrder, "FOK")
}

// submitSignedOrderWithType posts a signed order with a specific order type
func (c *CLOBClient) submitSignedOrderWithType(signedOrder *SignedCTFOrder, orderType string) (*OrderResponse, error) {
	start := time.Now()

	// Build request payload - owner must be API key!
	payload := signedOrder.ToAPIPayloadWithType(c.apiKey, orderType)
	body, err := json.Marshal(payload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal order: %w", err)
	}

	// DEBUG: Log the full payload being sent
	log.Debug().
		RawJSON("request_payload", body).
		Msg("üì§ Sending order to CLOB API")

	// Create request
	req, err := http.NewRequest("POST", c.baseURL+"/order", bytes.NewReader(body))
	if err != nil {
		return nil, err
	}

	// Add L2 auth headers
	c.signL2Request(req, "POST", "/order", body)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	log.Debug().
		Int("status", resp.StatusCode).
		Dur("api_time_ms", time.Since(start)).
		RawJSON("response", respBody).
		Msg("CLOB API response")

	var orderResp OrderResponse
	if err := json.Unmarshal(respBody, &orderResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w, body: %s", err, string(respBody))
	}

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		// Log full response for debugging
		log.Error().
			Int("status", resp.StatusCode).
			Str("error_code", orderResp.ErrorCode).
			Str("message", orderResp.Message).
			Str("raw_body", string(respBody)).
			Msg("‚ùå CLOB API order rejected")
		return &orderResp, fmt.Errorf("order failed (HTTP %d): %s - %s | raw: %s", resp.StatusCode, orderResp.ErrorCode, orderResp.Message, string(respBody))
	}

	log.Info().
		Str("order_id", orderResp.OrderID).
		Str("status", orderResp.Status).
		Msg("‚úÖ Order submitted successfully")

	return &orderResp, nil
}

// PlaceLimitOrder places a limit order with aggressive pricing for fast fills
// Uses FOK (Fill Or Kill) - order must fill immediately or is cancelled
// Returns the order ID for tracking
func (c *CLOBClient) PlaceLimitOrder(tokenID string, price, size decimal.Decimal, side string) (string, error) {
	sideInt := SideBuy
	if side == "SELL" {
		sideInt = SideSell
	}

	// Round price to valid tick size (0.01 for all prices on Polymarket)
	tickSize := decimal.NewFromFloat(0.01)
	
	// Add slippage for faster fills:
	// BUY: Pay slightly MORE to be at front of queue
	// SELL: Accept MORE slippage to guarantee fill in fast markets
	
	if sideInt == SideBuy {
		// Round DOWN base price, then ADD slippage
		price = price.Div(tickSize).Floor().Mul(tickSize)
		slippage := decimal.NewFromFloat(0.02) // 2¬¢ slippage for BUY
		price = price.Add(slippage)
	} else {
		// SELL needs MORE aggressive slippage to ensure exit
		// Round DOWN (not up) and subtract more
		price = price.Div(tickSize).Floor().Mul(tickSize)
		slippage := decimal.NewFromFloat(0.03) // 3¬¢ slippage for SELL
		price = price.Sub(slippage)
		if price.LessThan(tickSize) {
			price = tickSize // Minimum 1¬¢
		}
	}

	// Ensure minimum size of 5 shares (Polymarket requirement)
	minSize := decimal.NewFromInt(5)
	if size.LessThan(minSize) {
		size = minSize
	}

	// Create order signer
	signer := NewOrderSigner(c.privateKey, c.address, c.funderAddress, c.signatureType)

	// Create and sign order at exact price (no slippage for limit orders)
	signedOrder, err := signer.CreateSignedOrder(tokenID, sideInt, price, size)
	if err != nil {
		return "", fmt.Errorf("failed to sign order: %w", err)
	}

	log.Info().
		Str("token", tokenID[:20]+"...").
		Str("side", side).
		Str("size", size.String()).
		Str("price", price.String()).
		Msg("‚ö° Order signed (native Go)")

	// Submit as FAK (Fill And Kill) - fills what it can immediately, cancels rest
	// Better than FOK because it allows partial fills
	// Better than GTC because unfilled portion is cancelled (no ghost orders)
	resp, err := c.submitSignedOrderWithType(signedOrder, "FAK")
	if err != nil {
		return "", err
	}

	if resp.OrderID == "" {
		return "", fmt.Errorf("no order ID returned: %s", resp.Message)
	}

	log.Info().
		Str("order_id", resp.OrderID).
		Str("token_id", tokenID[:16]+"...").
		Str("price", price.String()).
		Str("size", size.String()).
		Str("side", side).
		Str("type", "FAK").
		Msg("üìã Order placed (Fill-And-Kill)")

	return resp.OrderID, nil
}

// GetOrderStatus checks the status of an order
func (c *CLOBClient) GetOrderStatus(orderID string) (status string, filledSize, filledPrice decimal.Decimal, err error) {
	req, err := http.NewRequest("GET", c.baseURL+"/order/"+orderID, nil)
	if err != nil {
		return "", decimal.Zero, decimal.Zero, err
	}

	c.signL2Request(req, "GET", "/order/"+orderID, nil)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return "", decimal.Zero, decimal.Zero, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	var orderInfo struct {
		OrderID     string `json:"order_id"`
		Status      string `json:"status"` // "live", "matched", "cancelled"
		SizeFilled  string `json:"size_filled"`
		PriceFilled string `json:"price_filled"`
	}

	if err := json.Unmarshal(respBody, &orderInfo); err != nil {
		return "", decimal.Zero, decimal.Zero, err
	}

	filledSize, _ = decimal.NewFromString(orderInfo.SizeFilled)
	filledPrice, _ = decimal.NewFromString(orderInfo.PriceFilled)

	return orderInfo.Status, filledSize, filledPrice, nil
}

// CancelOrder cancels an open order
func (c *CLOBClient) CancelOrder(orderID string) error {
	body := []byte(fmt.Sprintf(`{"orderID":"%s"}`, orderID))
	
	req, err := http.NewRequest("DELETE", c.baseURL+"/order", bytes.NewReader(body))
	if err != nil {
		return err
	}

	c.signL2Request(req, "DELETE", "/order", body)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		respBody, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("cancel failed: %s", string(respBody))
	}

	return nil
}

// GetOpenOrders returns all open orders
func (c *CLOBClient) GetOpenOrders() ([]Order, error) {
	endpoint := "/data/orders"
	req, err := http.NewRequest("GET", c.baseURL+endpoint, nil)
	if err != nil {
		return nil, err
	}

	c.signL2Request(req, "GET", endpoint, nil)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	var result struct {
		Data []Order `json:"data"`
	}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// signL2Request adds Level 2 authentication headers
// Based on: https://github.com/Polymarket/py-clob-client/blob/main/py_clob_client/signing/hmac.py
func (c *CLOBClient) signL2Request(req *http.Request, method, path string, body []byte) {
	timestamp := strconv.FormatInt(time.Now().Unix(), 10)

	// Build message to sign: timestamp + method + requestPath + body
	// Must match exactly what py-clob-client does
	message := timestamp + method + path
	if body != nil && len(body) > 0 {
		message += string(body)
	}

	// Decode secret using URL-safe base64 (py-clob-client uses urlsafe_b64decode)
	secretBytes, err := base64.URLEncoding.DecodeString(c.apiSecret)
	if err != nil {
		// Try with padding
		padded := c.apiSecret
		if len(padded)%4 != 0 {
			padded += strings.Repeat("=", 4-len(padded)%4)
		}
		secretBytes, err = base64.URLEncoding.DecodeString(padded)
		if err != nil {
			// Last resort: try standard base64
			secretBytes, _ = base64.StdEncoding.DecodeString(c.apiSecret)
		}
	}

	// HMAC-SHA256 signature
	h := hmac.New(sha256.New, secretBytes)
	h.Write([]byte(message))
	// URL-safe base64 encode the result (py-clob-client uses urlsafe_b64encode)
	signature := base64.URLEncoding.EncodeToString(h.Sum(nil))

	// Set headers - Polymarket uses UNDERSCORES not hyphens!
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("POLY_API_KEY", c.apiKey)
	req.Header.Set("POLY_SIGNATURE", signature)
	req.Header.Set("POLY_TIMESTAMP", timestamp)
	req.Header.Set("POLY_PASSPHRASE", c.passphrase)

	// POLY_ADDRESS must be the SIGNER address (not funder!)
	// The signer is the address that derives the API credentials
	if c.address != (common.Address{}) {
		req.Header.Set("POLY_ADDRESS", c.address.Hex())
	}
}

// TestConnection verifies API connectivity
func (c *CLOBClient) TestConnection() error {
	req, err := http.NewRequest("GET", c.baseURL+"/time", nil)
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("connection failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	log.Info().Msg("‚úÖ CLOB API connection verified")
	return nil
}

// GetAddress returns the wallet address (for display purposes)
func (c *CLOBClient) GetAddress() string {
	if c.address != (common.Address{}) {
		return c.address.Hex()
	}
	return ""
}

// PrivateKey returns the private key (for signing)
func (c *CLOBClient) PrivateKey() *ecdsa.PrivateKey {
	return c.privateKey
}

// Address returns the signing address
func (c *CLOBClient) Address() common.Address {
	return c.address
}

// FunderAddress returns the funder address
func (c *CLOBClient) FunderAddress() common.Address {
	return c.funderAddress
}

// ApiKey returns the API key
func (c *CLOBClient) ApiKey() string {
	return c.apiKey
}

// Legacy function for backward compatibility
func (c *CLOBClient) signRequest(req *http.Request, body []byte) {
	timestamp := strconv.FormatInt(time.Now().UnixMilli(), 10)

	signPayload := timestamp + req.Method + req.URL.Path
	if body != nil {
		signPayload += string(body)
	}

	h := hmac.New(sha256.New, []byte(c.apiSecret))
	h.Write([]byte(signPayload))
	signature := hex.EncodeToString(h.Sum(nil))

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("POLY_API_KEY", c.apiKey)
	req.Header.Set("POLY_SIGNATURE", signature)
	req.Header.Set("POLY_TIMESTAMP", timestamp)
	req.Header.Set("POLY_PASSPHRASE", c.passphrase)

	if c.address != (common.Address{}) {
		req.Header.Set("POLY_ADDRESS", c.address.Hex())
	}
}

// deriveApiCreds derives API credentials from the wallet by signing a message
// This calls the CLOB API to create or get existing credentials
func (c *CLOBClient) deriveApiCreds() (*ApiCreds, error) {
	if c.privateKey == nil {
		return nil, fmt.Errorf("wallet private key required")
	}

	// First try to derive existing creds
	creds, err := c.createOrDeriveCreds()
	if err != nil {
		return nil, err
	}

	return creds, nil
}

// createOrDeriveCreds creates or retrieves API credentials
func (c *CLOBClient) createOrDeriveCreds() (*ApiCreds, error) {
	timestamp := time.Now().Unix()
	nonce := int64(0)

	// Sign the CLOB auth message (EIP-712)
	signature, err := c.signClobAuthMessage(timestamp, nonce)
	if err != nil {
		return nil, fmt.Errorf("failed to sign auth message: %w", err)
	}

	// Build L1 headers for the derive request
	// Use funder address for POLY_ADDRESS (where funds are held)
	polyAddress := c.funderAddress.Hex()
	if polyAddress == "0x0000000000000000000000000000000000000000" {
		polyAddress = c.address.Hex()
	}

	headers := map[string]string{
		"POLY_ADDRESS":   polyAddress,
		"POLY_SIGNATURE": signature,
		"POLY_TIMESTAMP": strconv.FormatInt(timestamp, 10),
		"POLY_NONCE":     strconv.FormatInt(nonce, 10),
	}

	// Try to derive existing credentials first
	req, _ := http.NewRequest("GET", c.baseURL+"/auth/derive-api-key", nil)
	req.Header.Set("Content-Type", "application/json")
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("derive request failed: %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode == http.StatusOK {
		var creds ApiCreds
		if err := json.Unmarshal(body, &creds); err != nil {
			return nil, fmt.Errorf("failed to parse credentials: %w", err)
		}
		return &creds, nil
	}

	// If derive fails, try to create new credentials
	req, _ = http.NewRequest("POST", c.baseURL+"/auth/api-key", nil)
	req.Header.Set("Content-Type", "application/json")
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	resp, err = c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("create request failed: %w", err)
	}
	defer resp.Body.Close()

	body, _ = io.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	var creds ApiCreds
	if err := json.Unmarshal(body, &creds); err != nil {
		return nil, fmt.Errorf("failed to parse credentials: %w", err)
	}

	return &creds, nil
}

// signClobAuthMessage signs the CLOB authentication message using EIP-712
// Domain: {name: "ClobAuthDomain", version: "1", chainId: 137}
// Message: {address, timestamp, nonce, message: "This message attests that I control the given wallet"}
func (c *CLOBClient) signClobAuthMessage(timestamp int64, nonce int64) (string, error) {
	// EIP-712 Domain separator
	// keccak256("EIP712Domain(string name,string version,uint256 chainId)")
	domainTypeHash := crypto.Keccak256Hash([]byte("EIP712Domain(string name,string version,uint256 chainId)"))
	
	// Domain values
	nameHash := crypto.Keccak256Hash([]byte("ClobAuthDomain"))
	versionHash := crypto.Keccak256Hash([]byte("1"))
	chainId := big.NewInt(137) // Polygon
	
	// Encode domain separator
	domainSeparator := crypto.Keccak256Hash(
		domainTypeHash.Bytes(),
		nameHash.Bytes(),
		versionHash.Bytes(),
		common.LeftPadBytes(chainId.Bytes(), 32),
	)

	// ClobAuth type hash
	// keccak256("ClobAuth(address address,string timestamp,uint256 nonce,string message)")
	clobAuthTypeHash := crypto.Keccak256Hash([]byte("ClobAuth(address address,string timestamp,uint256 nonce,string message)"))

	// Use funder address for the auth message
	authAddress := c.funderAddress
	if authAddress == (common.Address{}) {
		authAddress = c.address
	}

	// Message values
	timestampStr := strconv.FormatInt(timestamp, 10)
	messageStr := "This message attests that I control the given wallet"

	// Encode struct
	structHash := crypto.Keccak256Hash(
		clobAuthTypeHash.Bytes(),
		common.LeftPadBytes(authAddress.Bytes(), 32),
		crypto.Keccak256Hash([]byte(timestampStr)).Bytes(),
		common.LeftPadBytes(big.NewInt(nonce).Bytes(), 32),
		crypto.Keccak256Hash([]byte(messageStr)).Bytes(),
	)

	// Final hash: keccak256("\x19\x01" + domainSeparator + structHash)
	rawData := append([]byte{0x19, 0x01}, domainSeparator.Bytes()...)
	rawData = append(rawData, structHash.Bytes()...)
	hash := crypto.Keccak256Hash(rawData)

	// Sign
	sig, err := crypto.Sign(hash.Bytes(), c.privateKey)
	if err != nil {
		return "", err
	}

	// Adjust V value for Ethereum compatibility
	if sig[64] < 27 {
		sig[64] += 27
	}

	return "0x" + hex.EncodeToString(sig), nil
}

// GetMidPrice fetches the mid price for a token from the CLOB orderbook
// This is faster than using the gamma API for price discovery
func (c *CLOBClient) GetMidPrice(tokenID string) (decimal.Decimal, error) {
	// Use the CLOB price endpoint for fast price lookup
	url := fmt.Sprintf("%s/price?token_id=%s&side=BUY", c.baseURL, tokenID)
	
	resp, err := c.httpClient.Get(url)
	if err != nil {
		return decimal.Zero, err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return decimal.Zero, fmt.Errorf("price lookup failed: %d", resp.StatusCode)
	}
	
	var result struct {
		Price string `json:"price"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return decimal.Zero, err
	}
	
	return decimal.NewFromString(result.Price)
}

// GetBookPrice fetches the best bid/ask from the orderbook for a token
func (c *CLOBClient) GetBookPrice(tokenID string) (bestBid, bestAsk decimal.Decimal, err error) {
	url := fmt.Sprintf("%s/book?token_id=%s", c.baseURL, tokenID)
	
	resp, err := c.httpClient.Get(url)
	if err != nil {
		return decimal.Zero, decimal.Zero, err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return decimal.Zero, decimal.Zero, fmt.Errorf("book lookup failed: %d", resp.StatusCode)
	}
	
	var result struct {
		Bids []struct {
			Price string `json:"price"`
			Size  string `json:"size"`
		} `json:"bids"`
		Asks []struct {
			Price string `json:"price"`
			Size  string `json:"size"`
		} `json:"asks"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return decimal.Zero, decimal.Zero, err
	}
	
	if len(result.Bids) > 0 {
		bestBid, _ = decimal.NewFromString(result.Bids[0].Price)
	}
	if len(result.Asks) > 0 {
		bestAsk, _ = decimal.NewFromString(result.Asks[0].Price)
	}
	
	return bestBid, bestAsk, nil
}


================================================================================
FILE: internal/arbitrage/odds.go
================================================================================
// Package arbitrage provides latency arbitrage functionality
//
// odds.go - Real-time odds fetching from Polymarket CLOB
// Fetches live bid/ask prices from the order book to ensure we're
// getting the actual tradeable prices, not stale API data.
package arbitrage

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
)

// CLOBBookEntry represents a single bid/ask entry
type CLOBBookEntry struct {
	Price string `json:"price"`
	Size  string `json:"size"`
}

// CLOBBook represents the order book from Polymarket CLOB
type CLOBBook struct {
	Market   string          `json:"market"`
	AssetID  string          `json:"asset_id"`
	Bids     []CLOBBookEntry `json:"bids"`
	Asks     []CLOBBookEntry `json:"asks"`
	Hash     string          `json:"hash"`
}

// LiveOdds represents current tradeable odds for a market
type LiveOdds struct {
	TokenID      string
	BestBid      decimal.Decimal // Best price to sell at
	BestAsk      decimal.Decimal // Best price to buy at
	BidSize      decimal.Decimal
	AskSize      decimal.Decimal
	Spread       decimal.Decimal
	SpreadPct    decimal.Decimal
	LastUpdated  time.Time
}

// OddsFetcher fetches real-time odds from Polymarket CLOB
type OddsFetcher struct {
	baseURL    string
	httpClient *http.Client
}

// NewOddsFetcher creates a new odds fetcher
func NewOddsFetcher() *OddsFetcher {
	return &OddsFetcher{
		baseURL: "https://clob.polymarket.com",
		httpClient: &http.Client{
			Timeout: 5 * time.Second,
		},
	}
}

// GetLiveOdds fetches the current order book for a token
func (f *OddsFetcher) GetLiveOdds(tokenID string) (*LiveOdds, error) {
	url := fmt.Sprintf("%s/book?token_id=%s", f.baseURL, tokenID)
	
	resp, err := f.httpClient.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch book: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("CLOB API returned status %d", resp.StatusCode)
	}

	var book CLOBBook
	if err := json.NewDecoder(resp.Body).Decode(&book); err != nil {
		return nil, fmt.Errorf("failed to decode book: %w", err)
	}

	odds := &LiveOdds{
		TokenID:     tokenID,
		LastUpdated: time.Now(),
	}

	// Parse best bid (highest buy order)
	if len(book.Bids) > 0 {
		odds.BestBid, _ = decimal.NewFromString(book.Bids[0].Price)
		odds.BidSize, _ = decimal.NewFromString(book.Bids[0].Size)
	}

	// Parse best ask (lowest sell order)
	if len(book.Asks) > 0 {
		odds.BestAsk, _ = decimal.NewFromString(book.Asks[0].Price)
		odds.AskSize, _ = decimal.NewFromString(book.Asks[0].Size)
	}

	// Calculate spread
	if !odds.BestBid.IsZero() && !odds.BestAsk.IsZero() {
		odds.Spread = odds.BestAsk.Sub(odds.BestBid)
		mid := odds.BestBid.Add(odds.BestAsk).Div(decimal.NewFromInt(2))
		if !mid.IsZero() {
			odds.SpreadPct = odds.Spread.Div(mid).Mul(decimal.NewFromInt(100))
		}
	}

	return odds, nil
}

// GetBothSideOdds fetches odds for both Up and Down tokens
func (f *OddsFetcher) GetBothSideOdds(upTokenID, downTokenID string) (*LiveOdds, *LiveOdds, error) {
	upOdds, err := f.GetLiveOdds(upTokenID)
	if err != nil {
		log.Warn().Err(err).Msg("Failed to fetch UP odds")
	}

	downOdds, err := f.GetLiveOdds(downTokenID)
	if err != nil {
		log.Warn().Err(err).Msg("Failed to fetch DOWN odds")
	}

	return upOdds, downOdds, nil
}

// GetMidPrice returns the mid-market price for a token
func (f *OddsFetcher) GetMidPrice(tokenID string) (decimal.Decimal, error) {
	odds, err := f.GetLiveOdds(tokenID)
	if err != nil {
		return decimal.Zero, err
	}

	if odds.BestBid.IsZero() || odds.BestAsk.IsZero() {
		return decimal.Zero, fmt.Errorf("no liquidity")
	}

	return odds.BestBid.Add(odds.BestAsk).Div(decimal.NewFromInt(2)), nil
}

// CheckArbitrageCondition checks if odds are favorable for arbitrage
// Returns true if the market odds are stale (still near 50/50 despite a price move)
func (f *OddsFetcher) CheckArbitrageCondition(tokenID string, expectedDirection string, threshold decimal.Decimal) (bool, *LiveOdds, error) {
	odds, err := f.GetLiveOdds(tokenID)
	if err != nil {
		return false, nil, err
	}

	// For buying, we care about the ask price (what we pay)
	// If ask is below threshold, odds are still cheap = opportunity
	if odds.BestAsk.LessThan(threshold) {
		return true, odds, nil
	}

	return false, odds, nil
}


================================================================================
FILE: internal/polymarket/window_scanner.go
================================================================================
// Package polymarket provides Polymarket API integration
//
// window_scanner.go - Scans for crypto prediction windows on Polymarket
// Searches for "Will [ASSET] go up/down in the next X minutes?" markets
// Asset is configurable via constructor (BTC, ETH, SOL, etc.)
package polymarket

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
)

// PredictionWindow represents a crypto up/down prediction window market
type PredictionWindow struct {
	ID            string
	ConditionID   string
	Question      string
	Slug          string
	Asset         string // BTC, ETH, SOL, etc.

	// Tokens
	YesTokenID string
	NoTokenID  string

	// Prices (YES = "Up", NO = "Down")
	YesPrice decimal.Decimal // Price for "Up" outcome
	NoPrice  decimal.Decimal // Price for "Down" outcome

	// Price to Beat - the reference price from Polymarket!
	PriceToBeat decimal.Decimal // Starting price for resolution
	CurrentPrice decimal.Decimal // Current price from Polymarket's feed

	// Market info
	Volume    decimal.Decimal
	Liquidity decimal.Decimal
	StartDate time.Time // Window start time (used to get "Price to Beat")
	EndDate   time.Time
	Active    bool
	Closed    bool

	// Parsed info
	WindowMinutes int    // 15, 60, etc.
	WindowType    string // "up_down", "price_range", etc.

	LastUpdated time.Time
}

// WindowScanner scans for crypto prediction window markets
type WindowScanner struct {
	client       *Client
	restURL      string
	asset        string // The asset to scan for (BTC, ETH, etc.)
	priceFetcher *CLOBPriceFetcher // For real-time CLOB prices
	wsClient     *WSClient         // WebSocket for real-time odds (FAST!)

	windows   []PredictionWindow
	windowsMu sync.RWMutex

	onNewWindow func(PredictionWindow)

	running bool
	stopCh  chan struct{}
}

// NewWindowScanner creates a new scanner for the given asset
func NewWindowScanner(apiURL string, asset string) *WindowScanner {
	return &WindowScanner{
		client:       NewClient(apiURL),
		restURL:      apiURL,
		asset:        strings.ToUpper(asset),
		windows:      make([]PredictionWindow, 0),
		stopCh:       make(chan struct{}),
		priceFetcher: NewCLOBPriceFetcher(), // Add CLOB price fetcher
	}
}

// SetNewWindowCallback sets callback for new windows
func (s *WindowScanner) SetNewWindowCallback(cb func(PredictionWindow)) {
	s.onNewWindow = cb
}

// SetWSClient sets the WebSocket client for real-time odds
func (s *WindowScanner) SetWSClient(ws *WSClient) {
	s.wsClient = ws
}

// Start begins scanning for prediction windows
func (s *WindowScanner) Start() {
	s.running = true
	go s.scanLoop()
	log.Info().Str("asset", s.asset).Msg("üîç Window Scanner started")
}

// Stop stops the scanner
func (s *WindowScanner) Stop() {
	s.running = false
	close(s.stopCh)
}

func (s *WindowScanner) scanLoop() {
	// Scan immediately
	s.scan()

	// Scan every 200ms for ULTRA-FAST odds detection - latency is everything!
	ticker := time.NewTicker(250 * time.Millisecond) // Scan windows every 250ms for FAST detection
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			s.scan()
		case <-s.stopCh:
			return
		}
	}
}

func (s *WindowScanner) scan() {
	windows, err := s.fetchWindows()
	if err != nil {
		log.Error().Err(err).Str("asset", s.asset).Msg("Failed to fetch windows")
		return
	}

	// CRITICAL: Fetch LIVE prices from WebSocket first (FASTEST!), fallback to CLOB REST
	for i := range windows {
		if windows[i].YesTokenID != "" && windows[i].NoTokenID != "" {
			// Try WebSocket first (instant, no network latency!)
			if s.wsClient != nil && s.wsClient.IsConnected() {
				upPrice, downPrice, ok := s.wsClient.GetMarketPrices(windows[i].YesTokenID, windows[i].NoTokenID)
				if ok && !upPrice.IsZero() {
					windows[i].YesPrice = upPrice
					windows[i].NoPrice = downPrice
					// Subscribe if not already (for future updates)
					s.wsClient.Subscribe(windows[i].ConditionID, windows[i].YesTokenID, windows[i].NoTokenID)
					continue // Got WS price, skip REST
				}
				// No WS price yet - subscribe for next time
				s.wsClient.Subscribe(windows[i].ConditionID, windows[i].YesTokenID, windows[i].NoTokenID)
			}
			
			// Fallback to REST (slower, only if WS didn't have price)
			upPrice, downPrice, err := s.priceFetcher.GetLivePrices(windows[i].YesTokenID, windows[i].NoTokenID)
			if err == nil && !upPrice.IsZero() {
				windows[i].YesPrice = upPrice
				windows[i].NoPrice = downPrice
			}
		}
	}

	log.Debug().Int("found", len(windows)).Str("asset", s.asset).Msg("üîç Windows scan complete")

	s.windowsMu.Lock()
	oldWindows := make(map[string]bool)
	for _, w := range s.windows {
		oldWindows[w.ID] = true
	}

	s.windows = windows
	s.windowsMu.Unlock()

	// Notify about new windows
	for _, w := range windows {
		if !oldWindows[w.ID] && s.onNewWindow != nil {
			s.onNewWindow(w)
		}
		// Log each window found
		log.Debug().
			Str("id", w.ID).
			Str("question", w.Question[:min(50, len(w.Question))]).
			Str("up", w.YesPrice.String()).
			Str("down", w.NoPrice.String()).
			Msg("üìä Window")
	}

	log.Debug().Int("windows", len(windows)).Str("asset", s.asset).Msg("Windows updated")
}

func (s *WindowScanner) fetchWindows() ([]PredictionWindow, error) {
	// Polymarket crypto windows use timestamp-based slugs:
	// btc-updown-15m-{timestamp} where timestamp is Unix time aligned to the window interval
	// Example: btc-updown-15m-1767707100 for the 15-minute window starting at that time

	now := time.Now().Unix()
	allWindows := make([]PredictionWindow, 0)
	seen := make(map[string]bool)

	// Window types: (prefix, interval in seconds)
	windowTypes := []struct {
		suffix   string
		interval int64
	}{
		{"5m", 300},    // 5 minutes
		{"15m", 900},   // 15 minutes
		{"1h", 3600},   // 1 hour
		{"4h", 14400},  // 4 hours
	}

	// Asset slug prefixes
	assetPrefix := strings.ToLower(s.asset) + "-updown"

	for _, wt := range windowTypes {
		// Calculate current window timestamp (aligned to interval)
		windowTs := (now / wt.interval) * wt.interval
		slug := fmt.Sprintf("%s-%s-%d", assetPrefix, wt.suffix, windowTs)

		window, err := s.fetchWindowBySlug(slug)
		if err != nil {
			log.Debug().Str("slug", slug).Err(err).Msg("Window not found")
			continue
		}

		if window != nil && !seen[window.ID] {
			seen[window.ID] = true
			allWindows = append(allWindows, *window)
		}
	}

	return allWindows, nil
}

// fetchWindowBySlug fetches a single window by its slug from gamma API
func (s *WindowScanner) fetchWindowBySlug(slug string) (*PredictionWindow, error) {
	// Use gamma-api.polymarket.com/events endpoint
	eventsURL := fmt.Sprintf("https://gamma-api.polymarket.com/events?slug=%s", slug)

	resp, err := http.Get(eventsURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var events []struct {
		ID             string `json:"id"`
		Title          string `json:"title"`
		Slug           string `json:"slug"`
		Description    string `json:"description"` // Contains price to beat info!
		Active         bool   `json:"active"`
		Closed         bool   `json:"closed"`
		EndDate        string `json:"endDate"`
		StartTime      string `json:"startTime"`      // Event start time (when window opens)
		EventStartTime string `json:"eventStartTime"` // Alternative field name
		Markets []struct {
			ID             string `json:"id"`
			ConditionID    string `json:"conditionId"`
			Question       string `json:"question"`
			Description    string `json:"description"` // May contain current price info
			Outcomes       string `json:"outcomes"`
			OutcomePrices  string `json:"outcomePrices"`
			ClobTokenIds   string `json:"clobTokenIds"`
			Volume         string `json:"volume"`
			EventStartTime string `json:"eventStartTime"` // Market-level start time
		} `json:"markets"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&events); err != nil {
		return nil, err
	}

	if len(events) == 0 || len(events[0].Markets) == 0 {
		return nil, nil
	}

	event := events[0]
	market := event.Markets[0]

	// Skip markets with no prices (no liquidity)
	if market.OutcomePrices == "" || market.OutcomePrices == "null" {
		return nil, nil
	}

	// Parse outcomes ["Up", "Down"]
	var outcomes []string
	if err := json.Unmarshal([]byte(market.Outcomes), &outcomes); err != nil {
		return nil, err
	}

	// Parse prices ["0.51", "0.49"]
	var prices []string
	if err := json.Unmarshal([]byte(market.OutcomePrices), &prices); err != nil {
		return nil, err
	}

	// Parse token IDs
	var tokenIDs []string
	if err := json.Unmarshal([]byte(market.ClobTokenIds), &tokenIDs); err != nil {
		return nil, err
	}

	if len(prices) < 2 || len(tokenIDs) < 2 {
		return nil, nil
	}

	yesPrice, _ := decimal.NewFromString(prices[0])
	noPrice, _ := decimal.NewFromString(prices[1])
	volume, _ := decimal.NewFromString(market.Volume)

	// Parse end date
	var endDate time.Time
	if event.EndDate != "" {
		endDate, _ = time.Parse(time.RFC3339, event.EndDate)
	}

	// Parse start date (event start time = when window opens)
	var startDate time.Time
	if market.EventStartTime != "" {
		startDate, _ = time.Parse(time.RFC3339, market.EventStartTime)
	} else if event.StartTime != "" {
		startDate, _ = time.Parse(time.RFC3339, event.StartTime)
	} else if event.EventStartTime != "" {
		startDate, _ = time.Parse(time.RFC3339, event.EventStartTime)
	}

	// Detect window minutes from slug
	windowMinutes := 15
	if strings.Contains(slug, "-5m-") {
		windowMinutes = 5
	} else if strings.Contains(slug, "-1h-") {
		windowMinutes = 60
	} else if strings.Contains(slug, "-4h-") {
		windowMinutes = 240
	}

	// Extract price to beat from description
	// Format: "Price to beat: $90,385.67" or similar
	priceToBeat := s.extractPriceToBeat(event.Description + " " + market.Description)

	return &PredictionWindow{
		ID:            market.ID,
		ConditionID:   market.ConditionID,
		Question:      event.Title,
		Slug:          event.Slug,
		Asset:         s.asset,
		YesTokenID:    tokenIDs[0], // Up token
		NoTokenID:     tokenIDs[1], // Down token
		YesPrice:      yesPrice,
		NoPrice:       noPrice,
		PriceToBeat:   priceToBeat,
		Volume:        volume,
		StartDate:     startDate,
		EndDate:       endDate,
		Active:        event.Active,
		Closed:        event.Closed,
		WindowMinutes: windowMinutes,
		WindowType:    "up_down",
		LastUpdated:   time.Now(),
	}, nil
}

// matchesAsset checks if a question matches the scanner's asset
func (s *WindowScanner) matchesAsset(questionLower string) bool {
	switch s.asset {
	case "BTC":
		return strings.Contains(questionLower, "bitcoin") || strings.Contains(questionLower, "btc")
	case "ETH":
		return strings.Contains(questionLower, "ethereum") || strings.Contains(questionLower, "eth")
	case "SOL":
		return strings.Contains(questionLower, "solana") || strings.Contains(questionLower, "sol")
	default:
		return strings.Contains(questionLower, strings.ToLower(s.asset))
	}
}

// GetActiveWindows returns currently active prediction windows with REAL-TIME WebSocket prices
func (s *WindowScanner) GetActiveWindows() []PredictionWindow {
	s.windowsMu.RLock()
	defer s.windowsMu.RUnlock()

	active := make([]PredictionWindow, 0)
	now := time.Now()

	for _, w := range s.windows {
		// Only include windows that haven't ended
		if w.Active && !w.Closed && (w.EndDate.IsZero() || w.EndDate.After(now)) {
			// Get REAL-TIME prices from WebSocket (instant, no network latency!)
			if s.wsClient != nil && s.wsClient.IsConnected() && w.YesTokenID != "" {
				if upPrice, downPrice, ok := s.wsClient.GetMarketPrices(w.YesTokenID, w.NoTokenID); ok {
					w.YesPrice = upPrice
					w.NoPrice = downPrice
				}
			}
			active = append(active, w)
		}
	}

	return active
}

// GetWindowByID returns a specific window
func (s *WindowScanner) GetWindowByID(id string) *PredictionWindow {
	s.windowsMu.RLock()
	defer s.windowsMu.RUnlock()

	for _, w := range s.windows {
		if w.ID == id {
			return &w
		}
	}
	return nil
}

// GetBestWindow returns the window with best liquidity/odds
func (s *WindowScanner) GetBestWindow() *PredictionWindow {
	windows := s.GetActiveWindows()
	if len(windows) == 0 {
		return nil
	}

	// Find window with highest volume (most liquid)
	best := &windows[0]
	for i := range windows {
		if windows[i].Volume.GreaterThan(best.Volume) {
			best = &windows[i]
		}
	}

	return best
}

// extractPriceToBeat extracts price from description text
// Looks for patterns like "$90,385.67" or "price to beat: $3,080.45"
func (s *WindowScanner) extractPriceToBeat(text string) decimal.Decimal {
	// Common patterns in Polymarket descriptions
	// Pattern: $XX,XXX.XX or $XXXX.XX
	
	// Look for dollar amount after common keywords
	text = strings.ToLower(text)
	
	// Keywords that precede the price
	keywords := []string{
		"price to beat:",
		"price to beat",
		"starting price:",
		"starting price",
		"reference price:",
		"reference price",
	}
	
	for _, kw := range keywords {
		idx := strings.Index(text, kw)
		if idx >= 0 {
			// Extract text after keyword
			after := text[idx+len(kw):]
			price := s.parseFirstPrice(after)
			if !price.IsZero() {
				return price
			}
		}
	}
	
	return decimal.Zero
}

// parseFirstPrice extracts the first dollar price from text
func (s *WindowScanner) parseFirstPrice(text string) decimal.Decimal {
	// Find $ followed by digits
	start := strings.Index(text, "$")
	if start < 0 {
		return decimal.Zero
	}
	
	// Extract number after $
	numStr := ""
	for i := start + 1; i < len(text); i++ {
		c := text[i]
		if (c >= '0' && c <= '9') || c == '.' || c == ',' {
			if c != ',' { // Skip commas
				numStr += string(c)
			}
		} else if len(numStr) > 0 {
			break
		}
	}
	
	if numStr == "" {
		return decimal.Zero
	}
	
	price, err := decimal.NewFromString(numStr)
	if err != nil {
		return decimal.Zero
	}
	
	return price
}


================================================================================
FILE: internal/polymarket/client.go
================================================================================
package polymarket

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
)

type Client struct {
	baseURL    string
	httpClient *http.Client
}

type Market struct {
	ID                 string `json:"id"`
	Question           string `json:"question"`
	Slug               string `json:"slug"`
	Active             bool   `json:"active"`
	Closed             bool   `json:"closed"`
	Volume             string `json:"volume"`
	OutcomePrices      string `json:"outcomePrices"`
	Outcomes           string `json:"outcomes"`
	ConditionID        string `json:"conditionId"`
	EndDate            string `json:"endDateIso"`
	Description        string `json:"description"`
	MarketMakerAddress string `json:"marketMakerAddress"`
}

type ParsedMarket struct {
	ID       string
	Question string
	Slug     string
	Active   bool
	Closed   bool
	Volume   decimal.Decimal
	YesPrice decimal.Decimal
	NoPrice  decimal.Decimal
	Outcomes []string
	EndDate  time.Time
}

type OrderBook struct {
	Bids [][]string `json:"bids"` // [[price, size], ...]
	Asks [][]string `json:"asks"`
}

func NewClient(baseURL string) *Client {
	return &Client{
		baseURL: baseURL,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// GetMarkets fetches a single page of markets (for backward compatibility)
func (c *Client) GetMarkets(limit int) ([]ParsedMarket, error) {
	return c.GetMarketsWithOffset(limit, 0)
}

// GetMarketsWithOffset fetches a single page of markets with offset
func (c *Client) GetMarketsWithOffset(limit, offset int) ([]ParsedMarket, error) {
	url := fmt.Sprintf("%s/markets?closed=false&active=true&limit=%d&offset=%d", c.baseURL, limit, offset)
	resp, err := c.httpClient.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch markets: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	var markets []Market
	if err := json.NewDecoder(resp.Body).Decode(&markets); err != nil {
		return nil, fmt.Errorf("failed to decode markets: %w", err)
	}

	// Parse markets
	var parsed []ParsedMarket
	for _, m := range markets {
		pm, err := c.parseMarket(m)
		if err != nil {
			log.Debug().Err(err).Str("market", m.ID).Msg("Failed to parse market")
			continue
		}
		parsed = append(parsed, *pm)
	}

	return parsed, nil
}

// GetAllMarkets fetches all markets using pagination, with optional rate limiting
func (c *Client) GetAllMarkets(batchSize, maxMarkets, maxRPS int) ([]ParsedMarket, error) {
	var all []ParsedMarket
	offset := 0
	for {
		// Respect maxMarkets if set
		toFetch := batchSize
		if maxMarkets > 0 && len(all)+batchSize > maxMarkets {
			toFetch = maxMarkets - len(all)
		}
		if toFetch <= 0 {
			break
		}

		batch, err := c.GetMarketsWithOffset(toFetch, offset)
		if err != nil {
			return nil, err
		}
		if len(batch) == 0 {
			break
		}
		all = append(all, batch...)
		offset += len(batch)

		// If we got less than requested, we're done
		if len(batch) < toFetch {
			break
		}

		// Rate limiting
		if maxRPS > 0 {
			time.Sleep(time.Second / time.Duration(maxRPS))
		}
	}
	return all, nil
}

func (c *Client) GetMarket(conditionID string) (*ParsedMarket, error) {
	url := fmt.Sprintf("%s/markets/%s", c.baseURL, conditionID)

	resp, err := c.httpClient.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var market Market
	if err := json.NewDecoder(resp.Body).Decode(&market); err != nil {
		return nil, err
	}

	return c.parseMarket(market)
}

func (c *Client) parseMarket(m Market) (*ParsedMarket, error) {
	pm := &ParsedMarket{
		ID:       m.ID,
		Question: m.Question,
		Slug:     m.Slug,
		Active:   m.Active,
		Closed:   m.Closed,
	}

	// Parse volume
	if m.Volume != "" {
		vol, err := decimal.NewFromString(m.Volume)
		if err == nil {
			pm.Volume = vol
		}
	}

	// Parse outcome prices
	if m.OutcomePrices != "" {
		var prices []string
		if err := json.Unmarshal([]byte(m.OutcomePrices), &prices); err != nil {
			return nil, fmt.Errorf("failed to parse outcome prices: %w", err)
		}

		if len(prices) >= 2 {
			if yes, err := decimal.NewFromString(prices[0]); err == nil {
				pm.YesPrice = yes
			}
			if no, err := decimal.NewFromString(prices[1]); err == nil {
				pm.NoPrice = no
			}
		}
	}

	// Parse outcomes
	if m.Outcomes != "" {
		var outcomes []string
		if err := json.Unmarshal([]byte(m.Outcomes), &outcomes); err == nil {
			pm.Outcomes = outcomes
		}
	}

	// Parse end date
	if m.EndDate != "" {
		if t, err := time.Parse(time.RFC3339, m.EndDate); err == nil {
			pm.EndDate = t
		}
	}

	return pm, nil
}

// GetOrderBook fetches the order book for a market (for future trading)
func (c *Client) GetOrderBook(tokenID string) (*OrderBook, error) {
	url := fmt.Sprintf("https://clob.polymarket.com/book?token_id=%s", tokenID)

	resp, err := c.httpClient.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var book OrderBook
	if err := json.NewDecoder(resp.Body).Decode(&book); err != nil {
		return nil, err
	}

	return &book, nil
}


================================================================================
FILE: internal/binance/client.go
================================================================================
package binance

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
)

// Kline represents a candlestick
type Kline struct {
	OpenTime  int64
	Open      decimal.Decimal
	High      decimal.Decimal
	Low       decimal.Decimal
	Close     decimal.Decimal
	Volume    decimal.Decimal
	CloseTime int64
}

// OrderBookEntry represents a price level
type OrderBookEntry struct {
	Price    decimal.Decimal
	Quantity decimal.Decimal
}

// OrderBook represents the order book
type OrderBook struct {
	Bids []OrderBookEntry
	Asks []OrderBookEntry
}

// Trade represents a trade
type Trade struct {
	Price     decimal.Decimal
	Quantity  decimal.Decimal
	Time      int64
	IsBuyMaker bool
}

// Client handles Binance data
type Client struct {
	wsURL      string
	restURL    string
	conn       *websocket.Conn
	
	// Real-time data
	currentPrice decimal.Decimal
	priceBuffer  []PricePoint
	trades       []Trade
	orderBook    *OrderBook
	
	// Callbacks
	onPrice func(decimal.Decimal)
	onTrade func(Trade)
	
	mu         sync.RWMutex
	bufferMu   sync.RWMutex
	running    bool
	stopCh     chan struct{}
	reconnectCh chan struct{}
}

// PricePoint for tracking price history
type PricePoint struct {
	Price     decimal.Decimal
	Volume    decimal.Decimal
	Timestamp time.Time
}

// NewClient creates a new Binance client
func NewClient() *Client {
	return &Client{
		wsURL:       "wss://stream.binance.com:9443/ws",
		restURL:     "https://api.binance.com",
		priceBuffer: make([]PricePoint, 0, 1000),
		trades:      make([]Trade, 0, 1000),
		stopCh:      make(chan struct{}),
		reconnectCh: make(chan struct{}, 1),
	}
}

// SetPriceCallback sets callback for price updates
func (c *Client) SetPriceCallback(cb func(decimal.Decimal)) {
	c.onPrice = cb
}

// SetTradeCallback sets callback for trade updates
func (c *Client) SetTradeCallback(cb func(Trade)) {
	c.onTrade = cb
}

// Start connects to WebSocket and begins streaming
func (c *Client) Start() error {
	c.running = true
	
	// Initial REST fetch for historical data
	if err := c.fetchInitialData(); err != nil {
		log.Warn().Err(err).Msg("Failed to fetch initial data, continuing anyway")
	}
	
	// Connect WebSocket
	go c.runWebSocket()
	
	// Periodic reconnect checker
	go c.reconnectLoop()
	
	log.Info().Msg("üìà Binance client started")
	return nil
}

// Stop closes the WebSocket connection
func (c *Client) Stop() {
	c.running = false
	close(c.stopCh)
	if c.conn != nil {
		c.conn.Close()
	}
}

func (c *Client) runWebSocket() {
	for c.running {
		if err := c.connectWebSocket(); err != nil {
			log.Error().Err(err).Msg("WebSocket connection failed")
			time.Sleep(5 * time.Second)
			continue
		}
		
		c.readMessages()
		
		if c.running {
			log.Warn().Msg("WebSocket disconnected, reconnecting...")
			time.Sleep(1 * time.Second)
		}
	}
}

func (c *Client) connectWebSocket() error {
	// Subscribe to BTC/USDT trade stream and mini ticker
	url := fmt.Sprintf("%s/btcusdt@trade", c.wsURL)
	
	dialer := websocket.Dialer{
		HandshakeTimeout: 10 * time.Second,
	}
	
	conn, _, err := dialer.Dial(url, nil)
	if err != nil {
		return fmt.Errorf("websocket dial failed: %w", err)
	}
	
	c.conn = conn
	log.Info().Str("url", url).Msg("üîå WebSocket connected to Binance")
	return nil
}

func (c *Client) readMessages() {
	for c.running {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			if c.running {
				log.Error().Err(err).Msg("WebSocket read error")
			}
			return
		}
		
		c.handleMessage(message)
	}
}

func (c *Client) handleMessage(data []byte) {
	var msg map[string]interface{}
	if err := json.Unmarshal(data, &msg); err != nil {
		return
	}
	
	// Trade stream message
	if eventType, ok := msg["e"].(string); ok && eventType == "trade" {
		c.handleTradeMessage(msg)
	}
}

func (c *Client) handleTradeMessage(msg map[string]interface{}) {
	priceStr, _ := msg["p"].(string)
	qtyStr, _ := msg["q"].(string)
	isBuyMaker, _ := msg["m"].(bool)
	tradeTime, _ := msg["T"].(float64)
	
	price, _ := decimal.NewFromString(priceStr)
	qty, _ := decimal.NewFromString(qtyStr)
	
	trade := Trade{
		Price:      price,
		Quantity:   qty,
		Time:       int64(tradeTime),
		IsBuyMaker: isBuyMaker,
	}
	
	// Update current price
	c.mu.Lock()
	c.currentPrice = price
	c.trades = append(c.trades, trade)
	if len(c.trades) > 1000 {
		c.trades = c.trades[500:]
	}
	c.mu.Unlock()
	
	// Add to buffer
	c.bufferMu.Lock()
	c.priceBuffer = append(c.priceBuffer, PricePoint{
		Price:     price,
		Volume:    qty,
		Timestamp: time.Now(),
	})
	// Keep last 5 minutes of data
	cutoff := time.Now().Add(-5 * time.Minute)
	for len(c.priceBuffer) > 0 && c.priceBuffer[0].Timestamp.Before(cutoff) {
		c.priceBuffer = c.priceBuffer[1:]
	}
	c.bufferMu.Unlock()
	
	// Callbacks
	if c.onPrice != nil {
		c.onPrice(price)
	}
	if c.onTrade != nil {
		c.onTrade(trade)
	}
}

func (c *Client) reconnectLoop() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	
	for {
		select {
		case <-ticker.C:
			// Check if we're receiving data
			c.mu.RLock()
			price := c.currentPrice
			c.mu.RUnlock()
			
			if price.IsZero() && c.running {
				log.Warn().Msg("No price data, triggering reconnect")
				select {
				case c.reconnectCh <- struct{}{}:
				default:
				}
			}
		case <-c.stopCh:
			return
		}
	}
}

func (c *Client) fetchInitialData() error {
	// Fetch recent klines for indicator calculation
	klines, err := c.GetKlines("BTCUSDT", "1m", 100)
	if err != nil {
		return err
	}
	
	// Populate buffer with kline close prices
	c.bufferMu.Lock()
	for _, k := range klines {
		c.priceBuffer = append(c.priceBuffer, PricePoint{
			Price:     k.Close,
			Volume:    k.Volume,
			Timestamp: time.Unix(k.CloseTime/1000, 0),
		})
	}
	c.bufferMu.Unlock()
	
	if len(klines) > 0 {
		c.mu.Lock()
		c.currentPrice = klines[len(klines)-1].Close
		c.mu.Unlock()
	}
	
	log.Info().Int("klines", len(klines)).Msg("Fetched initial price data")
	return nil
}

// GetKlines fetches historical klines via REST
func (c *Client) GetKlines(symbol, interval string, limit int) ([]Kline, error) {
	url := fmt.Sprintf("%s/api/v3/klines?symbol=%s&interval=%s&limit=%d",
		c.restURL, symbol, interval, limit)
	
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	var raw [][]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&raw); err != nil {
		return nil, err
	}
	
	klines := make([]Kline, len(raw))
	for i, k := range raw {
		openTime, _ := k[0].(float64)
		open, _ := decimal.NewFromString(k[1].(string))
		high, _ := decimal.NewFromString(k[2].(string))
		low, _ := decimal.NewFromString(k[3].(string))
		close, _ := decimal.NewFromString(k[4].(string))
		volume, _ := decimal.NewFromString(k[5].(string))
		closeTime, _ := k[6].(float64)
		
		klines[i] = Kline{
			OpenTime:  int64(openTime),
			Open:      open,
			High:      high,
			Low:       low,
			Close:     close,
			Volume:    volume,
			CloseTime: int64(closeTime),
		}
	}
	
	return klines, nil
}

// GetPriceAtTime fetches the BTC price at a specific timestamp using 1-second klines
// This is used to get the "Price to Beat" for Polymarket windows
// Returns the open price of the 1-second candle at the given timestamp
func (c *Client) GetPriceAtTime(t time.Time) (decimal.Decimal, error) {
	return c.GetAssetPriceAtTime("BTC", t)
}

// GetAssetPriceAtTime fetches any asset's price at a specific timestamp using 1-second klines
// asset should be "BTC", "ETH", or "SOL"
func (c *Client) GetAssetPriceAtTime(asset string, t time.Time) (decimal.Decimal, error) {
	// Map asset to Binance symbol
	symbol := asset + "USDT"
	
	// Convert to milliseconds for Binance API
	startMs := t.Unix() * 1000
	endMs := startMs + 1000 // Just 1 second
	
	url := fmt.Sprintf("%s/api/v3/klines?symbol=%s&interval=1s&startTime=%d&endTime=%d&limit=1",
		c.restURL, symbol, startMs, endMs)
	
	resp, err := http.Get(url)
	if err != nil {
		return decimal.Zero, fmt.Errorf("failed to fetch 1s kline: %w", err)
	}
	defer resp.Body.Close()
	
	var raw [][]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&raw); err != nil {
		return decimal.Zero, fmt.Errorf("failed to decode kline: %w", err)
	}
	
	if len(raw) == 0 {
		return decimal.Zero, fmt.Errorf("no kline data for timestamp %d", t.Unix())
	}
	
	// Return the open price of the kline
	open, err := decimal.NewFromString(raw[0][1].(string))
	if err != nil {
		return decimal.Zero, fmt.Errorf("failed to parse price: %w", err)
	}
	
	return open, nil
}

// GetOrderBook fetches order book via REST
func (c *Client) GetOrderBook(symbol string, limit int) (*OrderBook, error) {
	url := fmt.Sprintf("%s/api/v3/depth?symbol=%s&limit=%d",
		c.restURL, symbol, limit)
	
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	var raw struct {
		Bids [][]string `json:"bids"`
		Asks [][]string `json:"asks"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&raw); err != nil {
		return nil, err
	}
	
	book := &OrderBook{
		Bids: make([]OrderBookEntry, len(raw.Bids)),
		Asks: make([]OrderBookEntry, len(raw.Asks)),
	}
	
	for i, b := range raw.Bids {
		price, _ := decimal.NewFromString(b[0])
		qty, _ := decimal.NewFromString(b[1])
		book.Bids[i] = OrderBookEntry{Price: price, Quantity: qty}
	}
	for i, a := range raw.Asks {
		price, _ := decimal.NewFromString(a[0])
		qty, _ := decimal.NewFromString(a[1])
		book.Asks[i] = OrderBookEntry{Price: price, Quantity: qty}
	}
	
	c.mu.Lock()
	c.orderBook = book
	c.mu.Unlock()
	
	return book, nil
}

// GetFundingRate fetches perpetual funding rate
func (c *Client) GetFundingRate(symbol string) (decimal.Decimal, error) {
	url := fmt.Sprintf("https://fapi.binance.com/fapi/v1/fundingRate?symbol=%s&limit=1", symbol)
	
	resp, err := http.Get(url)
	if err != nil {
		return decimal.Zero, err
	}
	defer resp.Body.Close()
	
	var raw []struct {
		FundingRate string `json:"fundingRate"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&raw); err != nil {
		return decimal.Zero, err
	}
	
	if len(raw) == 0 {
		return decimal.Zero, nil
	}
	
	rate, _ := decimal.NewFromString(raw[0].FundingRate)
	return rate, nil
}

// GetCurrentPrice returns the current BTC price
func (c *Client) GetCurrentPrice() decimal.Decimal {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.currentPrice
}

// GetPriceBuffer returns recent price data
func (c *Client) GetPriceBuffer() []PricePoint {
	c.bufferMu.RLock()
	defer c.bufferMu.RUnlock()
	
	result := make([]PricePoint, len(c.priceBuffer))
	copy(result, c.priceBuffer)
	return result
}

// GetRecentTrades returns recent trades
func (c *Client) GetRecentTrades() []Trade {
	c.mu.RLock()
	defer c.mu.RUnlock()
	
	result := make([]Trade, len(c.trades))
	copy(result, c.trades)
	return result
}

// GetPriceChange calculates price change over duration
func (c *Client) GetPriceChange(duration time.Duration) (decimal.Decimal, decimal.Decimal) {
	c.bufferMu.RLock()
	defer c.bufferMu.RUnlock()
	
	if len(c.priceBuffer) < 2 {
		return decimal.Zero, decimal.Zero
	}
	
	cutoff := time.Now().Add(-duration)
	var oldPrice decimal.Decimal
	
	for _, p := range c.priceBuffer {
		if p.Timestamp.After(cutoff) {
			break
		}
		oldPrice = p.Price
	}
	
	if oldPrice.IsZero() {
		oldPrice = c.priceBuffer[0].Price
	}
	
	currentPrice := c.priceBuffer[len(c.priceBuffer)-1].Price
	change := currentPrice.Sub(oldPrice)
	changePct := change.Div(oldPrice).Mul(decimal.NewFromInt(100))
	
	return change, changePct
}

// GetVolumeInPeriod calculates total volume in duration
func (c *Client) GetVolumeInPeriod(duration time.Duration) decimal.Decimal {
	c.bufferMu.RLock()
	defer c.bufferMu.RUnlock()
	
	cutoff := time.Now().Add(-duration)
	volume := decimal.Zero
	
	for _, p := range c.priceBuffer {
		if p.Timestamp.After(cutoff) {
			volume = volume.Add(p.Volume)
		}
	}
	
	return volume
}

// GetBuySellRatio calculates buy/sell volume ratio
func (c *Client) GetBuySellRatio(duration time.Duration) decimal.Decimal {
	c.mu.RLock()
	defer c.mu.RUnlock()
	
	cutoff := time.Now().Add(-duration).UnixMilli()
	buyVol := decimal.Zero
	sellVol := decimal.Zero
	
	for _, t := range c.trades {
		if t.Time > cutoff {
			if t.IsBuyMaker {
				sellVol = sellVol.Add(t.Quantity)
			} else {
				buyVol = buyVol.Add(t.Quantity)
			}
		}
	}
	
	if sellVol.IsZero() {
		return decimal.NewFromInt(100)
	}
	
	return buyVol.Div(sellVol)
}

// GetPrices returns prices as float64 slice for indicator calculation
func (c *Client) GetPrices(count int) []float64 {
	c.bufferMu.RLock()
	defer c.bufferMu.RUnlock()
	
	start := 0
	if len(c.priceBuffer) > count {
		start = len(c.priceBuffer) - count
	}
	
	prices := make([]float64, 0, count)
	for i := start; i < len(c.priceBuffer); i++ {
		f, _ := c.priceBuffer[i].Price.Float64()
		prices = append(prices, f)
	}
	
	return prices
}

// GetVolumes returns volumes as float64 slice
func (c *Client) GetVolumes(count int) []float64 {
	c.bufferMu.RLock()
	defer c.bufferMu.RUnlock()
	
	start := 0
	if len(c.priceBuffer) > count {
		start = len(c.priceBuffer) - count
	}
	
	volumes := make([]float64, 0, count)
	for i := start; i < len(c.priceBuffer); i++ {
		f, _ := c.priceBuffer[i].Volume.Float64()
		volumes = append(volumes, f)
	}
	
	return volumes
}

// IsConnected returns connection status
func (c *Client) IsConnected() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.running && !c.currentPrice.IsZero()
}

// ParseDecimal helper
func ParseDecimal(s string) decimal.Decimal {
	d, _ := decimal.NewFromString(s)
	return d
}

// ParseFloat helper
func ParseFloat(s string) float64 {
	f, _ := strconv.ParseFloat(s, 64)
	return f
}


================================================================================
FILE: internal/database/database.go
================================================================================
package database

import (
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type Database struct {
	db *gorm.DB
}

// Models

type Market struct {
	ID            string `gorm:"primaryKey"`
	Question      string
	Slug          string
	YesPrice      decimal.Decimal `gorm:"type:decimal(10,6)"`
	NoPrice       decimal.Decimal `gorm:"type:decimal(10,6)"`
	Volume        decimal.Decimal `gorm:"type:decimal(20,2)"`
	EndDate       time.Time
	Active        bool
	LastChecked   time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

type Opportunity struct {
	ID          uint            `gorm:"primaryKey;autoIncrement"`
	MarketID    string          `gorm:"index"`
	Question    string
	YesPrice    decimal.Decimal `gorm:"type:decimal(10,6)"`
	NoPrice     decimal.Decimal `gorm:"type:decimal(10,6)"`
	TotalPrice  decimal.Decimal `gorm:"type:decimal(10,6)"`
	SpreadPct   decimal.Decimal `gorm:"type:decimal(10,4)"`
	Type        string
	AlertSent   bool
	TradedAt    *time.Time
	Profit      decimal.Decimal `gorm:"type:decimal(20,6)"`
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type Trade struct {
	ID           uint            `gorm:"primaryKey;autoIncrement"`
	MarketID     string          `gorm:"index"`
	Side         string          // "YES" or "NO"
	Amount       decimal.Decimal `gorm:"type:decimal(20,6)"`
	Price        decimal.Decimal `gorm:"type:decimal(10,6)"`
	Status       string          // "pending", "executed", "failed"
	TxHash       string
	ProfitLoss   decimal.Decimal `gorm:"type:decimal(20,6)"`
	ErrorMessage string
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

// ArbTrade represents an arbitrage trade for the latency arb strategy
type ArbTrade struct {
	ID             string          `gorm:"primaryKey"`
	Asset          string          `gorm:"index"` // BTC, ETH, SOL
	WindowID       string          `gorm:"index"`
	Question       string
	Direction      string          // "UP" or "DOWN"
	TokenID        string
	EntryPrice     decimal.Decimal `gorm:"type:decimal(10,6)"`
	ExitPrice      decimal.Decimal `gorm:"type:decimal(10,6)"`
	Amount         decimal.Decimal `gorm:"type:decimal(20,6)"`
	Shares         decimal.Decimal `gorm:"type:decimal(20,6)"`
	BTCAtEntry     decimal.Decimal `gorm:"type:decimal(20,6)"`
	BTCAtStart     decimal.Decimal `gorm:"type:decimal(20,6)"`
	PriceChangePct decimal.Decimal `gorm:"type:decimal(10,6)"`
	Edge           decimal.Decimal `gorm:"type:decimal(10,6)"`
	SizeMultiplier string          // "1x", "2x", "3x"
	Status         string          `gorm:"index"` // "open", "filled", "exited", "won", "lost"
	ExitType       string          // "quick_flip", "resolution", "stop_loss"
	Profit         decimal.Decimal `gorm:"type:decimal(20,6)"`
	EnteredAt      time.Time
	ExitedAt       *time.Time
	ResolvedAt     *time.Time
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

type Alert struct {
	ID         uint   `gorm:"primaryKey;autoIncrement"`
	MarketID   string `gorm:"index"`
	ChatID     int64
	MessageID  int
	Type       string
	SpreadPct  decimal.Decimal `gorm:"type:decimal(10,4)"`
	CreatedAt  time.Time
}

type UserSettings struct {
	ChatID          int64 `gorm:"primaryKey"`
	AlertsEnabled   bool  `gorm:"default:true"`
	MinSpreadPct    decimal.Decimal `gorm:"type:decimal(10,4);default:2.0"`
	TradingEnabled  bool  `gorm:"default:false"`
	MaxTradeSize    decimal.Decimal `gorm:"type:decimal(20,6);default:100"`
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

// ScalpTrade represents a scalping trade with ML features
type ScalpTrade struct {
	TradeID      string `gorm:"column:trade_id;primaryKey"`
	Asset        string `gorm:"column:asset;index"`
	WindowID     string `gorm:"column:window_id"`
	WindowTitle  string `gorm:"column:window_title"`
	Side         string `gorm:"column:side"`      // "UP" or "DOWN"
	TokenID      string `gorm:"column:token_id"`

	// Entry
	EntryPrice   decimal.Decimal `gorm:"column:entry_price;type:decimal(20,6)"`
	EntrySize    int64           `gorm:"column:entry_size"`
	EntryCost    decimal.Decimal `gorm:"column:entry_cost;type:decimal(20,6)"`
	EntryTime    time.Time       `gorm:"column:entry_time"`
	EntryOrderID string          `gorm:"column:entry_order_id"`

	// Exit
	ExitPrice    decimal.Decimal `gorm:"column:exit_price;type:decimal(20,6)"`
	ExitSize     int64           `gorm:"column:exit_size"`
	ExitValue    decimal.Decimal `gorm:"column:exit_value;type:decimal(20,6)"`
	ExitTime     *time.Time      `gorm:"column:exit_time"`
	ExitOrderID  string          `gorm:"column:exit_order_id"`
	ExitType     string          `gorm:"column:exit_type"` // profit_target, early_exit, stop_loss, timeout

	// P&L
	ProfitLoss   decimal.Decimal `gorm:"column:profit_loss;type:decimal(20,6)"`
	ProfitPct    decimal.Decimal `gorm:"column:profit_pct;type:decimal(10,4)"`

	// ML Features at Entry
	MLProbability    decimal.Decimal `gorm:"column:ml_probability;type:decimal(10,4)"`
	MLEntryThreshold decimal.Decimal `gorm:"column:ml_entry_threshold;type:decimal(10,4)"`
	MLProfitTarget   decimal.Decimal `gorm:"column:ml_profit_target;type:decimal(10,4)"`
	MLStopLoss       decimal.Decimal `gorm:"column:ml_stop_loss;type:decimal(10,4)"`
	Volatility15m    decimal.Decimal `gorm:"column:volatility_15m;type:decimal(10,6)"`
	Momentum1m       decimal.Decimal `gorm:"column:momentum_1m;type:decimal(10,6)"`
	Momentum5m       decimal.Decimal `gorm:"column:momentum_5m;type:decimal(10,6)"`
	PriceAtEntry     decimal.Decimal `gorm:"column:price_at_entry;type:decimal(20,6)"`
	TimeRemainingMin int             `gorm:"column:time_remaining_min"`

	// Status
	Status    string    `gorm:"column:status;index"` // OPEN, CLOSED, EXPIRED
	CreatedAt time.Time `gorm:"column:created_at"`
	UpdatedAt time.Time `gorm:"column:updated_at"`
}

func (ScalpTrade) TableName() string {
	return "scalp_trades"
}

// WindowPrice stores the captured "Price to Beat" for each prediction window
// This is captured at exact window start time and stored for later lookup
type WindowPrice struct {
	ID           uint            `gorm:"primaryKey;autoIncrement"`
	WindowSlug   string          `gorm:"uniqueIndex"` // e.g., "btc-updown-15m-1768040100"
	Asset        string          `gorm:"index"`       // BTC, ETH, SOL
	PriceToBeat  decimal.Decimal `gorm:"type:decimal(20,6)"`
	Source       string          // "chainlink", "binance", "cmc"
	WindowStart  time.Time       `gorm:"index"`
	CapturedAt   time.Time
	CreatedAt    time.Time
}

func (WindowPrice) TableName() string {
	return "window_prices"
}

func New(dbPath string) (*Database, error) {
	var db *gorm.DB
	var err error

	// Check if this is a PostgreSQL connection string
	if strings.HasPrefix(dbPath, "postgres://") || strings.HasPrefix(dbPath, "postgresql://") {
		// PostgreSQL connection
		db, err = gorm.Open(postgres.Open(dbPath), &gorm.Config{
			Logger: logger.Default.LogMode(logger.Silent),
		})
		if err != nil {
			return nil, err
		}
		log.Info().Msg("Database connected (PostgreSQL)")
	} else {
		// SQLite fallback
		dir := filepath.Dir(dbPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			return nil, err
		}
		db, err = gorm.Open(sqlite.Open(dbPath), &gorm.Config{
			Logger: logger.Default.LogMode(logger.Silent),
		})
		if err != nil {
			return nil, err
		}
		log.Info().Str("path", dbPath).Msg("Database initialized (SQLite)")
	}

	// Auto migrate all models
	if err := db.AutoMigrate(&Market{}, &Opportunity{}, &Trade{}, &ArbTrade{}, &Alert{}, &UserSettings{}, &WindowPrice{}); err != nil {
		return nil, err
	}

	return &Database{db: db}, nil
}

// Market operations

func (d *Database) SaveMarket(market *Market) error {
	return d.db.Save(market).Error
}

func (d *Database) GetMarket(id string) (*Market, error) {
	var market Market
	err := d.db.First(&market, "id = ?", id).Error
	return &market, err
}

// Opportunity operations

func (d *Database) SaveOpportunity(opp *Opportunity) error {
	return d.db.Create(opp).Error
}

func (d *Database) GetRecentOpportunities(limit int) ([]Opportunity, error) {
	var opps []Opportunity
	err := d.db.Order("created_at DESC").Limit(limit).Find(&opps).Error
	return opps, err
}

func (d *Database) GetLastAlertTime(marketID string) (time.Time, error) {
	var alert Alert
	err := d.db.Where("market_id = ?", marketID).Order("created_at DESC").First(&alert).Error
	if err != nil {
		return time.Time{}, err
	}
	return alert.CreatedAt, nil
}

// Alert operations

func (d *Database) SaveAlert(alert *Alert) error {
	return d.db.Create(alert).Error
}

// Trade operations

func (d *Database) SaveTrade(trade *Trade) error {
	return d.db.Create(trade).Error
}

func (d *Database) UpdateTrade(trade *Trade) error {
	return d.db.Save(trade).Error
}

func (d *Database) GetTradesByMarket(marketID string) ([]Trade, error) {
	var trades []Trade
	err := d.db.Where("market_id = ?", marketID).Order("created_at DESC").Find(&trades).Error
	return trades, err
}

func (d *Database) GetTotalProfitLoss() (decimal.Decimal, error) {
	var result struct {
		Total decimal.Decimal
	}
	err := d.db.Model(&Trade{}).Select("COALESCE(SUM(profit_loss), 0) as total").Scan(&result).Error
	return result.Total, err
}

// User settings operations

func (d *Database) GetUserSettings(chatID int64) (*UserSettings, error) {
	var settings UserSettings
	err := d.db.FirstOrCreate(&settings, UserSettings{ChatID: chatID}).Error
	return &settings, err
}

func (d *Database) SaveUserSettings(settings *UserSettings) error {
	return d.db.Save(settings).Error
}

// Stats operations

func (d *Database) GetStats() (map[string]interface{}, error) {
	stats := make(map[string]interface{})

	var opportunityCount int64
	d.db.Model(&Opportunity{}).Count(&opportunityCount)
	stats["total_opportunities"] = opportunityCount

	var tradeCount int64
	d.db.Model(&Trade{}).Count(&tradeCount)
	stats["total_trades"] = tradeCount

	pnl, _ := d.GetTotalProfitLoss()
	stats["total_pnl"] = pnl

	var marketCount int64
	d.db.Model(&Market{}).Where("active = ?", true).Count(&marketCount)
	stats["active_markets"] = marketCount

	return stats, nil
}

// ============ ARBITRAGE TRADE OPERATIONS ============

// SaveArbTrade saves an arbitrage trade to the database
func (d *Database) SaveArbTrade(trade *ArbTrade) error {
	trade.CreatedAt = time.Now()
	trade.UpdatedAt = time.Now()
	return d.db.Create(trade).Error
}

// UpdateArbTrade updates an existing arbitrage trade
func (d *Database) UpdateArbTrade(trade *ArbTrade) error {
	trade.UpdatedAt = time.Now()
	return d.db.Save(trade).Error
}

// GetArbTrade retrieves a single arbitrage trade by ID
func (d *Database) GetArbTrade(id string) (*ArbTrade, error) {
	var trade ArbTrade
	err := d.db.First(&trade, "id = ?", id).Error
	return &trade, err
}

// DeleteArbTrade deletes an arbitrage trade by ID (used for test cleanup)
func (d *Database) DeleteArbTrade(id string) error {
	return d.db.Delete(&ArbTrade{}, "id = ?", id).Error
}

// GetRecentArbTrades gets recent arbitrage trades
func (d *Database) GetRecentArbTrades(limit int) ([]ArbTrade, error) {
	var trades []ArbTrade
	err := d.db.Order("entered_at DESC").Limit(limit).Find(&trades).Error
	return trades, err
}

// GetOpenArbTrades gets all open arbitrage trades
func (d *Database) GetOpenArbTrades() ([]ArbTrade, error) {
	var trades []ArbTrade
	err := d.db.Where("status IN ?", []string{"open", "filled"}).Order("entered_at DESC").Find(&trades).Error
	return trades, err
}

// GetArbTradesByAsset gets trades for a specific asset
func (d *Database) GetArbTradesByAsset(asset string, limit int) ([]ArbTrade, error) {
	var trades []ArbTrade
	err := d.db.Where("asset = ?", asset).Order("entered_at DESC").Limit(limit).Find(&trades).Error
	return trades, err
}

// GetArbTradeStats gets aggregate statistics for arbitrage trades
func (d *Database) GetArbTradeStats() (map[string]interface{}, error) {
	stats := make(map[string]interface{})

	// Total trades
	var totalCount int64
	d.db.Model(&ArbTrade{}).Count(&totalCount)
	stats["total_trades"] = totalCount

	// Won/Lost
	var wonCount int64
	d.db.Model(&ArbTrade{}).Where("status = ?", "won").Count(&wonCount)
	stats["won_trades"] = wonCount

	var lostCount int64
	d.db.Model(&ArbTrade{}).Where("status = ?", "lost").Count(&lostCount)
	stats["lost_trades"] = lostCount

	// Open positions
	var openCount int64
	d.db.Model(&ArbTrade{}).Where("status IN ?", []string{"open", "filled"}).Count(&openCount)
	stats["open_positions"] = openCount

	// Total profit
	var profitResult struct {
		Total decimal.Decimal
	}
	d.db.Model(&ArbTrade{}).Select("COALESCE(SUM(profit), 0) as total").Scan(&profitResult)
	stats["total_profit"] = profitResult.Total

	// By asset
	type AssetCount struct {
		Asset string
		Count int64
	}
	var assetCounts []AssetCount
	d.db.Model(&ArbTrade{}).Select("asset, count(*) as count").Group("asset").Scan(&assetCounts)
	assetStats := make(map[string]int64)
	for _, ac := range assetCounts {
		assetStats[ac.Asset] = ac.Count
	}
	stats["by_asset"] = assetStats

	return stats, nil
}

// ============ SCALP TRADE OPERATIONS ============

// SaveScalpTrade saves a new scalp trade entry
func (d *Database) SaveScalpTrade(trade *ScalpTrade) error {
	trade.CreatedAt = time.Now()
	trade.UpdatedAt = time.Now()
	return d.db.Create(trade).Error
}

// UpdateScalpTrade updates an existing scalp trade (e.g., on exit)
func (d *Database) UpdateScalpTrade(trade *ScalpTrade) error {
	trade.UpdatedAt = time.Now()
	return d.db.Save(trade).Error
}

// GetOpenScalpTrades gets all OPEN scalp trades
func (d *Database) GetOpenScalpTrades() ([]ScalpTrade, error) {
	var trades []ScalpTrade
	err := d.db.Where("status = ?", "OPEN").Find(&trades).Error
	return trades, err
}

// GetScalpTrade retrieves a scalp trade by ID
func (d *Database) GetScalpTrade(tradeID string) (*ScalpTrade, error) {
	var trade ScalpTrade
	err := d.db.First(&trade, "trade_id = ?", tradeID).Error
	return &trade, err
}

// GetRecentScalpTrades gets recent scalp trades
func (d *Database) GetRecentScalpTrades(limit int) ([]ScalpTrade, error) {
	var trades []ScalpTrade
	err := d.db.Order("created_at DESC").Limit(limit).Find(&trades).Error
	return trades, err
}

// GetScalpTradeStats gets aggregate statistics
func (d *Database) GetScalpTradeStats() (map[string]interface{}, error) {
	stats := make(map[string]interface{})

	var totalCount int64
	d.db.Model(&ScalpTrade{}).Count(&totalCount)
	stats["total_trades"] = totalCount

	var closedCount int64
	d.db.Model(&ScalpTrade{}).Where("status = ?", "CLOSED").Count(&closedCount)
	stats["closed_trades"] = closedCount

	var openCount int64
	d.db.Model(&ScalpTrade{}).Where("status = ?", "OPEN").Count(&openCount)
	stats["open_trades"] = openCount

	// Total P&L
	var profitResult struct {
		Total decimal.Decimal
	}
	d.db.Model(&ScalpTrade{}).Where("status = ?", "CLOSED").Select("COALESCE(SUM(profit_loss), 0) as total").Scan(&profitResult)
	stats["total_profit"] = profitResult.Total

	// Win rate
	var winCount int64
	d.db.Model(&ScalpTrade{}).Where("status = ? AND profit_loss > 0", "CLOSED").Count(&winCount)
	if closedCount > 0 {
		stats["win_rate"] = float64(winCount) / float64(closedCount)
	} else {
		stats["win_rate"] = 0.0
	}

	return stats, nil
}

// UpdateMLLearning updates the ml_learning table with trade outcome
func (d *Database) UpdateMLLearning(asset string, priceBucket int, profit decimal.Decimal, won bool) error {
	// Using raw SQL since this table has UPSERT logic
	sql := `
		INSERT INTO ml_learning (asset, price_bucket, total_trades, winning_trades, total_profit, updated_at)
		VALUES ($1, $2, 1, $3, $4, NOW())
		ON CONFLICT (asset, price_bucket) DO UPDATE SET
			total_trades = ml_learning.total_trades + 1,
			winning_trades = ml_learning.winning_trades + $3,
			total_profit = ml_learning.total_profit + $4,
			win_rate = (ml_learning.winning_trades + $3)::DECIMAL / (ml_learning.total_trades + 1),
			updated_at = NOW()
	`
	winInt := 0
	if won {
		winInt = 1
	}
	return d.db.Exec(sql, asset, priceBucket, winInt, profit).Error
}

// UpdateDailyStats updates the daily_stats table
func (d *Database) UpdateDailyStats(profit decimal.Decimal, asset string, won bool) error {
	today := time.Now().Format("2006-01-02")
	winInt := 0
	loseInt := 0
	if won {
		winInt = 1
	} else {
		loseInt = 1
	}
	
	// Build asset-specific columns
	assetTradesCol := "btc_trades"
	assetProfitCol := "btc_profit"
	switch asset {
	case "ETH":
		assetTradesCol = "eth_trades"
		assetProfitCol = "eth_profit"
	case "SOL":
		assetTradesCol = "sol_trades"
		assetProfitCol = "sol_profit"
	}

	sql := `
		INSERT INTO daily_stats (date, total_trades, winning_trades, losing_trades, total_profit, ` + assetTradesCol + `, ` + assetProfitCol + `)
		VALUES ($1, 1, $2, $3, $4, 1, $4)
		ON CONFLICT (date) DO UPDATE SET
			total_trades = daily_stats.total_trades + 1,
			winning_trades = daily_stats.winning_trades + $2,
			losing_trades = daily_stats.losing_trades + $3,
			total_profit = daily_stats.total_profit + $4,
			` + assetTradesCol + ` = daily_stats.` + assetTradesCol + ` + 1,
			` + assetProfitCol + ` = daily_stats.` + assetProfitCol + ` + $4,
			updated_at = NOW()
	`
	return d.db.Exec(sql, today, winInt, loseInt, profit).Error
}

// WindowPrice operations - store/retrieve Price to Beat for prediction windows

// SaveWindowPrice stores the captured price for a window (upsert)
func (d *Database) SaveWindowPrice(wp *WindowPrice) error {
	// Use upsert - if window slug already exists, don't overwrite
	return d.db.Where("window_slug = ?", wp.WindowSlug).FirstOrCreate(wp).Error
}

// GetWindowPrice retrieves the stored price for a window by slug
func (d *Database) GetWindowPrice(windowSlug string) (*WindowPrice, error) {
	var wp WindowPrice
	err := d.db.Where("window_slug = ?", windowSlug).First(&wp).Error
	if err != nil {
		return nil, err
	}
	return &wp, nil
}

// GetWindowPriceByAssetAndTime retrieves price by asset and approximate window start time
func (d *Database) GetWindowPriceByAssetAndTime(asset string, windowStart time.Time) (*WindowPrice, error) {
	var wp WindowPrice
	// Allow 30 second tolerance for matching window start
	startMin := windowStart.Add(-30 * time.Second)
	startMax := windowStart.Add(30 * time.Second)
	err := d.db.Where("asset = ? AND window_start BETWEEN ? AND ?", asset, startMin, startMax).First(&wp).Error
	if err != nil {
		return nil, err
	}
	return &wp, nil
}

// CleanOldWindowPrices removes window prices older than 24 hours
func (d *Database) CleanOldWindowPrices() error {
	cutoff := time.Now().Add(-24 * time.Hour)
	return d.db.Where("window_start < ?", cutoff).Delete(&WindowPrice{}).Error
}


================================================================================
FILE: internal/bot/telegram.go
================================================================================
// Package bot provides a clean, modern Telegram bot for the scalper
// Minimal features: Status, Positions, Trade Alerts
package bot

import (
	"fmt"
	"strings"
	"sync"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/rs/zerolog/log"
	"github.com/shopspring/decimal"

	"github.com/web3guy0/polybot/internal/arbitrage"
	"github.com/web3guy0/polybot/internal/config"
)

// Bot is a minimal, modern Telegram bot for the scalper
type Bot struct {
	api    *tgbotapi.BotAPI
	cfg    *config.Config
	chatID int64

	// Scalpers for each asset
	scalpers map[string]*arbitrage.ScalperStrategy
	engines  map[string]*arbitrage.Engine

	// State
	mu       sync.RWMutex
	alertsOn bool

	stopCh chan struct{}
}

// New creates a new Telegram bot
func New(cfg *config.Config) (*Bot, error) {
	if cfg.TelegramToken == "" {
		return nil, fmt.Errorf("TELEGRAM_BOT_TOKEN not set")
	}

	api, err := tgbotapi.NewBotAPI(cfg.TelegramToken)
	if err != nil {
		return nil, fmt.Errorf("telegram connect failed: %w", err)
	}

	log.Info().Str("username", api.Self.UserName).Msg("ü§ñ Telegram connected")

	return &Bot{
		api:      api,
		cfg:      cfg,
		chatID:   cfg.TelegramChatID,
		scalpers: make(map[string]*arbitrage.ScalperStrategy),
		engines:  make(map[string]*arbitrage.Engine),
		alertsOn: true,
		stopCh:   make(chan struct{}),
	}, nil
}

// AddScalper registers a scalper for an asset
func (b *Bot) AddScalper(asset string, s *arbitrage.ScalperStrategy) {
	b.scalpers[asset] = s
}

// AddEngine registers an engine for an asset
func (b *Bot) AddEngine(asset string, e *arbitrage.Engine) {
	b.engines[asset] = e
}

// Start begins listening for commands
func (b *Bot) Start() {
	go b.listen()
	b.sendStartup()
}

// Stop stops the bot
func (b *Bot) Stop() {
	close(b.stopCh)
}

// SendTradeAlert sends a trade notification
func (b *Bot) SendTradeAlert(asset, side string, price decimal.Decimal, size int64, action string, pnl decimal.Decimal) {
	b.mu.RLock()
	alertsOn := b.alertsOn
	b.mu.RUnlock()

	if !alertsOn || b.chatID == 0 {
		log.Debug().Str("action", action).Bool("alertsOn", alertsOn).Int64("chatID", b.chatID).Msg("üì± Alert skipped")
		return
	}

	emoji := "üü¢"
	if action == "SELL" || action == "STOP" {
		emoji = "üî¥"
	}

	// Base message
	msg := fmt.Sprintf(`%s *%s %s*

Asset: *%s*
Side: *%s*
Price: *%s¬¢*
Size: *%d shares*`,
		emoji, action, side,
		asset,
		side,
		price.Mul(decimal.NewFromInt(100)).StringFixed(1),
		size,
	)

	// Add P&L for sells
	if action == "SELL" || action == "STOP" {
		pnlIcon := "üí∞"
		if pnl.LessThan(decimal.Zero) {
			pnlIcon = "üí∏"
		}
		msg += fmt.Sprintf("\nP&L: *%s $%s*", pnlIcon, pnl.StringFixed(2))
	}

	msg += fmt.Sprintf("\nTime: %s", time.Now().Format("15:04:05"))

	log.Info().Str("action", action).Str("asset", asset).Msg("üì± Sending Telegram alert")
	b.sendMarkdown(msg)
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INTERNAL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

func (b *Bot) listen() {
	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60
	updates := b.api.GetUpdatesChan(u)

	for {
		select {
		case update := <-updates:
			if update.Message != nil && update.Message.IsCommand() {
				go b.handleCommand(update.Message)
			}
			if update.CallbackQuery != nil {
				go b.handleCallback(update.CallbackQuery)
			}
		case <-b.stopCh:
			return
		}
	}
}

func (b *Bot) handleCommand(msg *tgbotapi.Message) {
	// Security check
	if b.chatID != 0 && msg.Chat.ID != b.chatID {
		return
	}

	switch msg.Command() {
	case "start", "menu":
		b.cmdMenu(msg.Chat.ID)
	case "status", "s":
		b.cmdStatus(msg.Chat.ID)
	case "pos", "positions":
		b.cmdPositions(msg.Chat.ID)
	case "stats":
		b.cmdStats(msg.Chat.ID)
	case "alerts":
		b.cmdToggleAlerts(msg.Chat.ID)
	case "help", "h":
		b.cmdHelp(msg.Chat.ID)
	default:
		b.send(msg.Chat.ID, "‚ùì Unknown. Try /help")
	}
}

func (b *Bot) handleCallback(cb *tgbotapi.CallbackQuery) {
	// Acknowledge
	b.api.Request(tgbotapi.NewCallback(cb.ID, ""))

	chatID := cb.Message.Chat.ID
	msgID := cb.Message.MessageID

	switch cb.Data {
	case "refresh_status":
		b.updateStatus(chatID, msgID)
	case "refresh_pos":
		b.updatePositions(chatID, msgID)
	case "toggle_alerts":
		b.toggleAlerts(chatID, msgID)
	}
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COMMANDS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

func (b *Bot) cmdMenu(chatID int64) {
	mode := "üü¢ LIVE"
	if b.cfg.DryRun {
		mode = "üìù PAPER"
	}

	msg := fmt.Sprintf(`‚ö° *POLYBOT SCALPER*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Mode: %s
Strategy: Buy ‚â§20¬¢ ‚Üí Sell 33¬¢

/status - Market status
/pos - Open positions  
/stats - Performance
/alerts - Toggle alerts
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, mode)

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üìä Status", "refresh_status"),
			tgbotapi.NewInlineKeyboardButtonData("üí∞ Positions", "refresh_pos"),
		),
	)

	b.sendWithKeyboard(chatID, msg, keyboard)
}

func (b *Bot) cmdStatus(chatID int64) {
	var sb strings.Builder
	sb.WriteString("üìä *MARKET STATUS*\n")
	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

	for asset, engine := range b.engines {
		price := engine.GetCurrentPrice()
		
		// Get window info
		windows := engine.GetWindowScanner().GetActiveWindows()
		if len(windows) > 0 {
			w := windows[0]
			sb.WriteString(fmt.Sprintf("*%s* | $%s\n", asset, price.StringFixed(2)))
			sb.WriteString(fmt.Sprintf("  UP: %s¬¢ | DOWN: %s¬¢\n",
				w.YesPrice.Mul(decimal.NewFromInt(100)).StringFixed(1),
				w.NoPrice.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			
			// Window age
			age := time.Since(w.StartDate)
			remaining := 15*time.Minute - age
			if remaining > 0 {
				sb.WriteString(fmt.Sprintf("  ‚è± %s left\n", remaining.Round(time.Second)))
			}
			sb.WriteString("\n")
		} else {
			sb.WriteString(fmt.Sprintf("*%s* | $%s | No window\n\n", asset, price.StringFixed(2)))
		}
	}

	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	sb.WriteString(fmt.Sprintf("Updated: %s", time.Now().Format("15:04:05")))

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîÑ Refresh", "refresh_status"),
		),
	)

	b.sendWithKeyboard(chatID, sb.String(), keyboard)
}

func (b *Bot) cmdPositions(chatID int64) {
	var sb strings.Builder
	sb.WriteString("üí∞ *OPEN POSITIONS*\n")
	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

	hasPositions := false
	for asset, scalper := range b.scalpers {
		positions := scalper.GetPositions()
		for _, pos := range positions {
			hasPositions = true
			held := time.Since(pos.EntryTime).Round(time.Second)
			sb.WriteString(fmt.Sprintf("*%s %s*\n", asset, pos.Side))
			sb.WriteString(fmt.Sprintf("  Entry: %s¬¢\n", pos.EntryPrice.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			sb.WriteString(fmt.Sprintf("  Target: %s¬¢\n", pos.TargetPrice.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			sb.WriteString(fmt.Sprintf("  Stop: %s¬¢\n", pos.StopLoss.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			sb.WriteString(fmt.Sprintf("  Held: %s\n\n", held))
		}
	}

	if !hasPositions {
		sb.WriteString("_No open positions_\n\n")
	}

	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	sb.WriteString("Entry: ‚â§20¬¢ | Target: 33¬¢ | Stop: 15¬¢")

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîÑ Refresh", "refresh_pos"),
		),
	)

	b.sendWithKeyboard(chatID, sb.String(), keyboard)
}

func (b *Bot) cmdStats(chatID int64) {
	var sb strings.Builder
	sb.WriteString("üìà *SCALPER STATS*\n")
	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

	totalTrades := 0
	totalWins := 0
	totalProfit := decimal.Zero

	for asset, scalper := range b.scalpers {
		stats := scalper.GetStats()
		totalTrades += stats.TotalTrades
		totalWins += stats.WinningTrades
		totalProfit = totalProfit.Add(stats.TotalProfit)

		if stats.TotalTrades > 0 {
			winRate := float64(stats.WinningTrades) / float64(stats.TotalTrades) * 100
			sb.WriteString(fmt.Sprintf("*%s*: %d trades | %.0f%% WR | $%s\n",
				asset, stats.TotalTrades, winRate, stats.TotalProfit.StringFixed(2)))
		}
	}

	if totalTrades == 0 {
		sb.WriteString("_No trades yet_\n")
	}

	sb.WriteString("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	if totalTrades > 0 {
		winRate := float64(totalWins) / float64(totalTrades) * 100
		sb.WriteString(fmt.Sprintf("*Total:* %d | %.0f%% WR | $%s", totalTrades, winRate, totalProfit.StringFixed(2)))
	}

	b.sendMarkdown(sb.String())
}

func (b *Bot) cmdToggleAlerts(chatID int64) {
	b.mu.Lock()
	b.alertsOn = !b.alertsOn
	status := b.alertsOn
	b.mu.Unlock()

	if status {
		b.send(chatID, "üîî Alerts ON")
	} else {
		b.send(chatID, "üîï Alerts OFF")
	}
}

func (b *Bot) cmdHelp(chatID int64) {
	msg := `üìñ *COMMANDS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

/status - Market prices & windows
/pos - Open scalp positions
/stats - Trading performance
/alerts - Toggle notifications

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
*Strategy:* Buy ‚â§20¬¢ ‚Üí Sell 33¬¢
*Stop Loss:* 15¬¢
*Max Age:* 10 min (need time for reversal)`

	b.sendMarkdown(msg)
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UPDATE HELPERS (for inline refresh buttons)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

func (b *Bot) updateStatus(chatID int64, msgID int) {
	var sb strings.Builder
	sb.WriteString("üìä *MARKET STATUS*\n")
	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

	for asset, engine := range b.engines {
		price := engine.GetCurrentPrice()
		windows := engine.GetWindowScanner().GetActiveWindows()
		if len(windows) > 0 {
			w := windows[0]
			sb.WriteString(fmt.Sprintf("*%s* | $%s\n", asset, price.StringFixed(2)))
			sb.WriteString(fmt.Sprintf("  UP: %s¬¢ | DOWN: %s¬¢\n",
				w.YesPrice.Mul(decimal.NewFromInt(100)).StringFixed(1),
				w.NoPrice.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			age := time.Since(w.StartDate)
			remaining := 15*time.Minute - age
			if remaining > 0 {
				sb.WriteString(fmt.Sprintf("  ‚è± %s left\n", remaining.Round(time.Second)))
			}
			sb.WriteString("\n")
		} else {
			sb.WriteString(fmt.Sprintf("*%s* | $%s | No window\n\n", asset, price.StringFixed(2)))
		}
	}

	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	sb.WriteString(fmt.Sprintf("Updated: %s", time.Now().Format("15:04:05")))

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîÑ Refresh", "refresh_status"),
		),
	)

	b.editWithKeyboard(chatID, msgID, sb.String(), keyboard)
}

func (b *Bot) updatePositions(chatID int64, msgID int) {
	var sb strings.Builder
	sb.WriteString("üí∞ *OPEN POSITIONS*\n")
	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

	hasPositions := false
	for asset, scalper := range b.scalpers {
		positions := scalper.GetPositions()
		for _, pos := range positions {
			hasPositions = true
			held := time.Since(pos.EntryTime).Round(time.Second)
			sb.WriteString(fmt.Sprintf("*%s %s*\n", asset, pos.Side))
			sb.WriteString(fmt.Sprintf("  Entry: %s¬¢\n", pos.EntryPrice.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			sb.WriteString(fmt.Sprintf("  Target: %s¬¢\n", pos.TargetPrice.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			sb.WriteString(fmt.Sprintf("  Stop: %s¬¢\n", pos.StopLoss.Mul(decimal.NewFromInt(100)).StringFixed(1)))
			sb.WriteString(fmt.Sprintf("  Held: %s\n\n", held))
		}
	}

	if !hasPositions {
		sb.WriteString("_No open positions_\n\n")
	}

	sb.WriteString("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	sb.WriteString(fmt.Sprintf("Updated: %s", time.Now().Format("15:04:05")))

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîÑ Refresh", "refresh_pos"),
		),
	)

	b.editWithKeyboard(chatID, msgID, sb.String(), keyboard)
}

func (b *Bot) toggleAlerts(chatID int64, msgID int) {
	b.mu.Lock()
	b.alertsOn = !b.alertsOn
	status := b.alertsOn
	b.mu.Unlock()

	msg := "üîï Alerts OFF"
	if status {
		msg = "üîî Alerts ON"
	}

	b.edit(chatID, msgID, msg)
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SEND HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

func (b *Bot) sendStartup() {
	if b.chatID == 0 {
		return
	}

	mode := "üü¢ LIVE"
	if b.cfg.DryRun {
		mode = "üìù PAPER"
	}

	msg := fmt.Sprintf(`‚ö° *POLYBOT STARTED*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Mode: %s
Assets: BTC, ETH, SOL
Strategy: Scalp ‚â§20¬¢ ‚Üí 33¬¢

/status for market info`, mode)

	b.sendMarkdown(msg)
}

func (b *Bot) send(chatID int64, text string) {
	msg := tgbotapi.NewMessage(chatID, text)
	b.api.Send(msg)
}

func (b *Bot) sendMarkdown(text string) {
	if b.chatID == 0 {
		return
	}
	msg := tgbotapi.NewMessage(b.chatID, text)
	msg.ParseMode = "Markdown"
	b.api.Send(msg)
}

func (b *Bot) sendWithKeyboard(chatID int64, text string, keyboard tgbotapi.InlineKeyboardMarkup) {
	msg := tgbotapi.NewMessage(chatID, text)
	msg.ParseMode = "Markdown"
	msg.ReplyMarkup = keyboard
	b.api.Send(msg)
}

func (b *Bot) edit(chatID int64, msgID int, text string) {
	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	b.api.Send(edit)
}

func (b *Bot) editWithKeyboard(chatID int64, msgID int, text string, keyboard tgbotapi.InlineKeyboardMarkup) {
	edit := tgbotapi.NewEditMessageText(chatID, msgID, text)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &keyboard
	b.api.Send(edit)
}


